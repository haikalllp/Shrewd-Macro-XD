This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app.manifest
build.bat
buildCommand.md
docs/architecture.md
docs/implementation_plan.md
docs/implementation_profile.md
docs/improvement.md
KnownIssue.md
LICENSE
MouseMacro.csproj
MouseMacro.sln
README.md
src/Configuration/ConfigurationEvents.cs
src/Configuration/ConfigurationManager.cs
src/Configuration/EventHandlerExtensions.cs
src/Configuration/EventHandlerManager.cs
src/Configuration/Validation.cs
src/Hooks/KeyboardHook.cs
src/Hooks/MouseHook.cs
src/Hooks/NativeMethods.cs
src/Hooks/WinMessages.cs
src/Models/AppSettings.cs
src/Models/HotkeySettings.cs
src/Models/InputBinding.cs
src/Models/InputBindingConverter.cs
src/Models/MacroSettings.cs
src/Models/UISettings.cs
src/Program.cs
src/UI/Controls/ModernButton.cs
src/UI/Controls/ModernTrackBar.cs
src/UI/MacroForm.cs
src/UI/MacroForm.Designer.cs
src/UI/MacroForm.resx
src/UI/Resources.Designer.cs
src/UI/Resources.resx
src/UI/UIManager.cs
src/Utilities/HotkeyManager.cs
src/Utilities/InputSimulator.cs
src/Utilities/JitterManager.cs
src/Utilities/MacroEffectBase.cs
src/Utilities/MacroManager.cs
src/Utilities/RecoilReductionManager.cs
src/Utilities/ToggleType.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="buildCommand.md">
# Batch (CMD)
dotnet clean && rmdir /s /q bin obj && dotnet restore && dotnet build -c Debug && dotnet build -c Release

# PowerShell
dotnet clean; Remove-Item -Recurse -Force bin,obj; dotnet restore; dotnet build -c Debug; dotnet build -c Release
</file>

<file path="app.manifest">
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="Notes&amp;Tasks"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="requireAdministrator" uiAccess="true" />
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
</file>

<file path="build.bat">
@echo off
:: Check for admin privileges
net session >nul 2>&1
if %errorLevel% == 0 (
    goto :admin
) else (
    echo Requesting administrative privileges...
    goto :UACPrompt
)

:UACPrompt
echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
echo UAC.ShellExecute "%~s0", "", "", "runas", 1 >> "%temp%\getadmin.vbs"
"%temp%\getadmin.vbs"
del "%temp%\getadmin.vbs"
exit /B

:admin
cd /d "%~dp0"

echo Starting Mouse Macro build process...
echo.

echo === Cleaning solution ===
dotnet clean
if errorlevel 1 goto error

echo === Removing build directories ===
if exist "bin" rmdir /s /q "bin"
if exist "obj" rmdir /s /q "obj"
if errorlevel 1 goto error

echo === Restoring packages ===
dotnet restore
if errorlevel 1 goto error

echo === Building Debug configuration ===
dotnet build -c Debug
if errorlevel 1 goto error

echo === Building Release configuration ===
dotnet build -c Release
if errorlevel 1 goto error

echo.
echo === Build Complete! ===
echo.
echo Debug build: %~dp0bin\Debug\net6.0-windows\NotesAndTasks.exe
echo Release build: %~dp0bin\Release\net6.0-windows\NotesAndTasks.exe
echo.
goto end

:error
echo.
echo Build failed! See error message above.
pause
exit /b 1

:end
echo Press any key to exit...
pause >nul
</file>

<file path="docs/implementation_profile.md">
# Profile System Implementation Plan

This document outlines the detailed plan for implementing the Profile System feature in the "MouseMacro" (Notes & Tasks) application. The feature will allow users to save, load, update, and manage multiple configuration profiles, with a default profile that cannot be deleted or updated. Profiles will be stored as JSON files in a dedicated directory alongside the executable, and the UI will include a dropdown menu for profile management, adhering to the application's modern theme.

## Table of Contents

- [Profile System Implementation Plan](#profile-system-implementation-plan)
  - [Table of Contents](#table-of-contents)
  - [Update Configuration Storage](#update-configuration-storage)
  - [Modify the UI](#modify-the-ui)
  - [Implement Profile Management Logic](#implement-profile-management-logic)
  - [Update Existing Code](#update-existing-code)
  - [Testing](#testing)

---

## Update Configuration Storage

The current application saves its state settings to a single JSON file in the executable folder via the `ConfigurationManager`. This section details how to extend this to support multiple profiles stored in a dedicated "Profiles" directory.

- **Create Profiles Directory:**
  - In the `ConfigurationManager` constructor, check if a "Profiles" directory exists in the executable folder. If not, create it using `Directory.CreateDirectory`.

- **Save Profile:**
  - Add a `SaveProfile(string profileName)` method to `ConfigurationManager`.
  - Validate the profile name to ensure it’s not null or empty.
  - Check if a profile with the same name exists. If it does (and isn’t the default profile), prompt the user to confirm overwriting.
  - Serialize the current configuration to JSON and save it as `${profileName}.json` in the "Profiles" directory.

- **Load Profile:**
  - Add a `LoadProfile(string profileName)` method to `ConfigurationManager`.
  - Validate the profile name.
  - Check if `${profileName}.json` exists in the "Profiles" directory. If not, display an error message.
  - Deserialize the JSON file into an `AppConfiguration` object and update the current configuration.

- **Update Profile:**
  - Add an `UpdateProfile(string profileName)` method to `ConfigurationManager`.
  - Validate the profile name.
  - Check if the profile is the default profile. If so, prevent the update and show a message (e.g., "The default profile cannot be updated").
  - Serialize the current configuration to JSON and overwrite the existing `${profileName}.json` file.

- **Rename Profile:**
  - Add a `RenameProfile(string oldName, string newName)` method to `ConfigurationManager`.
  - Validate both old and new names.
  - Check if the old profile is the default profile or if the new name already exists. If either condition is true, prevent the rename and show a message.
  - Rename the file from `${oldName}.json` to `${newName}.json` in the "Profiles" directory.

- **Get Profile Names:**
  - Add a `GetProfileNames()` method to `ConfigurationManager`.
  - Scan the "Profiles" directory for `.json` files and return a list of profile names (without the `.json` extension).

- **Default Profile:**
  - Define a constant `DEFAULT_PROFILE_NAME = "Default"`.
  - In the `ConfigurationManager` initialization, check if `Default.json` exists in the "Profiles" directory. If not, create it with default settings.
  - Ensure methods that modify profiles (update, rename) block operations on the default profile.

---

## Modify the UI

The UI will be updated to include a dropdown menu and buttons for profile management, following the application’s modern theme (e.g., consistent fonts, colors, and styles).

- **Add Profile Selection Dropdown:**
  - Add a `ComboBox` named `cmbProfiles` to the `settingsPanel`.
  - Style it to match the modern theme (e.g., use `JetBrains Mono` font, current color scheme).
  - Populate it with available profiles using `configManager.GetProfileNames()` when the form loads or after profile operations.

- **Add Profile Management Buttons:**
  - Add `ModernButton`s for the following actions:
    - "Save New Profile" (`btnSaveProfile`)
    - "Load Profile" (`btnLoadProfile`)
    - "Update Profile" (`btnUpdateProfile`)
    - "Rename Profile" (`btnRenameProfile`)
  - Arrange these buttons logically within the `settingsPanel`, ensuring alignment with existing controls.

- **Display Current Profile:**
  - Add a label (e.g., `lblCurrentProfile`) to show the current profile name, formatted as "Current Profile: [profileName]".
  - If the current profile is the default, append "(Default)" or adjust button states (e.g., disable update/rename).

- **UI Theme:**
  - Use the existing modern theme for all new controls:
    - Font: `JetBrains Mono`
    - Colors: Match the current scheme (e.g., dark background, light text)
    - Styles: Use `ModernButton` for buttons and apply consistent padding/margins.

---

## Implement Profile Management Logic

This section covers the logic behind profile operations, triggered by UI interactions.

- **Save New Profile:**
  - On `btnSaveProfile.Click`:
    - Prompt the user for a profile name via a dialog or text input.
    - Call `configManager.SaveProfile(profileName)`.
    - If successful, refresh `cmbProfiles` and select the new profile.

- **Load Profile:**
  - On `btnLoadProfile.Click`:
    - Get the selected profile from `cmbProfiles`.
    - Call `configManager.LoadProfile(selectedProfile)`.
    - If successful, update the UI and application state with the loaded settings.

- **Update Profile:**
  - On `btnUpdateProfile.Click`:
    - Check if the current profile is not the default.
    - If allowed, call `configManager.UpdateProfile(currentProfile)`.
    - If the default profile is selected, show a message (e.g., "Cannot update the default profile").

- **Rename Profile:**
  - On `btnRenameProfile.Click`:
    - Prompt the user for a new name.
    - Call `configManager.RenameProfile(currentProfile, newName)`.
    - If successful, refresh `cmbProfiles` and select the renamed profile.
    - If the default profile is selected, show a message (e.g., "Cannot rename the default profile").

- **Handle Default Profile:**
  - When `Default` is selected in `cmbProfiles`:
    - Disable `btnUpdateProfile` and `btnRenameProfile`.
    - Show a message if the user attempts to modify it.

---

## Update Existing Code

Integrate the Profile System with the existing codebase to ensure seamless operation.

- **Load Last Used Profile:**
  - Add a `LastUsedProfile` property to `AppConfiguration`.
  - On application startup:
    - Load the last used profile from the main configuration file.
    - If none exists or it’s invalid, load the default profile.

- **Update Current Profile:**
  - When settings are modified (e.g., via sliders or checkboxes):
    - If the current profile isn’t the default, call `configManager.UpdateProfile(currentProfile)` automatically.
    - If it’s the default, prompt the user to save a new profile or discard changes.

- **Switch Profiles:**
  - On `cmbProfiles.SelectedIndexChanged`:
    - Call `configManager.LoadProfile(selectedProfile)`.
    - Apply the loaded settings to the application and update `lblCurrentProfile`.

---

## Testing

Thorough testing ensures the feature meets all requirements and handles edge cases.

- **Test Cases:**
  - **Save Profile:** Create a new profile and verify a `${profileName}.json` file appears in the "Profiles" directory.
  - **Load Profile:** Load different profiles and confirm settings (e.g., jitter strength, hotkeys) apply correctly.
  - **Update Profile:** Modify settings, update a profile, and check that the JSON file reflects the changes.
  - **Rename Profile:** Rename a profile and verify the file name changes in the "Profiles" directory.
  - **Default Profile Protection:** Attempt to update or rename the default profile and ensure it’s blocked with a message.
  - **UI Updates:** Confirm `cmbProfiles` and `lblCurrentProfile` refresh correctly after each operation.

- **Edge Cases:**
  - Save a profile with an existing name and verify overwrite confirmation.
  - Attempt to load a non-existent profile and check for error handling.
  - Switch between multiple profiles and ensure settings apply consistently.
  - Delete `Default.json` manually, restart the app, and confirm it’s recreated.

---

This plan ensures the Profile System meets all specified requirements:
- Saving and loading named profiles as JSON files in a "Profiles" directory.
- Updating and renaming profiles, with a protected default profile.
- A modern-themed UI with a dropdown menu for profile management.
- Integration with the existing configuration system.
</file>

<file path="docs/improvement.md">
# Improvement Plan for MouseMacro Project

## Overview
This plan outlines a structured approach to enhance the "MouseMacro" project by improving its modularization, professionalism, and code quality. The focus is on aligning the project with best practices for C# .NET development (using .NET 6.0), organizing the directory structure for clarity, and refining the codebase while preserving all existing functionality and integrity.

## Goals
- **Modularization**: Break the code into smaller, well-defined modules with single responsibilities.
- **Directory Structure**: Organize files into logical folders for a neat and maintainable structure.
- **Code Quality**: Apply best practices like SOLID principles, clean code, and robust error handling.
- **Configuration Management**: Enhance the handling of configuration settings for efficiency and security.
- **UI and Business Logic Separation**: Decouple UI code from business logic for better testability and maintainability.
- **Documentation**: Add comprehensive documentation to improve understanding and future maintenance.
- **Testing**: Introduce unit tests to ensure functionality and prevent regressions.

## Step-by-Step Plan

### 1. Backup the Current Project
- **Action**: Create a full backup of the project directory.
- **Purpose**: Preserve the original code to avoid accidental loss during refactoring.
- **How**: Copy the entire project folder to a safe location (e.g., external drive or version control system like Git).

### 2. Organize Directory Structure
- **Action**: Restructure the project files into logical folders.
- **New Structure**:
  - `src/`: Contains all source code files.
    - `UI/`: For Windows Forms and custom controls (e.g., `MacroForm.cs`).
    - `Configuration/`: For settings management (e.g., `SettingsManager.cs`).
    - `Hooks/`: For low-level input handling (e.g., `NativeMethods.cs`).
    - `Utilities/`: For helper and manager classes.
    - `Models/`: For data models (if any).
  - `tests/`: For unit test projects.
  - `docs/`: For documentation files.
- **Steps**:
  1. Create the above folders in the project directory.
  2. Move existing files to their respective folders (e.g., `MacroForm.cs` to `src/UI/`).
  3. Update the project file (`MouseMacro.csproj`) to reflect the new file paths.
- **Outcome**: A cleaner, more organized project layout.

### 3. Extract Hook Logic
- **Action**: Move hook-related functionality into dedicated classes.
- **Steps**:
  1. Create `KeyboardHook.cs` and `MouseHook.cs` in `src/Hooks/`.
  2. Move hook initialization, callback methods, and disposal logic from `MacroForm.cs` to these classes.
  3. Expose public methods (e.g., `Start()`, `Stop()`) for controlling the hooks.
- **Outcome**: Hook logic is encapsulated, adhering to the Single Responsibility Principle (SRP).

### 4. Create Manager Classes
- **Action**: Extract business logic into manager classes.
- **Steps**:
  1. Create `JitterManager.cs` and `RecoilReductionManager.cs` in `src/Utilities/` for jitter and recoil reduction logic.
  2. Move relevant methods (e.g., `OnJitterTimer`) into these classes.
  3. Create `MacroManager.cs` in `src/Utilities/` to coordinate macro state and interactions between managers.
  4. Update `MacroForm.cs` to delegate tasks to these managers.
- **Outcome**: Business logic is modularized, reducing the complexity of `MacroForm.cs`.

### 5. Refactor MacroForm.cs
- **Action**: Simplify the form class by removing business logic.
- **Steps**:
  1. Use dependency injection to inject `MacroManager`, `JitterManager`, and `RecoilReductionManager` into `MacroForm.cs`.
  2. Refactor event handlers to call methods on the manager classes.
  3. Keep `MacroForm.cs` focused on UI updates and event wiring.
- **Outcome**: A cleaner separation between UI and logic, improving maintainability.

### 6. Improve Configuration Management
- **Action**: Enhance the `SettingsManager.cs` class.
- **Steps**:
  1. Integrate `Microsoft.Extensions.Configuration` for robust configuration handling.
  2. Store the JSON configuration file in a standard location (e.g., `%AppData%/MouseMacro/`).
  3. Add validation to ensure configuration values are valid (e.g., ranges for jitter settings).
  4. Handle file I/O exceptions gracefully.
- **Outcome**: Configuration management is more professional and secure.

### 7. Separate UI and Business Logic
- **Action**: Implement a design pattern to decouple UI and logic.
- **Steps**:
  1. Choose the Model-View-Presenter (MVP) pattern for simplicity.
  2. Create a `MacroPresenter.cs` class in `src/UI/Presenters/` to handle business logic.
  3. Move logic from `MacroForm.cs` to `MacroPresenter.cs`.
  4. Update `MacroForm.cs` to interact with the presenter via an interface (e.g., `IMacroView`).
- **Outcome**: UI and business logic are fully separated, enhancing testability.

### 8. Enhance Code Quality
- **Action**: Apply best practices throughout the codebase.
- **Steps**:
  1. Rename variables and methods for clarity (e.g., `btnToggle` to `toggleButton`).
  2. Remove unused code and variables identified during refactoring.
  3. Use consistent formatting (e.g., indentation, brace style).
  4. Apply DRY (Don't Repeat Yourself) by consolidating duplicated code.
  5. Use `readonly` for immutable fields and `const` for constants.
  6. Add exception handling with meaningful error messages.
  7. Integrate a logging framework (e.g., Serilog) for debugging.
- **Outcome**: Code is cleaner, more readable, and adheres to C# best practices.

### 9. Add Documentation
- **Action**: Document the codebase for future maintainers.
- **Steps**:
  1. Add XML comments to all public classes, methods, and properties (e.g., `/// <summary>`).
  2. Create a `README.md` file in the root directory with:
     - Project overview
     - Setup instructions
     - Usage guidelines
  3. Place additional documentation (e.g., architecture overview) in `docs/`.
- **Outcome**: Code is well-documented, easing onboarding and maintenance.

### 10. Implement Unit Tests
- **Action**: Add tests to verify functionality.
- **Steps**:
  1. Create a test project under `tests/` using a framework like xUnit.
  2. Write tests for:
     - Hook initialization and callbacks
     - Jitter and recoil reduction logic
     - Configuration loading/saving
     - Macro state management
  3. Mock dependencies (e.g., hooks) using a library like Moq.
  4. Run tests to ensure 100% coverage of critical components.
- **Outcome**: Functionality is validated, and regressions are prevented.

### 11. Test the Application
- **Action**: Manually verify the refactored application.
- **Steps**:
  1. Run the application and test all features (e.g., macro toggling, settings changes).
  2. Verify UI updates (e.g., button states, labels).
  3. Ensure hooks work correctly (e.g., mouse/keyboard input capture).
  4. Confirm configuration persists across sessions.
- **Outcome**: Assurance that functionality and integrity are intact.

### 12. Review and Iterate
- **Action**: Finalize the improvements.
- **Steps**:
  1. Review the refactored code for adherence to goals.
  2. Address any issues found during testing.
  3. Commit changes to version control (if not already using Git).
- **Outcome**: A polished, professional codebase ready for future development.

## Conclusion
This plan transforms the "MouseMacro" project into a modular, professional, and maintainable application. By following these steps, you’ll achieve a tidy directory structure, improved code quality, and adherence to C# .NET 6.0 best practices—all while preserving the program’s original functionality and integrity. Each step builds incrementally, allowing for validation at every stage to ensure a smooth transition.
</file>

<file path="KnownIssue.md">
# Known Issues
- Plateaued on settings from 3 - 5 (Speed and strength from 3-5 is same)

- Macro config format need to be fixed, current:
```json
{
  "JitterStrength": 0,
  "RecoilReductionStrength": 0,
  "AlwaysJitterMode": false,
  "AlwaysRecoilReductionMode": false,
  "JitterEnabled": false,
  "RecoilReductionEnabled": false,
  "MinimizeToTray": false,
  "MacroKey": 20,
  "SwitchKey": 81,
  "ToggleType": 0
}
```
- Fix config name to settings.json
- fix macro key to actual name
- fix switch key to actual name
- allow for mix of keyboard and mouse for binding, e.g. (meaning macro key can be keyboard, switch key can be mouse. and vice versa.)

- make default settings to be:
```json
{
  "JitterStrength": 3,
  "RecoilReductionStrength": 1,
  "AlwaysJitterMode": false,
  "AlwaysRecoilReductionMode": false,
  "JitterEnabled": false,
  "RecoilReductionEnabled": false,
  "MinimizeToTray": false,
  "MacroKey": Capital,
  "SwitchKey": Q
}
```

- Ensure program create config in same location as exe
- Ensure JSON config created upon first time running app
- Ensure app updates config after every change is made
- Ensure config is actually updated and saved for next loading

- Repetition of implementation in InputSimulator.cs and JitterManager.cs
- Repetition of implementation in InputSimulator.cs and RecoilReductionManager.cs
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Notes&Tasks (Mouse Macro)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="MouseMacro.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35818.85 d17.13
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MouseMacro", "MouseMacro.csproj", "{1FFAD009-1089-42F1-C326-6CC678F746BF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E2EE0FEB-3FDA-4BFB-A0AF-B207C69E2C25}
	EndGlobalSection
EndGlobal
</file>

<file path="src/Configuration/EventHandlerExtensions.cs">
using System;
using System.Windows.Forms;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Provides extension methods for event handler registration.
    /// </summary>
    public static class EventHandlerExtensions
    {
        /// <summary>
        /// Registers all event handlers for a control with the event handler manager.
        /// </summary>
        /// <param name="control">The control to register events for.</param>
        /// <param name="manager">The event handler manager.</param>
        /// <returns>The control for method chaining.</returns>
        public static T RegisterEvents<T>(this T control, EventHandlerManager manager) where T : Control
        {
            manager.RegisterControlEvents(control);
            return control;
        }

        /// <summary>
        /// Unregisters all event handlers for a control from the event handler manager.
        /// </summary>
        /// <param name="control">The control to unregister events for.</param>
        /// <param name="manager">The event handler manager.</param>
        /// <returns>The control for method chaining.</returns>
        public static T UnregisterEvents<T>(this T control, EventHandlerManager manager) where T : Control
        {
            manager.UnregisterControlEvents(control);
            return control;
        }

        /// <summary>
        /// Registers a specific event handler with tracking.
        /// </summary>
        /// <param name="control">The control to register the event for.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The event handler delegate.</param>
        /// <param name="manager">The event handler manager.</param>
        /// <returns>The control for method chaining.</returns>
        public static T RegisterEventHandler<T>(this T control, string eventName, Delegate handler, EventHandlerManager manager) where T : Control
        {
            if (string.IsNullOrEmpty(eventName))
                throw new ArgumentNullException(nameof(eventName));

            if (handler == null)
                throw new ArgumentNullException(nameof(handler));

            // Add the event handler to the manager's tracking
            typeof(EventHandlerManager)
                .GetMethod("RegisterEventHandler", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
                ?.Invoke(manager, new object[] { $"{control.Name}_{eventName}", handler });

            return control;
        }

        /// <summary>
        /// Registers common event handlers for a TrackBar control.
        /// </summary>
        public static TrackBar RegisterTrackBarEvents(this TrackBar trackBar, EventHandlerManager manager, Action<int> onValueChanged = null)
        {
            if (onValueChanged != null)
            {
                EventHandler valueChangedHandler = (s, e) => onValueChanged(trackBar.Value);
                trackBar.RegisterEventHandler("ValueChanged", valueChangedHandler, manager);
                trackBar.ValueChanged += valueChangedHandler;
            }
            return trackBar;
        }

        /// <summary>
        /// Registers common event handlers for a CheckBox control.
        /// </summary>
        public static CheckBox RegisterCheckBoxEvents(this CheckBox checkBox, EventHandlerManager manager, Action<bool> onCheckedChanged = null)
        {
            if (onCheckedChanged != null)
            {
                EventHandler checkedChangedHandler = (s, e) => onCheckedChanged(checkBox.Checked);
                checkBox.RegisterEventHandler("CheckedChanged", checkedChangedHandler, manager);
                checkBox.CheckedChanged += checkedChangedHandler;
            }
            return checkBox;
        }

        /// <summary>
        /// Registers common event handlers for a Button control.
        /// </summary>
        public static Button RegisterButtonEvents(this Button button, EventHandlerManager manager, Action onClick = null)
        {
            if (onClick != null)
            {
                EventHandler clickHandler = (s, e) => onClick();
                button.RegisterEventHandler("Click", clickHandler, manager);
                button.Click += clickHandler;
            }
            return button;
        }

        /// <summary>
        /// Registers common event handlers for a TextBox control.
        /// </summary>
        public static TextBox RegisterTextBoxEvents(this TextBox textBox, EventHandlerManager manager, 
            Action<string> onTextChanged = null,
            Action<KeyEventArgs> onKeyDown = null)
        {
            if (onTextChanged != null)
            {
                EventHandler textChangedHandler = (s, e) => onTextChanged(textBox.Text);
                textBox.RegisterEventHandler("TextChanged", textChangedHandler, manager);
                textBox.TextChanged += textChangedHandler;
            }

            if (onKeyDown != null)
            {
                KeyEventHandler keyDownHandler = (s, e) => onKeyDown(e);
                textBox.RegisterEventHandler("KeyDown", keyDownHandler, manager);
                textBox.KeyDown += keyDownHandler;
            }

            return textBox;
        }
    }
}
</file>

<file path="src/Models/InputBinding.cs">
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Forms;

namespace NotesAndTasks.Models
{
    /// <summary>
    /// Enumeration of input types
    /// </summary>
    public enum InputType
    {
        /// <summary>
        /// Keyboard input
        /// </summary>
        Keyboard,
        
        /// <summary>
        /// Mouse input
        /// </summary>
        Mouse
    }

    /// <summary>
    /// Represents a keyboard or mouse binding for a command
    /// </summary>
    public class InputBinding : INotifyPropertyChanged
    {
        private Keys _key;
        private InputType _type;
        private string _displayName;

        /// <summary>
        /// Gets or sets the key code
        /// </summary>
        public Keys Key
        {
            get => _key;
            set
            {
                if (_key != value)
                {
                    _key = value;
                    DisplayName = _key.ToString();
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets the input type (keyboard or mouse)
        /// </summary>
        public InputType Type
        {
            get => _type;
            set
            {
                if (_type != value)
                {
                    _type = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets the display name for the key
        /// </summary>
        public string DisplayName
        {
            get => _displayName;
            set
            {
                if (_displayName != value)
                {
                    _displayName = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Initializes a new instance of the InputBinding class
        /// </summary>
        public InputBinding()
        {
            _key = Keys.None;
            _type = InputType.Keyboard;
            _displayName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the InputBinding class with specified key and type
        /// </summary>
        /// <param name="key">The key code</param>
        /// <param name="type">The input type</param>
        public InputBinding(Keys key, InputType type)
        {
            _key = key;
            _type = type;
            _displayName = key.ToString();
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
</file>

<file path="src/Models/InputBindingConverter.cs">
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Windows.Forms;

namespace NotesAndTasks.Models
{
    /// <summary>
    /// Custom JSON converter for InputBinding objects to ensure proper serialization
    /// </summary>
    public class InputBindingConverter : JsonConverter<InputBinding>
    {
        /// <summary>
        /// Reads and converts the JSON to an InputBinding
        /// </summary>
        public override InputBinding Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            if (reader.TokenType != JsonTokenType.StartObject)
            {
                throw new JsonException("Expected start of object");
            }

            var result = new InputBinding();
            
            while (reader.Read() && reader.TokenType != JsonTokenType.EndObject)
            {
                if (reader.TokenType != JsonTokenType.PropertyName)
                {
                    throw new JsonException("Expected property name");
                }

                string propertyName = reader.GetString();
                reader.Read();

                switch (propertyName)
                {
                    case "Key":
                        if (reader.TokenType == JsonTokenType.String)
                        {
                            string keyName = reader.GetString();
                            if (Enum.TryParse<Keys>(keyName, out Keys key))
                            {
                                result.Key = key;
                            }
                        }
                        else if (reader.TokenType == JsonTokenType.Number)
                        {
                            int keyValue = reader.GetInt32();
                            result.Key = (Keys)keyValue;
                        }
                        break;

                    case "Type":
                        if (reader.TokenType == JsonTokenType.String)
                        {
                            string typeName = reader.GetString();
                            if (Enum.TryParse<InputType>(typeName, out InputType type))
                            {
                                result.Type = type;
                            }
                        }
                        else if (reader.TokenType == JsonTokenType.Number)
                        {
                            int typeValue = reader.GetInt32();
                            result.Type = (InputType)typeValue;
                        }
                        break;

                    case "DisplayName":
                        if (reader.TokenType == JsonTokenType.String)
                        {
                            result.DisplayName = reader.GetString();
                        }
                        break;
                }
            }

            return result;
        }

        /// <summary>
        /// Writes the InputBinding as JSON with enum values as strings
        /// </summary>
        public override void Write(Utf8JsonWriter writer, InputBinding value, JsonSerializerOptions options)
        {
            writer.WriteStartObject();
            
            writer.WritePropertyName("Key");
            writer.WriteStringValue(value.Key.ToString());
            
            writer.WritePropertyName("Type");
            writer.WriteStringValue(value.Type.ToString());
            
            writer.WritePropertyName("DisplayName");
            writer.WriteStringValue(value.DisplayName ?? value.Key.ToString());
            
            writer.WriteEndObject();
        }
    }
}
</file>

<file path="src/UI/Controls/ModernButton.cs">
using System.Drawing.Drawing2D;
using System.ComponentModel;

namespace NotesAndTasks
{
    public class ModernButton : Button
    {
        private int borderRadius = 10;
        private Color borderColor = Color.FromArgb(250, 91, 101);
        private Color hoverBackColor = Color.FromArgb(214, 37, 106);
        private bool isHovered = false;

        [Category("Modern Button")]
        public int BorderRadius
        {
            get => borderRadius;
            set
            {
                borderRadius = value;
                Invalidate();
            }
        }

        [Category("Modern Button")]
        public Color BorderColor
        {
            get => borderColor;
            set
            {
                borderColor = value;
                Invalidate();
            }
        }

        [Category("Modern Button")]
        public Color HoverBackColor
        {
            get => hoverBackColor;
            set
            {
                hoverBackColor = value;
                Invalidate();
            }
        }

        public ModernButton()
        {
            FlatStyle = FlatStyle.Flat;
            FlatAppearance.BorderSize = 0;
            BackColor = Color.FromArgb(30, 1, 62);
            ForeColor = Color.White;
            Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            Size = new Size(150, 40);
            Cursor = Cursors.Hand;

            MouseEnter += (s, e) =>
            {
                isHovered = true;
                Invalidate();
            };

            MouseLeave += (s, e) =>
            {
                isHovered = false;
                Invalidate();
            };
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            var graphicsPath = new GraphicsPath();
            var rect = new Rectangle(0, 0, Width - 1, Height - 1);
            int radius = borderRadius;

            // Create rounded rectangle path
            graphicsPath.AddArc(rect.X, rect.Y, radius * 2, radius * 2, 180, 90);
            graphicsPath.AddArc(rect.Right - radius * 2, rect.Y, radius * 2, radius * 2, 270, 90);
            graphicsPath.AddArc(rect.Right - radius * 2, rect.Bottom - radius * 2, radius * 2, radius * 2, 0, 90);
            graphicsPath.AddArc(rect.X, rect.Bottom - radius * 2, radius * 2, radius * 2, 90, 90);
            graphicsPath.CloseFigure();

            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;

            // Fill background
            using (var brush = new SolidBrush(isHovered ? hoverBackColor : BackColor))
            {
                e.Graphics.FillPath(brush, graphicsPath);
            }

            // Draw border
            using (var pen = new Pen(borderColor, 1))
            {
                e.Graphics.DrawPath(pen, graphicsPath);
            }

            // Draw text
            var textRect = new Rectangle(0, 0, Width, Height);
            TextRenderer.DrawText(e.Graphics, Text, Font, textRect, ForeColor,
                TextFormatFlags.HorizontalCenter | TextFormatFlags.VerticalCenter);

            graphicsPath.Dispose();
        }
    }
}
</file>

<file path="src/UI/Controls/ModernTrackBar.cs">
using System.Drawing.Drawing2D;
using System.ComponentModel;

namespace NotesAndTasks
{
    public class ModernTrackBar : TrackBar
    {
        private Color tickColor = Color.FromArgb(250, 91, 101);
        private Color trackColor = Color.FromArgb(214, 37, 106);
        private Color thumbColor = Color.FromArgb(255,255,255);
        private bool isDragging = false;

        [Category("Modern TrackBar")]
        public Color TickColor
        {
            get => tickColor;
            set
            {
                tickColor = value;
                Invalidate();
            }
        }

        [Category("Modern TrackBar")]
        public Color TrackColor
        {
            get => trackColor;
            set
            {
                trackColor = value;
                Invalidate();
            }
        }

        [Category("Modern TrackBar")]
        public Color ThumbColor
        {
            get => thumbColor;
            set
            {
                thumbColor = value;
                Invalidate();
            }
        }

        public ModernTrackBar()
        {
            SetStyle(ControlStyles.UserPaint | 
                    ControlStyles.AllPaintingInWmPaint | 
                    ControlStyles.OptimizedDoubleBuffer, true);

            ValueChanged += (s, e) => Invalidate();
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                isDragging = true;
                UpdateValue(e.X);
            }
            base.OnMouseDown(e);
        }

        protected override void OnMouseMove(MouseEventArgs e)
        {
            if (isDragging)
            {
                UpdateValue(e.X);
            }
            base.OnMouseMove(e);
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                isDragging = false;
            }
            base.OnMouseUp(e);
        }

        private void UpdateValue(int mouseX)
        {
            if (mouseX < 10) mouseX = 10;
            if (mouseX > Width - 10) mouseX = Width - 10;

            float valueRange = Maximum - Minimum;
            float pixelRange = Width - 20;
            float valuePerPixel = valueRange / pixelRange;

            int newValue = (int)((mouseX - 10) * valuePerPixel) + Minimum;
            if (newValue < Minimum) newValue = Minimum;
            if (newValue > Maximum) newValue = Maximum;

            Value = newValue;
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
            e.Graphics.Clear(BackColor);

            var trackRect = new Rectangle(0, Height / 2 - 2, Width - 1, 4);
            using (var trackBrush = new SolidBrush(trackColor))
            {
                e.Graphics.FillRectangle(trackBrush, trackRect);
            }

            // Draw ticks
            if (TickStyle != TickStyle.None)
            {
                using (var tickPen = new Pen(tickColor, 1))
                {
                    int tickCount = Maximum - Minimum;
                    float tickSpacing = (Width - 20) / (float)tickCount;
                    for (int i = 0; i <= tickCount; i++)
                    {
                        int x = 10 + (int)(i * tickSpacing);
                        e.Graphics.DrawLine(tickPen, x, Height / 2 + 5, x, Height / 2 + 10);
                    }
                }
            }

            // Draw thumb
            float thumbPosition = (Value - Minimum) * (Width - 20) / (float)(Maximum - Minimum) + 10;
            var thumbRect = new Rectangle((int)thumbPosition - 6, Height / 2 - 6, 12, 12);
            using (var thumbBrush = new SolidBrush(thumbColor))
            {
                e.Graphics.FillEllipse(thumbBrush, thumbRect);
            }
        }
    }
}
</file>

<file path="src/UI/MacroForm.resx">
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="notifyIcon.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="trayContextMenu.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>125, 17</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>45</value>
  </metadata>
</root>
</file>

<file path="src/UI/Resources.Designer.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NotesTasks.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("NotesTasks.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
</file>

<file path="src/UI/Resources.resx">
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
</file>

<file path="src/UI/UIManager.cs">
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using NotesAndTasks.Configuration;
using NotesAndTasks.Utilities;

namespace NotesAndTasks.UI
{
    /// <summary>
    /// Manages UI-specific operations and state updates.
    /// </summary>
    public class UIManager : IDisposable
    {
        #region Fields
        private readonly Form form;
        private readonly MacroManager macroManager;
        private readonly HotkeyManager hotkeyManager;
        private readonly TextBox debugLabel;
        private readonly Label lblJitterActive;
        private readonly Label lblRecoilReductionActive;
        private readonly Label lblCurrentKeyValue;
        private readonly Label lblMacroSwitchKeyValue;
        private readonly Label lblJitterStrengthValue;
        private readonly Label lblRecoilReductionStrengthValue;
        private readonly NotifyIcon notifyIcon;
        private readonly ToolTip toolTip;
        private bool disposed = false;
        #endregion

        #region Constructor
        public UIManager(
            Form form,
            MacroManager macroManager,
            HotkeyManager hotkeyManager,
            TextBox debugLabel,
            Label lblJitterActive,
            Label lblRecoilReductionActive,
            Label lblCurrentKeyValue,
            Label lblMacroSwitchKeyValue,
            Label lblJitterStrengthValue,
            Label lblRecoilReductionStrengthValue,
            NotifyIcon notifyIcon,
            ToolTip toolTip)
        {
            this.form = form ?? throw new ArgumentNullException(nameof(form));
            this.macroManager = macroManager ?? throw new ArgumentNullException(nameof(macroManager));
            this.hotkeyManager = hotkeyManager ?? throw new ArgumentNullException(nameof(hotkeyManager));
            this.debugLabel = debugLabel ?? throw new ArgumentNullException(nameof(debugLabel));
            this.lblJitterActive = lblJitterActive ?? throw new ArgumentNullException(nameof(lblJitterActive));
            this.lblRecoilReductionActive = lblRecoilReductionActive ?? throw new ArgumentNullException(nameof(lblRecoilReductionActive));
            this.lblCurrentKeyValue = lblCurrentKeyValue ?? throw new ArgumentNullException(nameof(lblCurrentKeyValue));
            this.lblMacroSwitchKeyValue = lblMacroSwitchKeyValue ?? throw new ArgumentNullException(nameof(lblMacroSwitchKeyValue));
            this.lblJitterStrengthValue = lblJitterStrengthValue ?? throw new ArgumentNullException(nameof(lblJitterStrengthValue));
            this.lblRecoilReductionStrengthValue = lblRecoilReductionStrengthValue ?? throw new ArgumentNullException(nameof(lblRecoilReductionStrengthValue));
            this.notifyIcon = notifyIcon ?? throw new ArgumentNullException(nameof(notifyIcon));
            this.toolTip = toolTip ?? throw new ArgumentNullException(nameof(toolTip));

            InitializeTooltips();
            InitializeIcon();
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Updates the form title to reflect current macro state and mode.
        /// </summary>
        public void UpdateTitle()
        {
            string jitterMode = macroManager.IsAlwaysJitterMode ? "Always Jitter" :
                (macroManager.IsJitterEnabled ? "Jitter" : "Jitter (OFF)");

            string recoilMode = macroManager.IsAlwaysRecoilReductionMode ? "Always Recoil Reduction" :
                (macroManager.IsJitterEnabled ? "Recoil Reduction (OFF)" : "Recoil Reduction");

            form.Text = $"Notes&Tasks [{(macroManager.IsEnabled ? "ON" : "OFF")}] - {jitterMode} / {recoilMode} Mode";
            UpdateModeLabels();
        }

        /// <summary>
        /// Updates the displayed current key binding for macro toggle.
        /// </summary>
        /// <param name="key">The key name to display.</param>
        public void UpdateCurrentKey(string key)
        {
            if (lblCurrentKeyValue != null)
            {
                lblCurrentKeyValue.Text = key;
            }
        }

        /// <summary>
        /// Updates the displayed key binding for mode switching.
        /// </summary>
        /// <param name="key">The key name to display.</param>
        public void UpdateSwitchKey(string key)
        {
            if (lblMacroSwitchKeyValue != null)
            {
                lblMacroSwitchKeyValue.Text = key;
            }
        }

        /// <summary>
        /// Updates the displayed jitter strength value.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="strength">The strength value to display (1-20).</param>
        public void UpdateJitterStrength(int strength)
        {
            try
            {
                if (form.InvokeRequired)
                {
                    form.Invoke(new Action<int>(UpdateJitterStrength), strength);
                    return;
                }

                lblJitterStrengthValue.Text = strength.ToString();
                UpdateDebugInfo($"Jitter strength updated to: {strength}");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error updating jitter strength: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates the displayed recoil reduction strength value.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="strength">The strength value to display (1-20).</param>
        public void UpdateRecoilReductionStrength(int strength)
        {
            try
            {
                if (form.InvokeRequired)
                {
                    form.Invoke(new Action<int>(UpdateRecoilReductionStrength), strength);
                    return;
                }

                lblRecoilReductionStrengthValue.Text = strength.ToString();
                UpdateDebugInfo($"Recoil reduction strength updated to: {strength}");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error updating recoil reduction strength: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates the displayed macro switch key value.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="key">The key name to display.</param>
        public void UpdateMacroSwitchKey(string key)
        {
            if (form.InvokeRequired)
            {
                form.Invoke(new Action<string>(UpdateMacroSwitchKey), key);
                return;
            }
            lblMacroSwitchKeyValue.Text = key;
            UpdateDebugInfo($"Macro switch key updated to: {key}");
        }

        /// <summary>
        /// Updates the active mode labels in the UI.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        public void UpdateModeLabels()
        {
            if (form.InvokeRequired)
            {
                form.Invoke(new Action(UpdateModeLabels));
                return;
            }

            lblRecoilReductionActive.Text = (!macroManager.IsJitterEnabled && macroManager.IsEnabled) ? "[Active]" : "";
            lblJitterActive.Text = (macroManager.IsJitterEnabled && macroManager.IsEnabled) ? "[Active]" : "";
        }

        /// <summary>
        /// Shows and activates the main window when restored from system tray.
        /// </summary>
        public void ShowWindow()
        {
            form.Show();
            form.WindowState = FormWindowState.Normal;
            form.Activate();
            notifyIcon.Visible = false;
            UpdateDebugInfo("Application restored from system tray");
        }

        /// <summary>
        /// Adds a debug message to the debug panel with timestamp.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="message">The debug message to display.</param>
        public void UpdateDebugInfo(string message)
        {
            if (debugLabel.InvokeRequired)
            {
                debugLabel.Invoke(new Action(() => UpdateDebugInfo(message)));
                return;
            }

            string timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
            string newLine = $"[{timestamp}] {message}";

            // Keep last 100 lines of debug info
            var lines = debugLabel.Lines.ToList();
            lines.Add(newLine);
            if (lines.Count > 100)
            {
                lines.RemoveAt(0);
            }
            debugLabel.Lines = lines.ToArray();

            // Auto-scroll to bottom
            debugLabel.SelectionStart = debugLabel.TextLength;
            debugLabel.ScrollToCaret();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Initializes tooltips for various UI controls to provide user guidance.
        /// </summary>
        private void InitializeTooltips()
        {
            toolTip.SetToolTip(form.Controls.Find("chkAlwaysJitter", true).FirstOrDefault(), "Always keep Jitter enabled");
            toolTip.SetToolTip(form.Controls.Find("trackBarJitter", true).FirstOrDefault(), "Adjust Jitter strength");
            toolTip.SetToolTip(form.Controls.Find("chkAlwaysRecoilReduction", true).FirstOrDefault(), "Always keep Recoil Reduction enabled");
            toolTip.SetToolTip(form.Controls.Find("trackBarRecoilReduction", true).FirstOrDefault(), "Adjust Recoil Reduction strength");
            toolTip.SetToolTip(form.Controls.Find("chkMinimizeToTray", true).FirstOrDefault(), "Minimize to system tray when closing");
        }

        /// <summary>
        /// Initializes the application icon for both the main window and system tray.
        /// </summary>
        private void InitializeIcon()
        {
            try
            {
                using var icon = Icon.ExtractAssociatedIcon(Application.ExecutablePath);
                if (icon != null)
                {
                    form.Icon = (Icon)icon.Clone();
                    notifyIcon.Icon = (Icon)icon.Clone();
                }
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error loading icon: {ex.Message}");
            }
        }
        #endregion

        #region IDisposable Implementation
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    notifyIcon?.Dispose();
                    toolTip?.Dispose();
                }
                disposed = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}
</file>

<file path="src/Utilities/ToggleType.cs">
namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Defines the types of input that can be used to toggle the macro functionality.
    /// </summary>
    public enum ToggleType
    {
        /// <summary>Keyboard key input</summary>
        Keyboard,
        /// <summary>Middle mouse button input</summary>
        MouseMiddle,
        /// <summary>Mouse button 4 (XButton1) input</summary>
        MouseX1,
        /// <summary>Mouse button 5 (XButton2) input</summary>
        MouseX2
    }
}
</file>

<file path="src/Configuration/Validation.cs">
using System;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Provides validation methods for input values throughout the application.
    /// </summary>
    internal static class Validation
    {
        /// <summary>
        /// Validates a strength value for jitter or recoil reduction.
        /// </summary>
        /// <param name="strength">The strength value to validate.</param>
        /// <param name="minValue">The minimum allowed value (inclusive).</param>
        /// <param name="maxValue">The maximum allowed value (inclusive).</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the strength value is outside the valid range.</exception>
        public static void ValidateStrength(int strength, int minValue, int maxValue, string paramName)
        {
            if (strength < minValue || strength > maxValue)
            {
                throw new ArgumentOutOfRangeException(
                    paramName,
                    strength,
                    $"Strength value must be between {minValue} and {maxValue}."
                );
            }
        }

        /// <summary>
        /// Validates that a string parameter is not null or empty.
        /// </summary>
        /// <param name="value">The string value to validate.</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentNullException">Thrown when the value is null.</exception>
        /// <exception cref="ArgumentException">Thrown when the value is empty.</exception>
        public static void ValidateStringNotNullOrEmpty(string value, string paramName)
        {
            if (value == null)
            {
                throw new ArgumentNullException(paramName);
            }
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Value cannot be empty or whitespace.", paramName);
            }
        }

        /// <summary>
        /// Validates that a reference parameter is not null.
        /// </summary>
        /// <typeparam name="T">The type of the parameter.</typeparam>
        /// <param name="value">The value to validate.</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentNullException">Thrown when the value is null.</exception>
        public static void ValidateNotNull<T>(T value, string paramName) where T : class
        {
            if (value == null)
            {
                throw new ArgumentNullException(paramName);
            }
        }

        /// <summary>
        /// Validates that a handle is not IntPtr.Zero.
        /// </summary>
        /// <param name="handle">The handle to validate.</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentException">Thrown when the handle is IntPtr.Zero.</exception>
        public static void ValidateHandle(IntPtr handle, string paramName)
        {
            if (handle == IntPtr.Zero)
            {
                throw new ArgumentException("Handle cannot be zero.", paramName);
            }
        }

        /// <summary>
        /// Validates that a hook code is valid for processing.
        /// </summary>
        /// <param name="nCode">The hook code to validate.</param>
        /// <returns>True if the hook code should be processed, false if it should be passed to the next hook.</returns>
        public static bool ValidateHookCode(int nCode)
        {
            return nCode >= 0;
        }
    }
}
</file>

<file path="src/Hooks/KeyboardHook.cs">
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Windows.Forms;

namespace NotesAndTasks.Hooks
{
    /// <summary>
    /// Provides low-level keyboard hook functionality for capturing keyboard input events.
    /// </summary>
    public class KeyboardHook : IDisposable
    {
        private IntPtr hookID = IntPtr.Zero;
        private readonly NativeMethods.LowLevelHookProc hookCallback;
        private bool disposed;

        /// <summary>
        /// Gets the Windows hook identifier.
        /// </summary>
        public IntPtr HookID => hookID;

        /// <summary>
        /// Event raised when a key is pressed.
        /// </summary>
        public event EventHandler<KeyboardHookEventArgs> KeyDown;

        /// <summary>
        /// Event raised when a key is released.
        /// </summary>
        public event EventHandler<KeyboardHookEventArgs> KeyUp;

        /// <summary>
        /// Initializes a new instance of the KeyboardHook class.
        /// </summary>
        public KeyboardHook()
        {
            hookCallback = HookCallback;
        }

        /// <summary>
        /// Sets up the keyboard hook with the specified module handle.
        /// </summary>
        /// <param name="moduleHandle">The handle to the module containing the hook procedure.</param>
        public void SetHook(IntPtr moduleHandle)
        {
            if (hookID != IntPtr.Zero)
                throw new InvalidOperationException("Hook is already set");

            hookID = NativeMethods.SetWindowsHookEx(WinMessages.WH_KEYBOARD_LL, hookCallback, moduleHandle, 0);
            if (hookID == IntPtr.Zero)
                throw new InvalidOperationException("Failed to set keyboard hook");
        }

        /// <summary>
        /// Starts monitoring keyboard events.
        /// </summary>
        public void Start()
        {
            if (hookID == IntPtr.Zero)
            {
                using var curProcess = System.Diagnostics.Process.GetCurrentProcess();
                using var curModule = curProcess.MainModule;
                if (curModule == null)
                    throw new InvalidOperationException("Failed to get current module");

                SetHook(NativeMethods.GetModuleHandle(curModule.ModuleName));
            }
        }

        /// <summary>
        /// Stops monitoring keyboard events.
        /// </summary>
        public void Stop()
        {
            if (hookID != IntPtr.Zero)
            {
                NativeMethods.UnhookWindowsHookEx(hookID);
                hookID = IntPtr.Zero;
            }
        }

        private IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0)
            {
                var hookStruct = Marshal.PtrToStructure<NativeMethods.KBDLLHOOKSTRUCT>(lParam);

                if (wParam == (IntPtr)WinMessages.WM_KEYDOWN || wParam == (IntPtr)WinMessages.WM_SYSKEYDOWN)
                {
                    KeyDown?.Invoke(this, new KeyboardHookEventArgs((Keys)hookStruct.vkCode));
                }
                else if (wParam == (IntPtr)WinMessages.WM_KEYUP || wParam == (IntPtr)WinMessages.WM_SYSKEYUP)
                {
                    KeyUp?.Invoke(this, new KeyboardHookEventArgs((Keys)hookStruct.vkCode));
                }
            }

            return NativeMethods.CallNextHookEx(hookID, nCode, wParam, lParam);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the KeyboardHook.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the KeyboardHook and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    Stop();
                }
                disposed = true;
            }
        }

        /// <summary>
        /// Finalizes an instance of the KeyboardHook class.
        /// </summary>
        ~KeyboardHook()
        {
            Dispose(false);
        }
    }

    /// <summary>
    /// Event arguments for keyboard hook events.
    /// </summary>
    public class KeyboardHookEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the virtual key code of the key.
        /// </summary>
        public Keys VirtualKeyCode { get; }

        /// <summary>
        /// Initializes a new instance of the KeyboardHookEventArgs class.
        /// </summary>
        /// <param name="virtualKeyCode">The virtual key code.</param>
        public KeyboardHookEventArgs(Keys virtualKeyCode)
        {
            VirtualKeyCode = virtualKeyCode;
        }
    }
}
</file>

<file path="src/Hooks/MouseHook.cs">
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Windows.Forms;

namespace NotesAndTasks.Hooks
{
    /// <summary>
    /// Manages low-level mouse hook functionality.
    /// </summary>
    public class MouseHook : IDisposable
    {
        private IntPtr hookID = IntPtr.Zero;
        private readonly NativeMethods.LowLevelHookProc hookProc;
        private bool disposed;

        /// <summary>
        /// Gets the Windows hook identifier.
        /// </summary>
        public IntPtr HookID => hookID;

        /// <summary>
        /// Event raised when a mouse button is pressed.
        /// </summary>
        public event EventHandler<MouseHookEventArgs> MouseDown;

        /// <summary>
        /// Event raised when a mouse button is released.
        /// </summary>
        public event EventHandler<MouseHookEventArgs> MouseUp;

        /// <summary>
        /// Initializes a new instance of the MouseHook class.
        /// </summary>
        public MouseHook()
        {
            hookProc = HookCallback;
        }

        /// <summary>
        /// Sets up the mouse hook with the specified module handle.
        /// </summary>
        /// <param name="moduleHandle">The handle to the module containing the hook procedure.</param>
        public void SetHook(IntPtr moduleHandle)
        {
            if (hookID != IntPtr.Zero)
                throw new InvalidOperationException("Hook is already set");

            hookID = NativeMethods.SetWindowsHookEx(WinMessages.WH_MOUSE_LL, hookProc, moduleHandle, 0);
            if (hookID == IntPtr.Zero)
                throw new InvalidOperationException("Failed to set mouse hook");
        }

        /// <summary>
        /// Starts monitoring mouse events.
        /// </summary>
        public void Start()
        {
            if (hookID == IntPtr.Zero)
            {
                using var curProcess = Process.GetCurrentProcess();
                using var curModule = curProcess.MainModule;
                if (curModule == null)
                    throw new InvalidOperationException("Failed to get current module");

                SetHook(NativeMethods.GetModuleHandle(curModule.ModuleName));
            }
        }

        /// <summary>
        /// Stops monitoring mouse events.
        /// </summary>
        public void Stop()
        {
            if (hookID != IntPtr.Zero)
            {
                NativeMethods.UnhookWindowsHookEx(hookID);
                hookID = IntPtr.Zero;
            }
        }

        private IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0)
            {
                var mouseData = Marshal.PtrToStructure<NativeMethods.MSLLHOOKSTRUCT>(lParam);
                var button = MouseButtons.None;
                bool isDown = false;

                switch ((int)wParam)
                {
                    case WinMessages.WM_LBUTTONDOWN:
                        button = MouseButtons.Left;
                        isDown = true;
                        break;
                    case WinMessages.WM_LBUTTONUP:
                        button = MouseButtons.Left;
                        break;
                    case WinMessages.WM_RBUTTONDOWN:
                        button = MouseButtons.Right;
                        isDown = true;
                        break;
                    case WinMessages.WM_RBUTTONUP:
                        button = MouseButtons.Right;
                        break;
                    case WinMessages.WM_MBUTTONDOWN:
                        button = MouseButtons.Middle;
                        isDown = true;
                        break;
                    case WinMessages.WM_MBUTTONUP:
                        button = MouseButtons.Middle;
                        break;
                    case WinMessages.WM_XBUTTONDOWN:
                        button = (mouseData.mouseData >> 16) == WinMessages.XBUTTON1 ? 
                            MouseButtons.XButton1 : MouseButtons.XButton2;
                        isDown = true;
                        break;
                    case WinMessages.WM_XBUTTONUP:
                        button = (mouseData.mouseData >> 16) == WinMessages.XBUTTON1 ? 
                            MouseButtons.XButton1 : MouseButtons.XButton2;
                        break;
                }

                if (button != MouseButtons.None)
                {
                    var args = new MouseHookEventArgs(button, mouseData.pt.X, mouseData.pt.Y);
                    if (isDown)
                        MouseDown?.Invoke(this, args);
                    else
                        MouseUp?.Invoke(this, args);
                }
            }
            return NativeMethods.CallNextHookEx(hookID, nCode, wParam, lParam);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the MouseHook.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the MouseHook and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    Stop();
                }
                disposed = true;
            }
        }

        /// <summary>
        /// Finalizes an instance of the MouseHook class.
        /// </summary>
        ~MouseHook()
        {
            Dispose(false);
        }
    }

    /// <summary>
    /// Event arguments for mouse hook events.
    /// </summary>
    public class MouseHookEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the mouse button that triggered the event.
        /// </summary>
        public MouseButtons Button { get; }

        /// <summary>
        /// Gets the X coordinate of the mouse cursor.
        /// </summary>
        public int X { get; }

        /// <summary>
        /// Gets the Y coordinate of the mouse cursor.
        /// </summary>
        public int Y { get; }

        /// <summary>
        /// Initializes a new instance of the MouseHookEventArgs class.
        /// </summary>
        /// <param name="button">The mouse button.</param>
        /// <param name="x">The X coordinate.</param>
        /// <param name="y">The Y coordinate.</param>
        public MouseHookEventArgs(MouseButtons button, int x, int y)
        {
            Button = button;
            X = x;
            Y = y;
        }
    }
}
</file>

<file path="src/Hooks/NativeMethods.cs">
using System;
using System.Runtime.InteropServices;

namespace NotesAndTasks
{
    /// <summary>
    /// Contains P/Invoke declarations for Windows API functions and related structures.
    /// This class follows security best practices by isolating native method declarations.
    /// </summary>
    /// <remarks>
    /// This class encapsulates all external Windows API calls used by the application.
    /// It implements the recommended pattern for P/Invoke declarations by:
    /// - Using internal access to limit exposure
    /// - Properly declaring structures with correct marshaling attributes
    /// - Including security-related attributes where needed
    /// - Providing comprehensive documentation for each member
    /// </remarks>
    internal static class NativeMethods
    {
        #region Delegates
        /// <summary>
        /// Delegate for low-level keyboard and mouse hook callbacks.
        /// </summary>
        /// <param name="nCode">Hook code. If nCode is less than zero, the hook procedure must pass the message to CallNextHookEx.</param>
        /// <param name="wParam">Message identifier.</param>
        /// <param name="lParam">Pointer to a KBDLLHOOKSTRUCT or MSLLHOOKSTRUCT structure.</param>
        /// <returns>If nCode is less than zero, the hook procedure must return the value returned by CallNextHookEx.</returns>
        internal delegate IntPtr LowLevelHookProc(int nCode, IntPtr wParam, IntPtr lParam);
        #endregion

        #region Structures
        /// <summary>
        /// Represents a point in a two-dimensional coordinate system.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct POINT
        {
            /// <summary>The x-coordinate of the point.</summary>
            public int X;
            /// <summary>The y-coordinate of the point.</summary>
            public int Y;
        }

        /// <summary>
        /// Contains information about a low-level mouse input event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct MSLLHOOKSTRUCT
        {
            /// <summary>The x- and y-coordinates of the cursor, in screen coordinates.</summary>
            public POINT pt;
            /// <summary>
            /// Additional information about the mouse event.
            /// If the message is WM_XBUTTONDOWN, WM_XBUTTONUP, WM_XBUTTONDBLCLK, WM_NCXBUTTONDOWN, WM_NCXBUTTONUP,
            /// or WM_NCXBUTTONDBLCLK, the high-order word specifies which X button was pressed or released.
            /// </summary>
            public uint mouseData;
            /// <summary>The event-injected flag.</summary>
            public uint flags;
            /// <summary>The time stamp for this message.</summary>
            public uint time;
            /// <summary>Additional information associated with the message.</summary>
            public IntPtr dwExtraInfo;
        }

        /// <summary>
        /// Contains information about a low-level keyboard input event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct KBDLLHOOKSTRUCT
        {
            /// <summary>The virtual-key code of the key.</summary>
            public uint vkCode;
            /// <summary>The hardware scan code of the key.</summary>
            public uint scanCode;
            /// <summary>The extended-key flag, event-injected flag, context code, and transition-state flag.</summary>
            public uint flags;
            /// <summary>The time stamp for this message.</summary>
            public uint time;
            /// <summary>Additional information associated with the message.</summary>
            public IntPtr dwExtraInfo;
        }

        /// <summary>
        /// Contains information about simulated mouse or keyboard input events.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct INPUT
        {
            /// <summary>The type of the input event (1 for mouse input, 2 for keyboard input).</summary>
            public uint type;
            /// <summary>The mouse input data when the type is INPUT_MOUSE.</summary>
            public MOUSEINPUT mi;
        }

        /// <summary>
        /// Contains information about a simulated mouse event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct MOUSEINPUT
        {
            /// <summary>The absolute position of the mouse, or the amount of motion since the last mouse event.</summary>
            public int dx;
            /// <summary>The absolute position of the mouse, or the amount of motion since the last mouse event.</summary>
            public int dy;
            /// <summary>If the mouse wheel is moved, indicates the amount of wheel movement.</summary>
            public uint mouseData;
            /// <summary>A set of bit flags that specify various aspects of mouse motion and button clicks.</summary>
            public uint dwFlags;
            /// <summary>The time stamp for the event, in milliseconds.</summary>
            public uint time;
            /// <summary>Additional information associated with the event.</summary>
            public IntPtr dwExtraInfo;
        }
        #endregion

        #region User32.dll Functions
        /// <summary>
        /// Sets a Windows hook that monitors low-level keyboard or mouse input events.
        /// </summary>
        /// <param name="idHook">The type of hook to be installed (WH_KEYBOARD_LL or WH_MOUSE_LL).</param>
        /// <param name="lpfn">A pointer to the hook procedure.</param>
        /// <param name="hMod">A handle to the DLL containing the hook procedure.</param>
        /// <param name="dwThreadId">The identifier of the thread with which the hook procedure is to be associated.</param>
        /// <returns>If successful, returns a handle to the hook procedure. If unsuccessful, returns IntPtr.Zero.</returns>
        /// <remarks>
        /// The hook procedure should process the message and return the value returned by CallNextHookEx.
        /// For low-level hooks, the hook procedure must be in the same desktop as the running application.
        /// </remarks>
        [DllImport("user32.dll", SetLastError = true)]
        internal static extern IntPtr SetWindowsHookEx(
            int idHook,
            LowLevelHookProc lpfn,
            IntPtr hMod,
            uint dwThreadId);

        /// <summary>
        /// Removes a previously set Windows hook.
        /// </summary>
        /// <param name="hhk">A handle to the hook to be removed. This parameter is obtained by a previous call to SetWindowsHookEx.</param>
        /// <returns>If successful, returns true. If unsuccessful, returns false.</returns>
        /// <remarks>
        /// The hook procedure must be in the state to be removed, that is, it must not be in the middle of processing a message.
        /// This function must be called on the same thread that installed the hook.
        /// </remarks>
        [DllImport("user32.dll", SetLastError = true)]
        internal static extern bool UnhookWindowsHookEx(IntPtr hhk);

        /// <summary>
        /// Passes the hook information to the next hook procedure in the current hook chain.
        /// </summary>
        /// <param name="hhk">This parameter is ignored.</param>
        /// <param name="nCode">The hook code passed to the current hook procedure.</param>
        /// <param name="wParam">The wParam value passed to the current hook procedure.</param>
        /// <param name="lParam">The lParam value passed to the current hook procedure.</param>
        /// <returns>The value returned by the next hook procedure in the chain.</returns>
        /// <remarks>
        /// This function must be called by the hook procedure if it is not processing the message.
        /// The hook procedure can modify the values pointed to by wParam and lParam before passing them to CallNextHookEx.
        /// </remarks>
        [DllImport("user32.dll")]
        internal static extern IntPtr CallNextHookEx(
            IntPtr hhk,
            int nCode,
            IntPtr wParam,
            IntPtr lParam);

        /// <summary>
        /// Retrieves the current cursor position.
        /// </summary>
        /// <param name="lpPoint">A pointer to a POINT structure that receives the screen coordinates of the cursor.</param>
        /// <returns>Returns true if successful, false otherwise.</returns>
        /// <remarks>
        /// The cursor position is always specified in screen coordinates and is not affected by the mapping mode of the window that contains the cursor.
        /// </remarks>
        [DllImport("user32.dll")]
        internal static extern bool GetCursorPos(out POINT lpPoint);

        /// <summary>
        /// Synthesizes mouse motion and button clicks.
        /// </summary>
        /// <param name="dwFlags">A set of bit flags that specify various aspects of mouse motion and button clicking.</param>
        /// <param name="dx">The mouse's absolute position along the x-axis or its amount of motion since the last mouse event.</param>
        /// <param name="dy">The mouse's absolute position along the y-axis or its amount of motion since the last mouse event.</param>
        /// <param name="dwData">If dwFlags contains MOUSEEVENTF_WHEEL, then dwData specifies the amount of wheel movement.</param>
        /// <param name="dwExtraInfo">Additional information associated with the mouse event.</param>
        /// <remarks>
        /// The mouse_event function has been superseded by SendInput. Use SendInput instead.
        /// </remarks>
        [DllImport("user32.dll")]
        internal static extern void mouse_event(
            uint dwFlags,
            int dx,
            int dy,
            uint dwData,
            int dwExtraInfo);

        /// <summary>
        /// Synthesizes keystrokes, mouse motions, and button clicks.
        /// </summary>
        /// <param name="nInputs">The number of structures in the pInputs array.</param>
        /// <param name="pInputs">An array of INPUT structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</param>
        /// <param name="cbSize">The size, in bytes, of an INPUT structure.</param>
        /// <returns>The function returns the number of events that it successfully inserted into the keyboard or mouse input stream.</returns>
        /// <remarks>
        /// This function is the preferred method for synthesizing input, as it supports more features and is more efficient than mouse_event and keybd_event.
        /// </remarks>
        [DllImport("user32.dll", SetLastError = true)]
        internal static extern uint SendInput(
            uint nInputs,
            ref INPUT pInputs,
            int cbSize);
        #endregion

        #region Kernel32.dll Functions
        /// <summary>
        /// Retrieves a module handle for the specified module.
        /// </summary>
        /// <param name="lpModuleName">The name of the loaded module (either a .dll or .exe file).</param>
        /// <returns>If successful, returns a handle to the specified module. If unsuccessful, returns IntPtr.Zero.</returns>
        /// <remarks>
        /// If lpModuleName is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).
        /// The returned handle is not global or inheritable. It cannot be duplicated or used by another process.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        internal static extern IntPtr GetModuleHandle(string lpModuleName);
        #endregion
    }
}
</file>

<file path="src/Hooks/WinMessages.cs">
using System;

namespace NotesAndTasks
{
    /// <summary>
    /// Contains Windows message constants used for low-level hooks and input handling.
    /// </summary>
    /// <remarks>
    /// This class provides a centralized location for all Windows message constants used in the application.
    /// The constants are organized into logical groups:
    /// - Hook-related constants (WH_*)
    /// - Keyboard message constants (WM_KEY*)
    /// - Mouse button message constants (WM_*BUTTON*)
    /// - Mouse button identifiers (XBUTTON*)
    /// - Mouse event flags (MOUSEEVENTF_*)
    /// - Input type identifiers (INPUT_*)
    /// - Base values for calculations
    /// </remarks>
    public static class WinMessages
    {
        /// <summary>
        /// Windows hook constant for low-level keyboard events.
        /// Used with SetWindowsHookEx to install a hook procedure that monitors low-level keyboard input events.
        /// </summary>
        public const int WH_KEYBOARD_LL = 13;

        /// <summary>
        /// Windows hook constant for low-level mouse events.
        /// Used with SetWindowsHookEx to install a hook procedure that monitors low-level mouse input events.
        /// </summary>
        public const int WH_MOUSE_LL = 14;

        /// <summary>
        /// Posted when a nonsystem key is pressed.
        /// A nonsystem key is a key that is pressed when the ALT key is not pressed.
        /// </summary>
        public const int WM_KEYDOWN = 0x0100;

        /// <summary>
        /// Posted when a nonsystem key is released.
        /// </summary>
        public const int WM_KEYUP = 0x0101;

        /// <summary>
        /// Posted when a system key is pressed (such as ALT).
        /// </summary>
        public const int WM_SYSKEYDOWN = 0x0104;

        /// <summary>
        /// Posted when a system key is released.
        /// </summary>
        public const int WM_SYSKEYUP = 0x0105;

        /// <summary>
        /// Posted when the left mouse button is pressed.
        /// </summary>
        public const int WM_LBUTTONDOWN = 0x0201;

        /// <summary>
        /// Posted when the left mouse button is released.
        /// </summary>
        public const int WM_LBUTTONUP = 0x0202;

        /// <summary>
        /// Posted when the right mouse button is pressed.
        /// </summary>
        public const int WM_RBUTTONDOWN = 0x0204;

        /// <summary>
        /// Posted when the right mouse button is released.
        /// </summary>
        public const int WM_RBUTTONUP = 0x0205;

        /// <summary>
        /// Posted when the middle mouse button is pressed.
        /// </summary>
        public const int WM_MBUTTONDOWN = 0x0207;

        /// <summary>
        /// Posted when the middle mouse button is released.
        /// </summary>
        public const int WM_MBUTTONUP = 0x0208;

        /// <summary>
        /// Posted when an X button is pressed.
        /// The specific button (XBUTTON1 or XBUTTON2) is indicated in the high-order word of the mouseData field.
        /// </summary>
        public const int WM_XBUTTONDOWN = 0x020B;

        /// <summary>
        /// Posted when an X button is released.
        /// The specific button (XBUTTON1 or XBUTTON2) is indicated in the high-order word of the mouseData field.
        /// </summary>
        public const int WM_XBUTTONUP = 0x020C;

        /// <summary>
        /// First X button identifier (typically the fourth mouse button).
        /// Used to identify which X button was pressed in WM_XBUTTONDOWN events.
        /// </summary>
        public const int XBUTTON1 = 0x0001;

        /// <summary>
        /// Second X button identifier (typically the fifth mouse button).
        /// Used to identify which X button was pressed in WM_XBUTTONDOWN events.
        /// </summary>
        public const int XBUTTON2 = 0x0002;

        /// <summary>
        /// Mouse event flag indicating relative mouse movement.
        /// When used with SendInput, specifies that dx and dy contain relative movement data.
        /// </summary>
        public const uint MOUSEEVENTF_MOVE = 0x0001;

        /// <summary>
        /// Input type constant indicating mouse input.
        /// Used with the INPUT structure to specify that the input event is mouse-related.
        /// </summary>
        public const uint INPUT_MOUSE = 0;

        /// <summary>
        /// Base strength value for recoil calculations.
        /// Used as a multiplier in basic recoil reduction calculations.
        /// </summary>
        public const double BASE_RECOIL_STRENGTH = 0.75;

        /// <summary>
        /// Secondary base strength value for enhanced recoil calculations.
        /// Used as a multiplier in advanced recoil reduction calculations.
        /// </summary>
        public const double BASE_RECOIL_STRENGTH_2 = 2.0;

        /// <summary>
        /// Speed multiplier for the lowest level of movement adjustment.
        /// Applied to movement calculations when minimal adjustment is needed.
        /// </summary>
        public const double LOW_LEVEL_1_SPEED = 0.25;

        /// <summary>
        /// Speed multiplier for the medium-low level of movement adjustment.
        /// Applied to movement calculations when moderate adjustment is needed.
        /// </summary>
        public const double LOW_LEVEL_2_SPEED = 0.5;

        /// <summary>
        /// Speed multiplier for the medium level of movement adjustment.
        /// Applied to movement calculations when significant adjustment is needed.
        /// </summary>
        public const double LOW_LEVEL_3_SPEED = 0.75;
    }
}
</file>

<file path="src/Models/AppSettings.cs">
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace NotesAndTasks.Models
{
    /// <summary>
    /// Root configuration class that contains all application settings
    /// </summary>
    public class AppSettings : INotifyPropertyChanged
    {
        private readonly MacroSettings _macroSettings;
        private readonly UISettings _uiSettings;
        private readonly HotkeySettings _hotkeySettings;

        /// <summary>
        /// Initializes a new instance of the AppSettings class with default settings
        /// </summary>
        public AppSettings()
        {
            _macroSettings = new MacroSettings();
            _uiSettings = new UISettings();
            _hotkeySettings = new HotkeySettings();
        }

        /// <summary>
        /// Gets the macro-related settings including jitter and recoil reduction
        /// </summary>
        public MacroSettings MacroSettings => _macroSettings;

        /// <summary>
        /// Gets the UI-related settings
        /// </summary>
        public UISettings UISettings => _uiSettings;

        /// <summary>
        /// Gets the hotkey configuration settings
        /// </summary>
        public HotkeySettings HotkeySettings => _hotkeySettings;

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
</file>

<file path="src/Models/HotkeySettings.cs">
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Forms;

namespace NotesAndTasks.Models
{
    /// <summary>
    /// Settings related to keyboard shortcuts and hotkeys
    /// </summary>
    public class HotkeySettings : INotifyPropertyChanged
    {
        private InputBinding _macroKey;
        private InputBinding _switchKey;

        /// <summary>
        /// Initializes a new instance of the HotkeySettings class with default values
        /// </summary>
        public HotkeySettings()
        {
            _macroKey = new InputBinding(Keys.Capital, InputType.Keyboard);
            _switchKey = new InputBinding(Keys.Q, InputType.Keyboard);
        }

        /// <summary>
        /// Gets or sets the key used to toggle the macro
        /// </summary>
        public InputBinding MacroKey
        {
            get => _macroKey;
            set
            {
                if (_macroKey != value)
                {
                    _macroKey = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets the key used to switch between modes
        /// </summary>
        public InputBinding SwitchKey
        {
            get => _switchKey;
            set
            {
                if (_switchKey != value)
                {
                    _switchKey = value;
                    OnPropertyChanged();
                }
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
</file>

<file path="src/Models/MacroSettings.cs">
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.CompilerServices;

namespace NotesAndTasks.Models
{
    /// <summary>
    /// Configuration settings for macro functionality including jitter and recoil reduction
    /// </summary>
    public class MacroSettings : INotifyPropertyChanged
    {
        private int _jitterStrength = 3;
        private int _recoilReductionStrength = 1;
        private bool _jitterEnabled;
        private bool _recoilReductionEnabled;
        private bool _alwaysJitterMode;
        private bool _alwaysRecoilReductionMode;

        /// <summary>
        /// Gets or sets the jitter strength value (1-20)
        /// </summary>
        [Range(1, 20, ErrorMessage = "Jitter strength must be between 1 and 20")]
        public int JitterStrength
        {
            get => _jitterStrength;
            set
            {
                if (_jitterStrength != value)
                {
                    _jitterStrength = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets the recoil reduction strength value (1-20)
        /// </summary>
        [Range(1, 20, ErrorMessage = "Recoil reduction strength must be between 1 and 20")]
        public int RecoilReductionStrength
        {
            get => _recoilReductionStrength;
            set
            {
                if (_recoilReductionStrength != value)
                {
                    _recoilReductionStrength = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets whether jitter is enabled
        /// </summary>
        public bool JitterEnabled
        {
            get => _jitterEnabled;
            set
            {
                if (_jitterEnabled != value)
                {
                    _jitterEnabled = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets whether recoil reduction is enabled
        /// </summary>
        public bool RecoilReductionEnabled
        {
            get => _recoilReductionEnabled;
            set
            {
                if (_recoilReductionEnabled != value)
                {
                    _recoilReductionEnabled = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets whether jitter mode is always enabled
        /// </summary>
        public bool AlwaysJitterMode
        {
            get => _alwaysJitterMode;
            set
            {
                if (_alwaysJitterMode != value)
                {
                    _alwaysJitterMode = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets whether recoil reduction mode is always enabled
        /// </summary>
        public bool AlwaysRecoilReductionMode
        {
            get => _alwaysRecoilReductionMode;
            set
            {
                if (_alwaysRecoilReductionMode != value)
                {
                    _alwaysRecoilReductionMode = value;
                    OnPropertyChanged();
                }
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
</file>

<file path="src/Models/UISettings.cs">
using System.ComponentModel;
using System.Drawing;
using System.Runtime.CompilerServices;

namespace NotesAndTasks.Models
{
    /// <summary>
    /// Configuration settings for UI functionality and appearance
    /// </summary>
    public class UISettings : INotifyPropertyChanged
    {
        private bool _minimizeToTray = false;
        private bool _showDebugPanel;
        private Point _windowPosition = new Point(100, 100);
        private Size _windowSize = new Size(800, 600);
        private bool _showStatusInTitle = true;
        private bool _showTrayNotifications = true;

        /// <summary>
        /// Gets or sets whether the application should minimize to tray when closing
        /// </summary>
        public bool MinimizeToTray
        {
            get => _minimizeToTray;
            set
            {
                if (_minimizeToTray != value)
                {
                    _minimizeToTray = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets whether to show the debug information panel
        /// </summary>
        public bool ShowDebugPanel
        {
            get => _showDebugPanel;
            set
            {
                if (_showDebugPanel != value)
                {
                    _showDebugPanel = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets whether to show status information in the window title
        /// </summary>
        public bool ShowStatusInTitle
        {
            get => _showStatusInTitle;
            set
            {
                if (_showStatusInTitle != value)
                {
                    _showStatusInTitle = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets whether to show system tray notifications
        /// </summary>
        public bool ShowTrayNotifications
        {
            get => _showTrayNotifications;
            set
            {
                if (_showTrayNotifications != value)
                {
                    _showTrayNotifications = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets the main window position
        /// </summary>
        public Point WindowPosition
        {
            get => _windowPosition;
            set
            {
                if (_windowPosition != value)
                {
                    _windowPosition = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Gets or sets the main window size
        /// </summary>
        public Size WindowSize
        {
            get => _windowSize;
            set
            {
                if (_windowSize != value)
                {
                    _windowSize = value;
                    OnPropertyChanged();
                }
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
</file>

<file path="src/Utilities/MacroEffectBase.cs">
using System;
using System.Windows.Forms;
using System.Threading;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Base class for macro effect managers like jitter and recoil reduction.
    /// Provides common functionality for handling strength, activation state, and lifecycle.
    /// </summary>
    public abstract class MacroEffectBase : IDisposable
    {
        protected readonly InputSimulator InputSimulator;
        protected bool Disposed = false;
        protected int EffectStrength;
        protected bool IsEffectActive = false;
        protected System.Threading.Timer Timer;

        /// <summary>
        /// Event raised when the effect state changes.
        /// </summary>
        public event EventHandler<bool> StateChanged;

        /// <summary>
        /// Gets whether the effect is currently active.
        /// </summary>
        public bool IsActive => IsEffectActive;

        /// <summary>
        /// Gets or sets the current effect strength (1-20).
        /// </summary>
        public int Strength
        {
            get => EffectStrength;
            protected set
            {
                if (value < 1 || value > 20)
                    throw new ArgumentOutOfRangeException(nameof(value), "Strength must be between 1 and 20.");
                EffectStrength = value;
            }
        }

        /// <summary>
        /// Initializes a new instance of the MacroEffectBase class.
        /// </summary>
        /// <param name="inputSimulator">The input simulator to use for mouse movement.</param>
        /// <param name="defaultStrength">The default strength value.</param>
        protected MacroEffectBase(InputSimulator inputSimulator, int defaultStrength)
        {
            InputSimulator = inputSimulator ?? throw new ArgumentNullException(nameof(inputSimulator));
            EffectStrength = defaultStrength;
            Timer = new System.Threading.Timer(OnTimerTick, null, System.Threading.Timeout.Infinite, 10);
        }

        /// <summary>
        /// Sets the effect strength value (1-20).
        /// </summary>
        /// <param name="value">The strength value to set.</param>
        public void SetStrength(int value)
        {
            if (Disposed)
                throw new ObjectDisposedException(GetType().Name);
            Strength = value;
        }

        /// <summary>
        /// Starts the effect.
        /// </summary>
        public void Start()
        {
            if (Disposed)
                throw new ObjectDisposedException(GetType().Name);

            if (!IsEffectActive)
            {
                IsEffectActive = true;
                Timer.Change(0, 10);
                StateChanged?.Invoke(this, true);
            }
        }

        /// <summary>
        /// Stops the effect.
        /// </summary>
        public void Stop()
        {
            if (Disposed)
                throw new ObjectDisposedException(GetType().Name);

            if (IsEffectActive)
            {
                IsEffectActive = false;
                Timer.Change(System.Threading.Timeout.Infinite, 10);
                StateChanged?.Invoke(this, false);
            }
        }

        /// <summary>
        /// Timer callback that applies the effect.
        /// Must be implemented by derived classes.
        /// </summary>
        protected abstract void OnTimerTick(object state);

        /// <summary>
        /// Disposes of resources used by the manager.
        /// </summary>
        public void Dispose()
        {
            if (!Disposed)
            {
                // First stop any active effects
                if (IsEffectActive)
                {
                    Stop();
                }

                // Ensure timer is stopped by setting infinite delay
                Timer?.Change(Timeout.Infinite, Timeout.Infinite);

                // Small delay to ensure any pending timer callbacks complete
                Thread.Sleep(50);

                // Now safe to dispose the timer
                Timer?.Dispose();
                Timer = null;

                Disposed = true;
                GC.SuppressFinalize(this);
            }
        }
    }
}
</file>

<file path="src/Configuration/ConfigurationEvents.cs">
using System;
using NotesAndTasks.Models;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Event arguments for when settings have changed
    /// </summary>
    public class SettingsChangedEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the section of settings that changed
        /// </summary>
        public string Section { get; }

        /// <summary>
        /// Gets the previous settings
        /// </summary>
        public AppSettings PreviousSettings { get; }

        /// <summary>
        /// Gets the new settings
        /// </summary>
        public AppSettings NewSettings { get; }

        /// <summary>
        /// Initializes a new instance of the SettingsChangedEventArgs class
        /// </summary>
        /// <param name="section">The section that changed</param>
        /// <param name="previousSettings">The previous settings</param>
        /// <param name="newSettings">The new settings</param>
        public SettingsChangedEventArgs(string section, AppSettings previousSettings, AppSettings newSettings)
        {
            Section = section;
            PreviousSettings = previousSettings;
            NewSettings = newSettings;
        }
    }

    /// <summary>
    /// Event arguments for settings validation
    /// </summary>
    public class SettingsValidationEventArgs : EventArgs
    {
        /// <summary>
        /// Gets or sets whether the settings are valid
        /// </summary>
        public bool IsValid { get; set; } = true;

        /// <summary>
        /// Gets or sets the validation error message
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// Gets the settings being validated
        /// </summary>
        public AppSettings Settings { get; }

        /// <summary>
        /// Initializes a new instance of the SettingsValidationEventArgs class
        /// </summary>
        /// <param name="settings">The settings to validate</param>
        public SettingsValidationEventArgs(AppSettings settings)
        {
            Settings = settings;
        }
    }

    /// <summary>
    /// Event arguments for settings backup completion
    /// </summary>
    public class SettingsBackupEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the path to the backup file
        /// </summary>
        public string BackupPath { get; }

        /// <summary>
        /// Gets whether the backup was successful
        /// </summary>
        public bool Success { get; }

        /// <summary>
        /// Gets the error message if backup failed
        /// </summary>
        public string ErrorMessage { get; }

        /// <summary>
        /// Initializes a new instance of the SettingsBackupEventArgs class
        /// </summary>
        /// <param name="backupPath">The path to the backup file</param>
        /// <param name="success">Whether the backup was successful</param>
        /// <param name="errorMessage">The error message if backup failed</param>
        public SettingsBackupEventArgs(string backupPath, bool success, string errorMessage = null)
        {
            BackupPath = backupPath;
            Success = success;
            ErrorMessage = errorMessage;
        }
    }

    /// <summary>
    /// Delegate for settings change events
    /// </summary>
    public delegate void SettingsChangedEventHandler(object sender, SettingsChangedEventArgs e);

    /// <summary>
    /// Delegate for settings validation events
    /// </summary>
    public delegate void SettingsValidationEventHandler(object sender, SettingsValidationEventArgs e);

    /// <summary>
    /// Delegate for settings backup completion events
    /// </summary>
    public delegate void SettingsBackupEventHandler(object sender, SettingsBackupEventArgs e);
}
</file>

<file path="src/Utilities/JitterManager.cs">
using System;
using System.Windows.Forms;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Manages jitter pattern generation and application for mouse movement.
    /// This class handles the timing and pattern of jitter movements.
    /// </summary>
    public class JitterManager : MacroEffectBase
    {
        private int currentStep = 0;

        private readonly (int dx, int dy)[] jitterPattern = new[]
        {
            (7, 7), (-7, -7), (0, 7), (7, 7), (-7, -7),
            (0, 6), (7, 7), (-7, -7), (0, 7), (7, 7),
            (-7, -7), (0, 6), (7, 7), (-7, -7), (0, 6),
            (7, 7), (-7, -7), (0, 7), (7, 7), (-7, -7),
            (0, 6), (7, 7), (-7, -7), (0, 6)
        };

        /// <summary>
        /// Initializes a new instance of the JitterManager class.
        /// </summary>
        /// <param name="inputSimulator">The input simulator to use for mouse movement.</param>
        public JitterManager(InputSimulator inputSimulator) : base(inputSimulator, 3)
        {
        }

        /// <summary>
        /// Timer callback that applies the jitter pattern.
        /// </summary>
        protected override void OnTimerTick(object state)
        {
            if (!IsActive) return;

            try
            {
                var pattern = jitterPattern[currentStep];
                InputSimulator.SimulateJitterMovement(pattern, Strength);
                currentStep = (currentStep + 1) % jitterPattern.Length;
            }
            catch (Exception)
            {
                Stop();
            }
        }
    }
}
</file>

<file path="src/Program.cs">
using System;
using System.Threading;
using System.Windows.Forms;
using System.Diagnostics;
using System.Security.Principal;
using NotesAndTasks.Configuration;

namespace NotesAndTasks
{
    internal static class Program
    {
        private static Mutex mutex = new Mutex(true, "NotesTasksGlobalMutex");

        [STAThread]
        static void Main()
        {
            try
            {
                // Check for administrative privileges
                WindowsIdentity identity = WindowsIdentity.GetCurrent();
                WindowsPrincipal principal = new WindowsPrincipal(identity);
                bool isAdmin = principal.IsInRole(WindowsBuiltInRole.Administrator);

                if (!isAdmin)
                {
                    // Restart the application with admin rights
                    ProcessStartInfo startInfo = new ProcessStartInfo();
                    startInfo.UseShellExecute = true;
                    startInfo.WorkingDirectory = Environment.CurrentDirectory;
                    startInfo.FileName = Application.ExecutablePath;
                    startInfo.Verb = "runas";

                    try
                    {
                        Process.Start(startInfo);
                        return;
                    }
                    catch (Exception)
                    {
                        MessageBox.Show("This application requires administrative privileges to run.", "Notes&Tasks",
                            MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }
                }

                // Try to get mutex ownership
                if (!mutex.WaitOne(TimeSpan.Zero, true))
                {
                    MessageBox.Show("Another instance of Notes&Tasks is already running.", "Notes&Tasks", 
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // Optimize process settings for background operation alongside games
                using (Process currentProcess = Process.GetCurrentProcess())
                {
                    // Set process priority to BelowNormal to avoid competing with games
                    currentProcess.PriorityClass = ProcessPriorityClass.BelowNormal;

                    // Set CPU affinity to use last core
                    // This keeps the macro off the primary cores that games typically use
                    if (Environment.ProcessorCount > 1)
                    {
                        int lastCore = Environment.ProcessorCount - 1;
                        currentProcess.ProcessorAffinity = (IntPtr)(1 << lastCore);
                    }

                    // Enable Windows 11 Efficiency Mode
                    // This helps reduce resource competition with games
                    try
                    {
                        if (Environment.OSVersion.Version.Build >= 22621) // Windows 11 22H2 build
                        {
                            currentProcess.ProcessorAffinity = currentProcess.ProcessorAffinity;
                        }
                    }
                    catch (Exception) { /* Ignore if not supported */ }
                }

                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);

                try
                {
                    // Initialize configuration manager before application starts
                    var _ = ConfigurationManager.Instance;
                    
                    Application.Run(new MacroForm());
                }
                finally
                {
                    // Release mutex when application exits
                    mutex.ReleaseMutex();
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"An error occurred: {ex.Message}", "Notes&Tasks Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                mutex.Dispose();
            }
        }
    }
}
</file>

<file path="src/Utilities/HotkeyManager.cs">
using System;
using System.Windows.Forms;
using NotesAndTasks.Configuration;
using NotesAndTasks.Models;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Manages hotkeys and key bindings for the macro application.
    /// </summary>
    public class HotkeyManager
    {
        #region Events
        public event EventHandler<Keys> MacroKeyChanged;
        public event EventHandler<Keys> SwitchKeyChanged;
        public event EventHandler<bool> KeySettingStateChanged;
        public event EventHandler<string> DebugInfoUpdated;
        #endregion

        #region Fields
        private Keys macroKey = Keys.Capital;  // Default to Caps Lock
        private Keys switchKey = Keys.Q;       // Default to Q
        private ToggleType toggleType = ToggleType.Keyboard;
        private bool isSettingMacroKey = false;
        private bool isSettingSwitchKey = false;
        private readonly MacroManager macroManager;
        #endregion

        #region Properties
        /// <summary>
        /// Gets the current macro toggle key.
        /// </summary>
        public Keys MacroKey => macroKey;

        /// <summary>
        /// Gets the current mode switch key.
        /// </summary>
        public Keys SwitchKey => switchKey;

        /// <summary>
        /// Gets the current toggle type.
        /// </summary>
        public ToggleType ToggleType => toggleType;

        /// <summary>
        /// Gets whether the manager is currently waiting for a macro key input.
        /// </summary>
        public bool IsSettingMacroKey => isSettingMacroKey;

        /// <summary>
        /// Gets whether the manager is currently waiting for a switch key input.
        /// </summary>
        public bool IsSettingSwitchKey => isSettingSwitchKey;
        #endregion

        #region Constructor
        public HotkeyManager(MacroManager macroManager)
        {
            this.macroManager = macroManager ?? throw new ArgumentNullException(nameof(macroManager));
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Sets the macro toggle key.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="type">The type of toggle.</param>
        public void SetMacroKey(Keys key, ToggleType type)
        {
            macroKey = key;
            toggleType = type;
            MacroKeyChanged?.Invoke(this, key);
            SaveSettings();
        }

        /// <summary>
        /// Sets the mode switch key.
        /// </summary>
        /// <param name="key">The key to set.</param>
        public void SetSwitchKey(Keys key)
        {
            switchKey = key;
            SwitchKeyChanged?.Invoke(this, key);
            SaveSettings();
        }

        /// <summary>
        /// Loads hotkey settings from the settings manager.
        /// </summary>
        public void LoadSettings()
        {
            var settings = ConfigurationManager.Instance.CurrentSettings;
            if (settings != null)
            {
                macroKey = settings.HotkeySettings.MacroKey.Key;
                switchKey = settings.HotkeySettings.SwitchKey.Key;
                toggleType = ConvertInputTypeToToggleType(settings.HotkeySettings.MacroKey.Type);
            }
        }

        /// <summary>
        /// Saves current hotkey settings to the settings manager.
        /// </summary>
        private void SaveSettings()
        {
            var settings = ConfigurationManager.Instance.CurrentSettings;
            if (settings != null)
            {
                settings.HotkeySettings.MacroKey.Key = macroKey;
                settings.HotkeySettings.SwitchKey.Key = switchKey;
                settings.HotkeySettings.MacroKey.Type = ConvertToggleTypeToInputType(toggleType);
                ConfigurationManager.Instance.SaveSettings();
            }
        }

        /// <summary>
        /// Converts InputType to ToggleType
        /// </summary>
        private ToggleType ConvertInputTypeToToggleType(Models.InputType inputType)
        {
            return inputType == Models.InputType.Keyboard ? ToggleType.Keyboard : ToggleType.MouseMiddle;
        }

        /// <summary>
        /// Converts ToggleType to InputType
        /// </summary>
        private Models.InputType ConvertToggleTypeToInputType(ToggleType toggleType)
        {
            return toggleType == ToggleType.Keyboard ? Models.InputType.Keyboard : Models.InputType.Mouse;
        }

        /// <summary>
        /// Resets hotkeys to their default values.
        /// </summary>
        public void ResetToDefaults()
        {
            SetMacroKey(Keys.Capital, ToggleType.Keyboard);
            SetSwitchKey(Keys.Q);
        }

        /// <summary>
        /// Starts listening for a new macro key.
        /// </summary>
        public void StartSettingMacroKey()
        {
            isSettingMacroKey = true;
            isSettingSwitchKey = false;
            KeySettingStateChanged?.Invoke(this, true);
            DebugInfoUpdated?.Invoke(this, "Waiting for new macro key...");
        }

        /// <summary>
        /// Starts listening for a new switch key.
        /// </summary>
        public void StartSettingSwitchKey()
        {
            isSettingSwitchKey = true;
            isSettingMacroKey = false;
            KeySettingStateChanged?.Invoke(this, true);
            DebugInfoUpdated?.Invoke(this, "Waiting for new switch key...");
        }

        /// <summary>
        /// Handles keyboard input events.
        /// </summary>
        public void HandleKeyDown(Keys virtualKeyCode)
        {
            if (isSettingMacroKey)
            {
                isSettingMacroKey = false;
                KeySettingStateChanged?.Invoke(this, false);
                SetMacroKey(virtualKeyCode, ToggleType.Keyboard);
                DebugInfoUpdated?.Invoke(this, $"Set macro key to {virtualKeyCode}");
            }
            else if (isSettingSwitchKey)
            {
                isSettingSwitchKey = false;
                KeySettingStateChanged?.Invoke(this, false);
                SetSwitchKey(virtualKeyCode);
                DebugInfoUpdated?.Invoke(this, $"Set switch key to {virtualKeyCode}");
            }
            else if (virtualKeyCode == macroKey && toggleType == ToggleType.Keyboard)
            {
                macroManager.ToggleMacro();
            }
            else if (virtualKeyCode == switchKey)
            {
                macroManager.SwitchMode();
            }
        }

        /// <summary>
        /// Handles mouse button input events.
        /// </summary>
        public void HandleMouseButton(MouseButtons button)
        {
            Keys key = MouseButtonToKeys(button);
            ToggleType type = MouseButtonToToggleType(button);

            if (isSettingMacroKey)
            {
                isSettingMacroKey = false;
                KeySettingStateChanged?.Invoke(this, false);
                SetMacroKey(key, type);
                DebugInfoUpdated?.Invoke(this, $"Set macro key to {button}");
            }
            else if (isSettingSwitchKey)
            {
                isSettingSwitchKey = false;
                KeySettingStateChanged?.Invoke(this, false);
                SetSwitchKey(key);
                DebugInfoUpdated?.Invoke(this, $"Set switch key to {button}");
            }
            else if (key == macroKey)
            {
                macroManager.ToggleMacro();
            }
            else if (key == switchKey)
            {
                macroManager.SwitchMode();
            }
        }

        /// <summary>
        /// Cancels any ongoing key setting operation.
        /// </summary>
        public void CancelKeySetting()
        {
            if (isSettingMacroKey || isSettingSwitchKey)
            {
                isSettingMacroKey = false;
                isSettingSwitchKey = false;
                KeySettingStateChanged?.Invoke(this, false);
                DebugInfoUpdated?.Invoke(this, "Key setting cancelled");
            }
        }

        #region Private Methods
        private Keys MouseButtonToKeys(MouseButtons button)
        {
            return button switch
            {
                MouseButtons.Middle => Keys.MButton,
                MouseButtons.XButton1 => Keys.XButton1,
                MouseButtons.XButton2 => Keys.XButton2,
                _ => Keys.None
            };
        }

        private ToggleType MouseButtonToToggleType(MouseButtons button)
        {
            return button switch
            {
                MouseButtons.Middle => ToggleType.MouseMiddle,
                MouseButtons.XButton1 => ToggleType.MouseX1,
                MouseButtons.XButton2 => ToggleType.MouseX2,
                _ => ToggleType.Keyboard
            };
        }
        #endregion
        #endregion
    }
}
</file>

<file path="src/Utilities/MacroManager.cs">
using System;
using System.Windows.Forms;
using NotesAndTasks.Hooks;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Coordinates between hook and feature managers to provide macro functionality.
    /// This class handles the overall macro state and mode switching.
    /// </summary>
    public class MacroManager : IDisposable
    {
        #region Events
        public event EventHandler<bool> MacroStateChanged;
        public event EventHandler<bool> ModeChanged;
        public event EventHandler JitterStarted;
        public event EventHandler JitterStopped;
        public event EventHandler RecoilReductionStarted;
        public event EventHandler RecoilReductionStopped;
        #endregion

        #region Fields
        private readonly InputSimulator inputSimulator;
        private readonly JitterManager jitterManager;
        private readonly RecoilReductionManager recoilManager;
        private readonly object lockObject = new object();
        private bool disposed = false;
        private bool leftButtonDown = false;
        private bool rightButtonDown = false;
        private bool isActive = false;
        private int jitterStrength = 3;
        private int recoilReductionStrength = 1;
        private bool isTransitioningMode = false;
        #endregion

        #region Properties
        public bool IsEnabled { get; private set; }
        public bool IsJitterEnabled { get; private set; }
        public bool IsAlwaysJitterMode { get; private set; }
        public bool IsAlwaysRecoilReductionMode { get; private set; }

        /// <summary>
        /// Gets the current jitter strength value.
        /// </summary>
        public int JitterStrength => jitterStrength;

        /// <summary>
        /// Gets the current recoil reduction strength value.
        /// </summary>
        public int RecoilReductionStrength => recoilReductionStrength;
        #endregion

        #region Constructor
        public MacroManager()
        {
            try
            {
                inputSimulator = new InputSimulator();
                jitterManager = new JitterManager(inputSimulator);
                recoilManager = new RecoilReductionManager(inputSimulator);

                // Subscribe to state change events
                jitterManager.StateChanged += OnEffectStateChanged;
                recoilManager.StateChanged += OnEffectStateChanged;
            }
            catch (Exception)
            {
                // Clean up if initialization fails
                Dispose(true);
                throw;
            }
        }
        #endregion

        #region Public Methods
        public void HandleMouseButton(MouseButtons button, bool isDown)
        {
            ThrowIfDisposed();

            lock (lockObject)
            {
                try
                {
                    bool stateChanged = false;
                    if (button == MouseButtons.Left && leftButtonDown != isDown)
                    {
                        leftButtonDown = isDown;
                        stateChanged = true;
                    }
                    else if (button == MouseButtons.Right && rightButtonDown != isDown)
                    {
                        rightButtonDown = isDown;
                        stateChanged = true;
                    }

                    if (stateChanged)
                    {
                        CheckMacroState();
                    }
                }
                catch (Exception)
                {
                    // Reset button states on error
                    leftButtonDown = false;
                    rightButtonDown = false;
                    StopAllEffects();
                    throw;
                }
            }
        }

        public void ToggleMacro()
        {
            ThrowIfDisposed();

            lock (lockObject)
            {
                try
                {
                    IsEnabled = !IsEnabled;
                    MacroStateChanged?.Invoke(this, IsEnabled);
                    
                    if (!IsEnabled)
                    {
                        // Ensure cleanup when disabling
                        leftButtonDown = false;
                        rightButtonDown = false;
                    }
                    
                    CheckMacroState();
                }
                catch (Exception)
                {
                    // Reset state on error
                    IsEnabled = false;
                    StopAllEffects();
                    throw;
                }
            }
        }

        public void SwitchMode()
        {
            ThrowIfDisposed();

            lock (lockObject)
            {
                if (isTransitioningMode) return;
                
                try
                {
                    isTransitioningMode = true;
                    
                    if (!IsAlwaysJitterMode && !IsAlwaysRecoilReductionMode)
                    {
                        bool previousState = IsJitterEnabled;
                        IsJitterEnabled = !IsJitterEnabled;
                        
                        // Only trigger events and state check if the state actually changed
                        if (previousState != IsJitterEnabled)
                        {
                            ModeChanged?.Invoke(this, IsJitterEnabled);
                            CheckMacroState();
                        }
                    }
                }
                finally
                {
                    isTransitioningMode = false;
                }
            }
        }

        public void SetJitterStrength(int strength)
        {
            ThrowIfDisposed();

            if (strength < 1 || strength > 20)
                throw new ArgumentOutOfRangeException(nameof(strength), "Strength must be between 1 and 20.");

            lock (lockObject)
            {
                jitterStrength = strength;
                jitterManager.SetStrength(strength);
            }
        }

        public void SetRecoilReductionStrength(int strength)
        {
            ThrowIfDisposed();

            if (strength < 1 || strength > 20)
                throw new ArgumentOutOfRangeException(nameof(strength), "Strength must be between 1 and 20.");

            lock (lockObject)
            {
                recoilReductionStrength = strength;
                recoilManager.SetStrength(strength);
            }
        }

        public void SetAlwaysJitterMode(bool enabled)
        {
            ThrowIfDisposed();

            lock (lockObject)
            {
                if (isTransitioningMode) return;
                
                try
                {
                    isTransitioningMode = true;
                    bool stateChanged = false;

                    // First handle disabling if requested
                    if (!enabled && IsAlwaysJitterMode)
                    {
                        IsAlwaysJitterMode = false;
                        stateChanged = true;
                    }
                    // Only allow enabling if the other mode is not enabled
                    else if (enabled && !IsAlwaysJitterMode && !IsAlwaysRecoilReductionMode)
                    {
                        IsAlwaysJitterMode = true;
                        IsJitterEnabled = true;
                        stateChanged = true;
                    }

                    if (stateChanged)
                    {
                        ModeChanged?.Invoke(this, IsJitterEnabled);
                        CheckMacroState();
                    }
                }
                finally
                {
                    isTransitioningMode = false;
                }
            }
        }

        public void SetAlwaysRecoilReductionMode(bool enabled)
        {
            ThrowIfDisposed();

            lock (lockObject)
            {
                if (isTransitioningMode) return;
                
                try
                {
                    isTransitioningMode = true;
                    bool stateChanged = false;

                    // First handle disabling if requested
                    if (!enabled && IsAlwaysRecoilReductionMode)
                    {
                        IsAlwaysRecoilReductionMode = false;
                        stateChanged = true;
                    }
                    // Only allow enabling if the other mode is not enabled
                    else if (enabled && !IsAlwaysRecoilReductionMode && !IsAlwaysJitterMode)
                    {
                        IsAlwaysRecoilReductionMode = true;
                        IsJitterEnabled = false;
                        stateChanged = true;
                    }

                    if (stateChanged)
                    {
                        ModeChanged?.Invoke(this, IsJitterEnabled);
                        CheckMacroState();
                    }
                }
                finally
                {
                    isTransitioningMode = false;
                }
            }
        }
        #endregion

        #region Private Methods
        private void ThrowIfDisposed()
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(MacroManager));
        }

        private void OnEffectStateChanged(object sender, bool active)
        {
            lock (lockObject)
            {
                CheckMacroState();
            }
        }

        private void StopAllEffects()
        {
            // Ensure we're in a locked context
            if (!Monitor.IsEntered(lockObject))
                throw new InvalidOperationException("StopAllEffects must be called within a lock");

            try
            {
                if (jitterManager.IsActive)
                {
                    JitterStopped?.Invoke(this, EventArgs.Empty);
                    jitterManager.Stop();
                }
                if (recoilManager.IsActive)
                {
                    RecoilReductionStopped?.Invoke(this, EventArgs.Empty);
                    recoilManager.Stop();
                }
            }
            finally
            {
                isActive = false;
            }
        }

        private void CheckMacroState()
        {
            // Ensure we're in a locked context
            if (!Monitor.IsEntered(lockObject))
                throw new InvalidOperationException("CheckMacroState must be called within a lock");

            try
            {
                bool shouldActivate = IsEnabled && leftButtonDown && rightButtonDown;

                // Always stop effects if we shouldn't be active
                if (!shouldActivate)
                {
                    StopAllEffects();
                    return;
                }

                // Determine which mode should be active
                bool shouldUseJitter = IsAlwaysJitterMode || (!IsAlwaysRecoilReductionMode && IsJitterEnabled);

                // If we're already active but in the wrong mode, stop all effects first
                if (isActive && (jitterManager.IsActive != shouldUseJitter || recoilManager.IsActive == shouldUseJitter))
                {
                    StopAllEffects();
                }

                // Start the appropriate effect if we're not active
                if (!isActive)
                {
                    try
                    {
                        if (shouldUseJitter)
                        {
                            JitterStarted?.Invoke(this, EventArgs.Empty);
                            jitterManager.Start();
                        }
                        else
                        {
                            RecoilReductionStarted?.Invoke(this, EventArgs.Empty);
                            recoilManager.Start();
                        }
                        isActive = true;
                    }
                    catch (Exception)
                    {
                        StopAllEffects();
                        throw;
                    }
                }
            }
            catch (Exception)
            {
                // Reset to a safe state on any error
                isActive = false;
                leftButtonDown = false;
                rightButtonDown = false;
                throw;
            }
        }
        #endregion

        #region IDisposable Implementation
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    lock (lockObject)
                    {
                        try
                        {
                            // Stop all effects first
                            StopAllEffects();

                            // Unsubscribe from events
                            if (jitterManager != null)
                            {
                                jitterManager.StateChanged -= OnEffectStateChanged;
                                jitterManager.Dispose();
                            }
                            if (recoilManager != null)
                            {
                                recoilManager.StateChanged -= OnEffectStateChanged;
                                recoilManager.Dispose();
                            }
                            inputSimulator?.Dispose();
                        }
                        catch
                        {
                            // Swallow exceptions in dispose
                        }
                    }
                }
                disposed = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}
</file>

<file path="src/Configuration/EventHandlerManager.cs">
using System;
using System.Collections.Generic;
using System.Windows.Forms;
using NotesAndTasks.Models;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Manages event handler registration and lifecycle for the application.
    /// Provides centralized control over event subscriptions and cleanup.
    /// </summary>
    public class EventHandlerManager : IDisposable
    {
        private readonly Dictionary<string, List<Delegate>> eventHandlers;
        private readonly ConfigurationManager configManager;
        private bool isDisposed;

        /// <summary>
        /// Initializes a new instance of the EventHandlerManager class.
        /// </summary>
        /// <param name="configManager">The configuration manager instance.</param>
        public EventHandlerManager(ConfigurationManager configManager)
        {
            this.configManager = configManager ?? throw new ArgumentNullException(nameof(configManager));
            this.eventHandlers = new Dictionary<string, List<Delegate>>();

            RegisterConfigurationEvents();
        }

        /// <summary>
        /// Registers configuration-related event handlers.
        /// </summary>
        private void RegisterConfigurationEvents()
        {
            // Settings change handlers
            RegisterEventHandler("SettingsChanged", 
                new EventHandler<SettingsChangedEventArgs>(OnSettingsChanged));
            configManager.SettingsChanged += OnSettingsChanged;

            // Settings validation handlers
            RegisterEventHandler("SettingsValidating",
                new EventHandler<SettingsValidationEventArgs>(OnSettingsValidating));
            configManager.SettingsValidating += OnSettingsValidating;

            // Settings backup handlers
            RegisterEventHandler("SettingsBackup",
                new EventHandler<SettingsBackupEventArgs>(OnSettingsBackupCompleted));
            configManager.SettingsBackupCompleted += OnSettingsBackupCompleted;
        }

        /// <summary>
        /// Registers a control's event handlers.
        /// </summary>
        /// <param name="control">The control to register events for.</param>
        public void RegisterControlEvents<T>(T control) where T : Control
        {
            if (control == null) return;

            // Store event handlers
            var handlers = new List<Delegate>();
            eventHandlers[control.Name] = handlers;

            // Common events
            EventHandler clickHandler = (s, e) => OnControlClick(control, e);
            control.Click += clickHandler;
            handlers.Add(clickHandler);

            // Mouse events
            MouseEventHandler mouseDownHandler = (s, e) => OnControlMouseDown(control, e);
            control.MouseDown += mouseDownHandler;
            handlers.Add(mouseDownHandler);

            MouseEventHandler mouseUpHandler = (s, e) => OnControlMouseUp(control, e);
            control.MouseUp += mouseUpHandler;
            handlers.Add(mouseUpHandler);

            // Type-specific events
            if (control is TrackBar trackBar)
            {
                EventHandler valueChangedHandler = (s, e) => OnTrackBarValueChanged(trackBar, e);
                trackBar.ValueChanged += valueChangedHandler;
                handlers.Add(valueChangedHandler);

                EventHandler scrollHandler = (s, e) => OnTrackBarScroll(trackBar, e);
                trackBar.Scroll += scrollHandler;
                handlers.Add(scrollHandler);
            }
            else if (control is CheckBox checkBox)
            {
                EventHandler checkedChangedHandler = (s, e) => OnCheckBoxCheckedChanged(checkBox, e);
                checkBox.CheckedChanged += checkedChangedHandler;
                handlers.Add(checkedChangedHandler);
            }
            else if (control is TextBox textBox)
            {
                EventHandler textChangedHandler = (s, e) => OnTextBoxTextChanged(textBox, e);
                textBox.TextChanged += textChangedHandler;
                handlers.Add(textChangedHandler);

                KeyEventHandler keyDownHandler = (s, e) => OnTextBoxKeyDown(textBox, e);
                textBox.KeyDown += keyDownHandler;
                handlers.Add(keyDownHandler);
            }
        }

        /// <summary>
        /// Registers an event handler with tracking.
        /// </summary>
        private void RegisterEventHandler(string eventName, Delegate handler)
        {
            if (!eventHandlers.ContainsKey(eventName))
            {
                eventHandlers[eventName] = new List<Delegate>();
            }
            eventHandlers[eventName].Add(handler);
        }

        /// <summary>
        /// Unregisters all event handlers for a control.
        /// </summary>
        public void UnregisterControlEvents(Control control)
        {
            if (control == null) return;

            var handlersToRemove = new List<string>();
            foreach (var kvp in eventHandlers)
            {
                if (kvp.Key.StartsWith($"{control.Name}_"))
                {
                    handlersToRemove.Add(kvp.Key);
                }
            }

            foreach (var handlerName in handlersToRemove)
            {
                eventHandlers.Remove(handlerName);
            }
        }

        /// <summary>
        /// Handles settings changes
        /// </summary>
        private void OnSettingsChanged(object sender, SettingsChangedEventArgs e)
        {
            if (e.Section == "All")
            {
                // Process all sections
                HandleMacroSettingsChanges(e.PreviousSettings, e.NewSettings);
                HandleHotkeySettingsChanges(e.PreviousSettings, e.NewSettings);
                HandleUISettingsChanges(e.PreviousSettings, e.NewSettings);
            }
            else if (e.Section == "MacroSettings")
            {
                HandleMacroSettingsChanges(e.PreviousSettings, e.NewSettings);
            }
            else if (e.Section == "HotkeySettings")
            {
                HandleHotkeySettingsChanges(e.PreviousSettings, e.NewSettings);
            }
            else if (e.Section == "UISettings")
            {
                HandleUISettingsChanges(e.PreviousSettings, e.NewSettings);
            }
        }

        /// <summary>
        /// Handles settings validation
        /// </summary>
        private void OnSettingsValidating(object sender, SettingsValidationEventArgs e)
        {
            var settings = e.Settings;
            if (settings == null)
            {
                e.IsValid = false;
                e.Message = "Settings cannot be null";
                return;
            }

            // Validate macro settings
            if (settings.MacroSettings.AlwaysJitterMode && settings.MacroSettings.AlwaysRecoilReductionMode)
            {
                e.IsValid = false;
                e.Message = "Cannot enable both AlwaysJitterMode and AlwaysRecoilReductionMode simultaneously";
                return;
            }

            // Validate hotkey settings
            if (settings.HotkeySettings.MacroKey.Key == settings.HotkeySettings.SwitchKey.Key &&
                settings.HotkeySettings.MacroKey.Type == settings.HotkeySettings.SwitchKey.Type)
            {
                e.IsValid = false;
                e.Message = "Macro key and switch key cannot be the same";
                return;
            }

            // Validate UI settings
            if (settings.UISettings.WindowSize.Width <= 0 || settings.UISettings.WindowSize.Height <= 0)
            {
                e.IsValid = false;
                e.Message = "Window size dimensions must be positive";
                return;
            }
        }

        /// <summary>
        /// Handles settings backup completion
        /// </summary>
        private void OnSettingsBackupCompleted(object sender, SettingsBackupEventArgs e)
        {
            if (e.Success)
            {
                System.Diagnostics.Debug.WriteLine($"Backup completed successfully: {e.BackupPath}");
            }
            else
            {
                System.Diagnostics.Debug.WriteLine($"Backup failed: {e.ErrorMessage}");
            }
        }

        /// <summary>
        /// Handles changes to macro settings.
        /// </summary>
        private void HandleMacroSettingsChanges(AppSettings previousSettings, AppSettings newSettings)
        {
            if (previousSettings?.MacroSettings.JitterStrength != newSettings.MacroSettings.JitterStrength)
            {
                System.Diagnostics.Debug.WriteLine($"Jitter strength changed from {previousSettings?.MacroSettings.JitterStrength} to {newSettings.MacroSettings.JitterStrength}");
            }

            if (previousSettings?.MacroSettings.JitterEnabled != newSettings.MacroSettings.JitterEnabled)
            {
                System.Diagnostics.Debug.WriteLine($"Jitter enabled changed from {previousSettings?.MacroSettings.JitterEnabled} to {newSettings.MacroSettings.JitterEnabled}");
            }

            if (previousSettings?.MacroSettings.AlwaysJitterMode != newSettings.MacroSettings.AlwaysJitterMode)
            {
                System.Diagnostics.Debug.WriteLine($"Always jitter mode changed from {previousSettings?.MacroSettings.AlwaysJitterMode} to {newSettings.MacroSettings.AlwaysJitterMode}");
            }

            if (previousSettings?.MacroSettings.RecoilReductionStrength != newSettings.MacroSettings.RecoilReductionStrength)
            {
                System.Diagnostics.Debug.WriteLine($"Recoil reduction strength changed from {previousSettings?.MacroSettings.RecoilReductionStrength} to {newSettings.MacroSettings.RecoilReductionStrength}");
            }

            if (previousSettings?.MacroSettings.RecoilReductionEnabled != newSettings.MacroSettings.RecoilReductionEnabled)
            {
                System.Diagnostics.Debug.WriteLine($"Recoil reduction enabled changed from {previousSettings?.MacroSettings.RecoilReductionEnabled} to {newSettings.MacroSettings.RecoilReductionEnabled}");
            }

            if (previousSettings?.MacroSettings.AlwaysRecoilReductionMode != newSettings.MacroSettings.AlwaysRecoilReductionMode)
            {
                System.Diagnostics.Debug.WriteLine($"Always recoil reduction mode changed from {previousSettings?.MacroSettings.AlwaysRecoilReductionMode} to {newSettings.MacroSettings.AlwaysRecoilReductionMode}");
            }
        }

        /// <summary>
        /// Handles changes to hotkey settings.
        /// </summary>
        private void HandleHotkeySettingsChanges(AppSettings previousSettings, AppSettings newSettings)
        {
            if (previousSettings?.HotkeySettings.MacroKey.Key != newSettings.HotkeySettings.MacroKey.Key || 
                previousSettings?.HotkeySettings.MacroKey.Type != newSettings.HotkeySettings.MacroKey.Type)
            {
                System.Diagnostics.Debug.WriteLine($"Macro toggle key changed from {previousSettings?.HotkeySettings.MacroKey.DisplayName} to {newSettings.HotkeySettings.MacroKey.DisplayName}");
            }

            if (previousSettings?.HotkeySettings.SwitchKey.Key != newSettings.HotkeySettings.SwitchKey.Key ||
                previousSettings?.HotkeySettings.SwitchKey.Type != newSettings.HotkeySettings.SwitchKey.Type)
            {
                System.Diagnostics.Debug.WriteLine($"Mode switch key changed from {previousSettings?.HotkeySettings.SwitchKey.DisplayName} to {newSettings.HotkeySettings.SwitchKey.DisplayName}");
            }
        }

        /// <summary>
        /// Handles changes to UI settings.
        /// </summary>
        private void HandleUISettingsChanges(AppSettings previousSettings, AppSettings newSettings)
        {
            if (previousSettings?.UISettings.MinimizeToTray != newSettings.UISettings.MinimizeToTray)
            {
                System.Diagnostics.Debug.WriteLine($"Minimize to tray changed from {previousSettings?.UISettings.MinimizeToTray} to {newSettings.UISettings.MinimizeToTray}");
            }

            if (previousSettings?.UISettings.ShowDebugPanel != newSettings.UISettings.ShowDebugPanel)
            {
                System.Diagnostics.Debug.WriteLine($"Show debug panel changed from {previousSettings?.UISettings.ShowDebugPanel} to {newSettings.UISettings.ShowDebugPanel}");
            }

            if (previousSettings?.UISettings.ShowStatusInTitle != newSettings.UISettings.ShowStatusInTitle)
            {
                System.Diagnostics.Debug.WriteLine($"Show status in title changed from {previousSettings?.UISettings.ShowStatusInTitle} to {newSettings.UISettings.ShowStatusInTitle}");
            }

            if (previousSettings?.UISettings.ShowTrayNotifications != newSettings.UISettings.ShowTrayNotifications)
            {
                System.Diagnostics.Debug.WriteLine($"Show tray notifications changed from {previousSettings?.UISettings.ShowTrayNotifications} to {newSettings.UISettings.ShowTrayNotifications}");
            }
        }

        // Event handler methods
        private void OnControlClick(Control control, EventArgs e)
        {
            // Handle click event
        }

        private void OnControlMouseDown(Control control, MouseEventArgs e)
        {
            // Handle mouse down
        }

        private void OnControlMouseUp(Control control, MouseEventArgs e)
        {
            // Handle mouse up
        }

        private void OnTrackBarValueChanged(TrackBar trackBar, EventArgs e)
        {
            // Handle value changed
        }

        private void OnTrackBarScroll(TrackBar trackBar, EventArgs e)
        {
            // Handle scroll
        }

        private void OnCheckBoxCheckedChanged(CheckBox checkBox, EventArgs e)
        {
            // Handle checked changed
        }

        private void OnTextBoxTextChanged(TextBox textBox, EventArgs e)
        {
            // Handle text changed
        }

        private void OnTextBoxKeyDown(TextBox textBox, KeyEventArgs e)
        {
            // Handle key down
        }

        /// <summary>
        /// Disposes of the event handler manager and unregisters all events.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Protected implementation of Dispose pattern.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (!isDisposed)
            {
                if (disposing)
                {
                    // Unregister all event handlers
                    configManager.SettingsChanged -= OnSettingsChanged;
                    configManager.SettingsValidating -= OnSettingsValidating;
                    configManager.SettingsBackupCompleted -= OnSettingsBackupCompleted;

                    eventHandlers.Clear();
                }

                isDisposed = true;
            }
        }
    }
}
</file>

<file path="src/Utilities/InputSimulator.cs">
using System;
using System.Runtime.InteropServices;
using NotesAndTasks.Hooks;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Provides functionality for simulating mouse input and movement.
    /// This class encapsulates the Windows SendInput API for mouse control.
    /// </summary>
    public class InputSimulator : IDisposable
    {
        private bool disposed = false;
        private readonly object lockObject = new object();

        [StructLayout(LayoutKind.Sequential)]
        private struct MOUSEINPUT
        {
            public int dx;
            public int dy;
            public uint mouseData;
            public uint dwFlags;
            public uint time;
            public IntPtr dwExtraInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct INPUT
        {
            public uint type;
            public MOUSEINPUT mi;
        }

        private const int INPUT_MOUSE = 0;
        private const int MOUSEEVENTF_MOVE = 0x0001;

        [DllImport("user32.dll", SetLastError = true)]
        private static extern uint SendInput(uint nInputs, ref INPUT pInputs, int cbSize);

        /// <summary>
        /// Simulates mouse movement by the specified delta values.
        /// </summary>
        /// <param name="deltaX">The change in X coordinate.</param>
        /// <param name="deltaY">The change in Y coordinate.</param>
        /// <returns>True if the input was successfully simulated, false otherwise.</returns>
        public bool SimulateMouseMovement(int deltaX, int deltaY)
        {
            if (disposed)
            {
                throw new ObjectDisposedException(nameof(InputSimulator));
            }

            try
            {
                lock (lockObject)
                {
                    // Validate movement values
                    if (Math.Abs(deltaX) > 100 || Math.Abs(deltaY) > 100)
                    {
                        return false;
                    }

                    var input = new INPUT
                    {
                        type = INPUT_MOUSE,
                        mi = new MOUSEINPUT
                        {
                            dx = deltaX,
                            dy = deltaY,
                            mouseData = 0,
                            time = 0,
                            dwExtraInfo = IntPtr.Zero,
                            dwFlags = MOUSEEVENTF_MOVE
                        }
                    };

                    return SendInput(1, ref input, Marshal.SizeOf(input)) == 1;
                }
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Simulates mouse movement with jitter pattern.
        /// </summary>
        /// <param name="pattern">The jitter pattern coordinates (dx, dy).</param>
        /// <param name="strength">The strength multiplier for the pattern (1-20).</param>
        /// <returns>True if the input was successfully simulated, false otherwise.</returns>
        public bool SimulateJitterMovement((int dx, int dy) pattern, int strength)
        {
            if (disposed)
            {
                throw new ObjectDisposedException(nameof(InputSimulator));
            }

            if (strength < 1 || strength > 20)
            {
                throw new ArgumentOutOfRangeException(nameof(strength), "Strength must be between 1 and 20.");
            }

            int scaledDx = (int)(pattern.dx * strength / 7.0);
            int scaledDy = (int)(pattern.dy * strength / 7.0);

            return SimulateMouseMovement(scaledDx, scaledDy);
        }

        /// <summary>
        /// Simulates mouse movement for recoil reduction.
        /// </summary>
        /// <param name="strength">The strength of the recoil reduction (1-20).</param>
        /// <returns>True if the input was successfully simulated, false otherwise.</returns>
        public bool SimulateRecoilReduction(int strength)
        {
            if (disposed)
            {
                throw new ObjectDisposedException(nameof(InputSimulator));
            }

            if (strength < 1 || strength > 20)
            {
                throw new ArgumentOutOfRangeException(nameof(strength), "Strength must be between 1 and 20.");
            }

            int verticalMovement;
            const double BASE_RECOIL_STRENGTH = 0.75;

            // Low level recoil reduction (1-6)
            if (strength <= 6)
            {
                // lowest level of recoil reduction (1)
                if (strength == 1)
                {
                    verticalMovement = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * 0.3));
                }
                // Progressive scaling for 2-6 with more distinct steps
                else
                {
                    // Use stepped scaling to create more noticeable differences
                    double stepMultiplier = strength switch
                    {
                        2 => 1.0,
                        3 => 1.5,
                        4 => 1.9,
                        5 => 2.2,
                        6 => 3.0,
                        _ => 1.5
                    };
                    verticalMovement = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * stepMultiplier * 2.0));
                }
            }
            // Medium level recoil reduction (7-16)
            else if (strength <= 16)
            {
                // Smoother scaling with reduced multiplier
                double baseValue = BASE_RECOIL_STRENGTH * 1.1;
                double scalingFactor = 1 + ((strength - 6) * 0.08);
                verticalMovement = Math.Max(1, (int)Math.Round(baseValue * strength * scalingFactor));
            }
            // High level recoil reduction (17-20)
            else
            {
                double baseValue = BASE_RECOIL_STRENGTH * 20.0;
                double scalingFactor = 1.18; // Reduced from 1.19 for smoother scaling
                double exponentialBoost = 1.08; // Reduced from 1.1 for smoother scaling
                verticalMovement = Math.Max(1, (int)Math.Round(
                    baseValue *
                    Math.Pow(scalingFactor, strength - 13) *
                    Math.Pow(exponentialBoost, strength - 13)
                ));
            }

            return SimulateMouseMovement(0, verticalMovement);
        }

        /// <summary>
        /// Moves the mouse to the specified coordinates.
        /// </summary>
        /// <param name="dx">The change in X coordinate.</param>
        /// <param name="dy">The change in Y coordinate.</param>
        public void MoveMouse(int dx, int dy)
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(InputSimulator));

            if (Math.Abs(dx) > 100 || Math.Abs(dy) > 100)
            {
                throw new ArgumentOutOfRangeException("Movement values exceeded safe limits");
            }

            var input = new INPUT
            {
                type = INPUT_MOUSE,
                mi = new MOUSEINPUT
                {
                    dx = dx,
                    dy = dy,
                    mouseData = 0,
                    dwFlags = MOUSEEVENTF_MOVE,
                    time = 0,
                    dwExtraInfo = IntPtr.Zero
                }
            };

            SendInput(1, ref input, Marshal.SizeOf(input));
        }

        /// <summary>
        /// Disposes of resources used by the InputSimulator.
        /// </summary>
        public void Dispose()
        {
            if (!disposed)
            {
                disposed = true;
                GC.SuppressFinalize(this);
            }
        }
    }
}
</file>

<file path="src/Utilities/RecoilReductionManager.cs">
using System;
using System.Windows.Forms;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Manages recoil reduction functionality for mouse movement.
    /// This class handles the timing and strength of vertical compensation.
    /// </summary>
    public class RecoilReductionManager : MacroEffectBase
    {
        /// <summary>
        /// Initializes a new instance of the RecoilReductionManager class.
        /// </summary>
        /// <param name="inputSimulator">The input simulator to use for mouse movement.</param>
        public RecoilReductionManager(InputSimulator inputSimulator) : base(inputSimulator, 1)
        {
        }

        /// <summary>
        /// Timer callback that applies the recoil reduction movement.
        /// </summary>
        protected override void OnTimerTick(object state)
        {
            if (!IsActive) return;

            try
            {
                // Use InputSimulator's SimulateRecoilReduction method to avoid duplication
                InputSimulator.SimulateRecoilReduction(Strength);
            }
            catch (Exception)
            {
                Stop();
            }
        }
    }
}
</file>

<file path="MouseMacro.csproj">
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net6.0-windows</TargetFramework>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
    <UacUIApproved>true</UacUIApproved>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <AssemblyName>Notes&amp;Tasks</AssemblyName>
    <RootNamespace>NotesAndTasks</RootNamespace>
    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>
    <ApplicationIcon>assets\logo.ico</ApplicationIcon>
    <Title>Notes &amp; Tasks</Title>
    <Authors>HaikalllP</Authors>
    <Description>Task Management and Note Taking Application</Description>
    <SignAssembly>true</SignAssembly>
    <EnableUnsafeBinaryFormatterSerialization>true</EnableUnsafeBinaryFormatterSerialization>
    <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
    <Version>1.0.0.1</Version> <!-- Incrementing the version for the next release -->
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DebugType>embedded</DebugType>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
    <DebugType>none</DebugType>
    <Optimize>true</Optimize>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="src\**\*.cs">
      <Link>%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="src\UI\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
</Project>
</file>

<file path="src/UI/MacroForm.Designer.cs">
using System;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;
using NotesAndTasks.Hooks;

namespace NotesAndTasks
{
    partial class MacroForm
    {
        /// <summary>
        ///  Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        ///  Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Unsubscribe from events
                if (chkAlwaysJitter != null)
                {
                    chkAlwaysJitter.CheckedChanged -= alwaysJitterCheckedChanged;
                }
                if (chkAlwaysRecoilReduction != null)
                {
                    chkAlwaysRecoilReduction.CheckedChanged -= alwaysRecoilReductionCheckedChanged;
                }

                // Dispose other resources
                if (components != null)
                {
                    components.Dispose();
                }

                // Dispose managers
                if (macroManager != null)
                {
                    macroManager.Dispose();
                }

                // Dispose hooks
                if (keyboardHook != null)
                {
                    keyboardHook.Stop();
                    keyboardHook.Dispose();
                }

                if (mouseHook != null)
                {
                    mouseHook.Stop();
                    mouseHook.Dispose();
                }

                // Dispose UI resources
                if (notifyIcon != null)
                {
                    notifyIcon.Visible = false;
                    notifyIcon.Dispose();
                }

                if (toolTip != null)
                {
                    toolTip.Dispose();
                }

                if (uiManager != null)
                {
                    uiManager.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        ///  Required method for Designer support - do not modify
        ///  the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
            mainPanel = new Panel();
            debugPanel = new Panel();
            debugLabel = new TextBox();
            btnToggleDebug = new ModernButton();
            strengthPanel1 = new Panel();
            lblRecoilReductionStrengthValue = new Label();
            lblRecoilReductionStrengthPrefix = new Label();
            trackBarRecoilReduction = new ModernTrackBar();
            lblRecoilReductionActive = new Label();
            strengthPanel2 = new Panel();
            lblJitterStrengthValue = new Label();
            lblJitterStrengthPrefix = new Label();
            trackBarJitter = new ModernTrackBar();
            lblJitterActive = new Label();
            settingsPanel = new Panel();
            lblCurrentKeyValue = new Label();
            lblCurrentKeyPrefix = new Label();
            btnSetKey = new ModernButton();
            chkMinimizeToTray = new CheckBox();
            lblMacroSwitchKeyValue = new Label();
            btnSetMacroSwitch = new ModernButton();
            lblMacroSwitchKeyPrefix = new Label();
            chkAlwaysJitter = new CheckBox();
            chkAlwaysRecoilReduction = new CheckBox();
            notifyIcon = new NotifyIcon(components);
            trayContextMenu = new ContextMenuStrip(components);
            showWindowMenuItem = new ToolStripMenuItem();
            exitMenuItem = new ToolStripMenuItem();

            mainPanel.SuspendLayout();
            debugPanel.SuspendLayout();
            strengthPanel1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarRecoilReduction).BeginInit();
            strengthPanel2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarJitter).BeginInit();
            settingsPanel.SuspendLayout();
            trayContextMenu.SuspendLayout();
            SuspendLayout();
            // 
            // mainPanel
            // 
            mainPanel.Dock = DockStyle.Fill;
            mainPanel.BackColor = Color.FromArgb(16, 2, 31);
            mainPanel.Controls.Add(debugPanel);
            mainPanel.Controls.Add(btnToggleDebug);
            mainPanel.Controls.Add(strengthPanel1);
            mainPanel.Controls.Add(strengthPanel2);
            mainPanel.Controls.Add(settingsPanel);
            mainPanel.Controls.Add(chkAlwaysJitter);
            mainPanel.Controls.Add(chkAlwaysRecoilReduction);
            mainPanel.Location = new Point(0, 0);
            mainPanel.Margin = new Padding(3, 2, 3, 2);
            mainPanel.Name = "mainPanel";
            mainPanel.Padding = new Padding(14, 12, 14, 12);
            mainPanel.Size = new Size(477, 676);
            mainPanel.TabIndex = 0;
            // 
            // debugPanel
            // 
            debugPanel.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            debugPanel.AutoScroll = true;
            debugPanel.BackColor = Color.FromArgb(214, 37, 106);
            debugPanel.BorderStyle = BorderStyle.FixedSingle;
            debugPanel.Controls.Add(debugLabel);
            debugPanel.Location = new Point(20, 541);
            debugPanel.Margin = new Padding(3, 2, 3, 2);
            debugPanel.Name = "debugPanel";
            debugPanel.Padding = new Padding(7, 6, 7, 6);
            debugPanel.Size = new Size(438, 124);
            debugPanel.TabIndex = 7;
            debugPanel.Visible = false;
            // 
            // debugLabel
            // 
            debugLabel.BackColor = Color.FromArgb(16, 2, 31);
            debugLabel.BorderStyle = BorderStyle.None;
            debugLabel.Dock = DockStyle.Fill;
            debugLabel.Font = new Font("JetBrains Mono", 9.75F, FontStyle.Regular, GraphicsUnit.Point);
            debugLabel.ForeColor = Color.White;
            debugLabel.Location = new Point(7, 6);
            debugLabel.Margin = new Padding(3, 2, 3, 2);
            debugLabel.Multiline = true;
            debugLabel.Name = "debugLabel";
            debugLabel.ReadOnly = true;
            debugLabel.ScrollBars = ScrollBars.Vertical;
            debugLabel.Size = new Size(422, 110);
            debugLabel.TabIndex = 0;
            // 
            // btnToggleDebug
            // 
            btnToggleDebug.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            btnToggleDebug.BackColor = Color.FromArgb(30, 1, 62);
            btnToggleDebug.BorderColor = Color.FromArgb(250, 91, 101);
            btnToggleDebug.BorderRadius = 10;
            btnToggleDebug.FlatStyle = FlatStyle.Flat;
            btnToggleDebug.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            btnToggleDebug.ForeColor = Color.White;
            btnToggleDebug.HoverBackColor = Color.FromArgb(214, 37, 106);
            btnToggleDebug.Location = new Point(21, 495);
            btnToggleDebug.Margin = new Padding(0, 0, 0, 12);
            btnToggleDebug.Name = "btnToggleDebug";
            btnToggleDebug.Size = new Size(437, 35);
            btnToggleDebug.TabIndex = 5;
            btnToggleDebug.Text = "Show Debug Info";
            btnToggleDebug.UseVisualStyleBackColor = false;
            // 
            // strengthPanel1
            // 
            strengthPanel1.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            strengthPanel1.Controls.Add(lblRecoilReductionStrengthValue);
            strengthPanel1.Controls.Add(lblRecoilReductionStrengthPrefix);
            strengthPanel1.Controls.Add(trackBarRecoilReduction);
            strengthPanel1.Controls.Add(lblRecoilReductionActive);
            strengthPanel1.Location = new Point(20, 225);
            strengthPanel1.Margin = new Padding(0, 0, 0, 12);
            strengthPanel1.Name = "strengthPanel1";
            strengthPanel1.Size = new Size(438, 84);
            strengthPanel1.TabIndex = 9;
            // 
            // lblRecoilReductionStrengthValue
            // 
            lblRecoilReductionStrengthValue.AutoSize = true;
            lblRecoilReductionStrengthValue.Font = new Font("JetBrains Mono", 10F, FontStyle.Bold, GraphicsUnit.Point);
            lblRecoilReductionStrengthValue.ForeColor = Color.White;
            lblRecoilReductionStrengthValue.Location = new Point(212, 6);
            lblRecoilReductionStrengthValue.Margin = new Padding(0);
            lblRecoilReductionStrengthValue.Name = "lblRecoilReductionStrengthValue";
            lblRecoilReductionStrengthValue.Size = new Size(16, 18);
            lblRecoilReductionStrengthValue.TabIndex = 1;
            lblRecoilReductionStrengthValue.Text = "1";
            // 
            // lblRecoilReductionStrengthPrefix
            // 
            lblRecoilReductionStrengthPrefix.AutoSize = true;
            lblRecoilReductionStrengthPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblRecoilReductionStrengthPrefix.ForeColor = Color.White;
            lblRecoilReductionStrengthPrefix.Location = new Point(0, 6);
            lblRecoilReductionStrengthPrefix.Margin = new Padding(0);
            lblRecoilReductionStrengthPrefix.Name = "lblRecoilReductionStrengthPrefix";
            lblRecoilReductionStrengthPrefix.Size = new Size(216, 18);
            lblRecoilReductionStrengthPrefix.TabIndex = 0;
            lblRecoilReductionStrengthPrefix.Text = "Recoil Reduction Strength:";
            // 
            // trackBarRecoilReduction
            // 
            trackBarRecoilReduction.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            trackBarRecoilReduction.Location = new Point(0, 37);
            trackBarRecoilReduction.Margin = new Padding(0);
            trackBarRecoilReduction.Maximum = 20;
            trackBarRecoilReduction.Minimum = 1;
            trackBarRecoilReduction.Name = "trackBarRecoilReduction";
            trackBarRecoilReduction.Size = new Size(438, 45);
            trackBarRecoilReduction.TabIndex = 8;
            trackBarRecoilReduction.ThumbColor = Color.FromArgb(255, 255, 255);
            trackBarRecoilReduction.TickColor = Color.FromArgb(250, 91, 101);
            trackBarRecoilReduction.TrackColor = Color.FromArgb(214, 37, 106);
            trackBarRecoilReduction.Value = 1;
            // 
            // lblRecoilReductionActive (RecoilReduction Active Label)
            // 
            lblRecoilReductionActive.AutoSize = true;
            lblRecoilReductionActive.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblRecoilReductionActive.ForeColor = Color.FromArgb(250, 91, 101);
            lblRecoilReductionActive.Location = new Point(350, 5);
            lblRecoilReductionActive.Name = "lblRecoilReductionActive";
            lblRecoilReductionActive.Size = new Size(0, 20);
            lblRecoilReductionActive.TabIndex = 1;
            lblRecoilReductionActive.TextAlign = ContentAlignment.MiddleRight;
            // 
            // strengthPanel2
            // 
            strengthPanel2.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            strengthPanel2.Controls.Add(lblJitterStrengthValue);
            strengthPanel2.Controls.Add(lblJitterStrengthPrefix);
            strengthPanel2.Controls.Add(trackBarJitter);
            strengthPanel2.Controls.Add(lblJitterActive);
            strengthPanel2.Location = new Point(20, 331);
            strengthPanel2.Margin = new Padding(0, 0, 0, 12);
            strengthPanel2.Name = "strengthPanel2";
            strengthPanel2.Size = new Size(438, 81);
            strengthPanel2.TabIndex = 10;
            // 
            // lblJitterStrengthValue
            // 
            lblJitterStrengthValue.AutoSize = true;
            lblJitterStrengthValue.Font = new Font("JetBrains Mono", 10F, FontStyle.Bold, GraphicsUnit.Point);
            lblJitterStrengthValue.ForeColor = Color.White;
            lblJitterStrengthValue.Location = new Point(132, 6);
            lblJitterStrengthValue.Margin = new Padding(0);
            lblJitterStrengthValue.Name = "lblJitterStrengthValue";
            lblJitterStrengthValue.Size = new Size(16, 18);
            lblJitterStrengthValue.TabIndex = 1;
            lblJitterStrengthValue.Text = "3";
            // 
            // lblJitterStrengthPrefix
            // 
            lblJitterStrengthPrefix.AutoSize = true;
            lblJitterStrengthPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblJitterStrengthPrefix.ForeColor = Color.White;
            lblJitterStrengthPrefix.Location = new Point(0, 6);
            lblJitterStrengthPrefix.Margin = new Padding(0);
            lblJitterStrengthPrefix.Name = "lblJitterStrengthPrefix";
            lblJitterStrengthPrefix.Size = new Size(144, 18);
            lblJitterStrengthPrefix.TabIndex = 0;
            lblJitterStrengthPrefix.Text = "Jitter Strength: ";
            // 
            // trackBarJitter
            // 
            trackBarJitter.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            trackBarJitter.Location = new Point(0, 34);
            trackBarJitter.Margin = new Padding(0);
            trackBarJitter.Maximum = 20;
            trackBarJitter.Minimum = 1;
            trackBarJitter.Name = "trackBarJitter";
            trackBarJitter.Size = new Size(438, 45);
            trackBarJitter.TabIndex = 3;
            trackBarJitter.ThumbColor = Color.FromArgb(255, 255, 255);
            trackBarJitter.TickColor = Color.FromArgb(250, 91, 101);
            trackBarJitter.TrackColor = Color.FromArgb(214, 37, 106);
            trackBarJitter.Value = 3;
            // 
            // lblJitterActive (Jitter Active Label)
            // 
            lblJitterActive.AutoSize = true;
            lblJitterActive.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblJitterActive.ForeColor = Color.FromArgb(250, 91, 101);
            lblJitterActive.Location = new Point(350, 5);
            lblJitterActive.Name = "lblJitterActive";
            lblJitterActive.Size = new Size(0, 20);
            lblJitterActive.TabIndex = 0;
            lblJitterActive.TextAlign = ContentAlignment.MiddleRight;
            // 
            // settingsPanel
            // 
            settingsPanel.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            settingsPanel.Controls.Add(lblCurrentKeyValue);
            settingsPanel.Controls.Add(lblCurrentKeyPrefix);
            settingsPanel.Controls.Add(btnSetKey);
            settingsPanel.Controls.Add(chkMinimizeToTray);
            settingsPanel.Controls.Add(lblMacroSwitchKeyValue);
            settingsPanel.Controls.Add(btnSetMacroSwitch);
            settingsPanel.Controls.Add(lblMacroSwitchKeyPrefix);
            settingsPanel.Location = new Point(20, 25);
            settingsPanel.Margin = new Padding(0, 0, 0, 12);
            settingsPanel.Name = "settingsPanel";
            settingsPanel.Size = new Size(438, 179);
            settingsPanel.TabIndex = 11;
            // 
            // lblCurrentKeyValue
            // 
            lblCurrentKeyValue.AutoSize = true;
            lblCurrentKeyValue.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Bold, GraphicsUnit.Point);
            lblCurrentKeyValue.ForeColor = Color.White;
            lblCurrentKeyValue.Location = new Point(141, 22);
            lblCurrentKeyValue.Margin = new Padding(0);
            lblCurrentKeyValue.Name = "lblCurrentKeyValue";
            lblCurrentKeyValue.Size = new Size(64, 18);
            lblCurrentKeyValue.TabIndex = 1;
            lblCurrentKeyValue.Text = "Capital";
            // 
            // lblCurrentKeyPrefix
            // 
            lblCurrentKeyPrefix.AutoSize = true;
            lblCurrentKeyPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblCurrentKeyPrefix.ForeColor = Color.White;
            lblCurrentKeyPrefix.Location = new Point(0, 21);
            lblCurrentKeyPrefix.Margin = new Padding(0);
            lblCurrentKeyPrefix.Name = "lblCurrentKeyPrefix";
            lblCurrentKeyPrefix.Size = new Size(144, 18);
            lblCurrentKeyPrefix.TabIndex = 0;
            lblCurrentKeyPrefix.Text = "Macro Toggle Key:";
            // 
            // btnSetKey
            // 
            btnSetKey.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            btnSetKey.BackColor = Color.FromArgb(30, 1, 62);
            btnSetKey.BorderColor = Color.FromArgb(250, 91, 101);
            btnSetKey.BorderRadius = 10;
            btnSetKey.FlatStyle = FlatStyle.Flat;
            btnSetKey.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            btnSetKey.ForeColor = Color.White;
            btnSetKey.HoverBackColor = Color.FromArgb(214, 37, 106);
            btnSetKey.Location = new Point(1, 49);
            btnSetKey.Margin = new Padding(0, 0, 0, 12);
            btnSetKey.Name = "btnSetKey";
            btnSetKey.Size = new Size(437, 35);
            btnSetKey.TabIndex = 1;
            btnSetKey.Text = "Set Toggle Key";
            btnSetKey.UseVisualStyleBackColor = false;
            // 
            // chkMinimizeToTray
            // 
            chkMinimizeToTray.Anchor = AnchorStyles.Top | AnchorStyles.Right;
            chkMinimizeToTray.AutoSize = true;
            chkMinimizeToTray.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            chkMinimizeToTray.ForeColor = Color.White;
            chkMinimizeToTray.Location = new Point(280, 3);
            chkMinimizeToTray.Margin = new Padding(3, 2, 3, 2);
            chkMinimizeToTray.Name = "chkMinimizeToTray";
            chkMinimizeToTray.Size = new Size(155, 22);
            chkMinimizeToTray.TabIndex = 6;
            chkMinimizeToTray.Text = "Minimize to Tray";
            // 
            // lblMacroSwitchKeyValue
            // 
            lblMacroSwitchKeyValue.AutoSize = true;
            lblMacroSwitchKeyValue.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Bold, GraphicsUnit.Point);
            lblMacroSwitchKeyValue.ForeColor = Color.White;
            lblMacroSwitchKeyValue.Location = new Point(148, 105);
            lblMacroSwitchKeyValue.Name = "lblMacroSwitchKeyValue";
            lblMacroSwitchKeyValue.Size = new Size(20, 19);
            lblMacroSwitchKeyValue.TabIndex = 5;
            lblMacroSwitchKeyValue.Text = "Q";
            // 
            // btnSetMacroSwitch
            // 
            btnSetMacroSwitch.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            btnSetMacroSwitch.BackColor = Color.FromArgb(30, 1, 62);
            btnSetMacroSwitch.BorderColor = Color.FromArgb(250, 91, 101);
            btnSetMacroSwitch.BorderRadius = 10;
            btnSetMacroSwitch.FlatStyle = FlatStyle.Flat;
            btnSetMacroSwitch.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            btnSetMacroSwitch.ForeColor = Color.White;
            btnSetMacroSwitch.HoverBackColor = Color.FromArgb(214, 37, 106);
            btnSetMacroSwitch.Location = new Point(1, 133);
            btnSetMacroSwitch.Margin = new Padding(0, 0, 0, 12);
            btnSetMacroSwitch.Name = "btnSetMacroSwitch";
            btnSetMacroSwitch.Size = new Size(437, 35);
            btnSetMacroSwitch.TabIndex = 4;
            btnSetMacroSwitch.Text = "Set Switch Key";
            btnSetMacroSwitch.UseVisualStyleBackColor = false;
            // 
            // lblMacroSwitchKeyPrefix
            // 
            lblMacroSwitchKeyPrefix.AutoSize = true;
            lblMacroSwitchKeyPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblMacroSwitchKeyPrefix.ForeColor = Color.White;
            lblMacroSwitchKeyPrefix.Location = new Point(0, 106);
            lblMacroSwitchKeyPrefix.Name = "lblMacroSwitchKeyPrefix";
            lblMacroSwitchKeyPrefix.Size = new Size(152, 18);
            lblMacroSwitchKeyPrefix.TabIndex = 6;
            lblMacroSwitchKeyPrefix.Text = "Switch Macro Mode:";
            // 
            // chkAlwaysJitter
            // 
            chkAlwaysJitter.AutoSize = true;
            chkAlwaysJitter.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            chkAlwaysJitter.ForeColor = Color.White;
            chkAlwaysJitter.Location = new Point(24, 459);
            chkAlwaysJitter.Margin = new Padding(3, 2, 3, 2);
            chkAlwaysJitter.Name = "chkAlwaysJitter";
            chkAlwaysJitter.Size = new Size(171, 22);
            chkAlwaysJitter.TabIndex = 3;
            chkAlwaysJitter.Text = "Always Jitter Mode";
            // 
            // chkAlwaysRecoilReduction
            // 
            chkAlwaysRecoilReduction.AutoSize = true;
            chkAlwaysRecoilReduction.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            chkAlwaysRecoilReduction.ForeColor = Color.White;
            chkAlwaysRecoilReduction.Location = new Point(24, 429);
            chkAlwaysRecoilReduction.Margin = new Padding(3, 2, 3, 2);
            chkAlwaysRecoilReduction.Name = "chkAlwaysRecoilReduction";
            chkAlwaysRecoilReduction.Size = new Size(251, 22);
            chkAlwaysRecoilReduction.TabIndex = 2;
            chkAlwaysRecoilReduction.Text = "Always Recoil Reduction Mode";
            // 
            // notifyIcon
            // 
            notifyIcon.ContextMenuStrip = trayContextMenu;
            notifyIcon.Text = "Notes&Tasks";
            notifyIcon.Visible = false;
            // 
            // trayContextMenu
            // 
            trayContextMenu.Items.AddRange(new ToolStripItem[] {
                showWindowMenuItem,
                new ToolStripSeparator(),
                exitMenuItem
            });
            trayContextMenu.Name = "trayContextMenu";
            trayContextMenu.ShowImageMargin = false;
            trayContextMenu.Size = new Size(151, 48);
            // 
            // showWindowMenuItem
            // 
            showWindowMenuItem.Name = "showWindowMenuItem";
            showWindowMenuItem.Size = new Size(150, 22);
            showWindowMenuItem.Text = "Open";
            showWindowMenuItem.Font = new Font(showWindowMenuItem.Font, FontStyle.Bold);
            // 
            // exitMenuItem
            // 
            exitMenuItem.Name = "exitMenuItem";
            exitMenuItem.Size = new Size(150, 22);
            exitMenuItem.Text = "Exit";
            // 
            // MacroForm
            // 
            AutoScaleDimensions = new SizeF(7F, 15F);
            AutoScaleMode = AutoScaleMode.Font;
            BackColor = Color.FromArgb(30, 30, 30);
            ClientSize = new Size(477, 676);
            Controls.Add(mainPanel);
            Margin = new Padding(3, 2, 3, 2);
            MinimumSize = new Size(493, 422);
            Name = "MacroForm";
            Text = "NotesAndTasks";
            mainPanel.ResumeLayout(false);
            mainPanel.PerformLayout();
            debugPanel.ResumeLayout(false);
            debugPanel.PerformLayout();
            strengthPanel1.ResumeLayout(false);
            strengthPanel1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarRecoilReduction).EndInit();
            strengthPanel2.ResumeLayout(false);
            strengthPanel2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarJitter).EndInit();
            settingsPanel.ResumeLayout(false);
            settingsPanel.PerformLayout();
            trayContextMenu.ResumeLayout(false);
            ResumeLayout(false);
        }

        #endregion
        private System.Windows.Forms.Panel mainPanel;
        private ModernButton btnSetKey;
        private System.Windows.Forms.Label lblCurrentKeyPrefix;
        private System.Windows.Forms.Label lblCurrentKeyValue;
        private ModernTrackBar trackBarJitter;
        private System.Windows.Forms.Label lblJitterStrengthPrefix;
        private System.Windows.Forms.Label lblJitterStrengthValue;
        private ModernTrackBar trackBarRecoilReduction;
        private System.Windows.Forms.Label lblRecoilReductionStrengthPrefix;
        private System.Windows.Forms.Label lblRecoilReductionStrengthValue;
        private ModernButton btnToggleDebug;
        private System.Windows.Forms.Panel debugPanel;
        private System.Windows.Forms.TextBox debugLabel;
        private System.Windows.Forms.NotifyIcon notifyIcon;
        private System.Windows.Forms.ContextMenuStrip trayContextMenu;
        private System.Windows.Forms.ToolStripMenuItem showWindowMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exitMenuItem;
        private System.Windows.Forms.Panel settingsPanel;
        private System.Windows.Forms.Panel strengthPanel1;
        private System.Windows.Forms.Panel strengthPanel2;
        private System.Windows.Forms.CheckBox chkMinimizeToTray;
        private ModernButton btnSetMacroSwitch;
        private System.Windows.Forms.Label lblMacroSwitchKeyPrefix;
        private System.Windows.Forms.Label lblMacroSwitchKeyValue;
        private System.Windows.Forms.CheckBox chkAlwaysJitter;
        private System.Windows.Forms.CheckBox chkAlwaysRecoilReduction;
        private System.Windows.Forms.Label lblRecoilReductionActive;
        private System.Windows.Forms.Label lblJitterActive;
    }
}
</file>

<file path="src/Configuration/ConfigurationManager.cs">
using System;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Windows.Forms;
using System.Linq;
using NotesAndTasks.Models;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Manages application settings including loading, saving, validation, and backup
    /// </summary>
    public class ConfigurationManager : IDisposable
    {
        // Application directory for storing configuration
        private static readonly string AppDirectory = AppDomain.CurrentDomain.BaseDirectory;
        
        // Settings file paths
        private static readonly string SettingsFilePath = Path.Combine(AppDirectory, "settings.json");
        private static readonly string SettingsBackupDirectoryPath = Path.Combine(AppDirectory, "Backups");
        private static readonly int MaxBackupCount = 5;
        private static readonly int MaxBackupAgeDays = 7; // Keep backups for 7 days maximum

        // Legacy settings path for compatibility
        private static readonly string LegacySettingsFilePath = Path.Combine(AppDirectory, "macro_config.json");

        private readonly ReaderWriterLockSlim _configLock = new ReaderWriterLockSlim();
        private readonly JsonSerializerOptions _jsonOptions;
        private AppSettings _currentSettings;
        private bool _disposed;

        // Singleton instance
        private static ConfigurationManager _instance;
        private static readonly object _instanceLock = new object();

        public event EventHandler<SettingsChangedEventArgs> SettingsChanged;
        public event EventHandler<SettingsValidationEventArgs> SettingsValidating;
        public event EventHandler<SettingsBackupEventArgs> SettingsBackupCompleted;

        /// <summary>
        /// Gets the singleton instance of the ConfigurationManager
        /// </summary>
        public static ConfigurationManager Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_instanceLock)
                    {
                        if (_instance == null)
                        {
                            try
                            {
                                _instance = new ConfigurationManager();
                            }
                            catch (Exception ex)
                            {
                                System.Diagnostics.Debug.WriteLine($"Failed to create ConfigurationManager instance: {ex.Message}");
                                throw;
                            }
                        }
                    }
                }
                return _instance;
            }
        }

        /// <summary>
        /// Gets the current application settings
        /// </summary>
        public AppSettings CurrentSettings
        {
            get
            {
                _configLock.EnterReadLock();
                try
                {
                    return _currentSettings;
                }
                finally
                {
                    _configLock.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Initializes a new instance of the ConfigurationManager class
        /// </summary>
        private ConfigurationManager()
        {
            try
            {
                _jsonOptions = new JsonSerializerOptions
                {
                    WriteIndented = true
                };

                // Register custom converters
                _jsonOptions.Converters.Add(new InputBindingConverter());

                InitializeDirectories();
                LoadSettings();

                // If settings are still null after LoadSettings, create defaults
                if (_currentSettings == null)
                {
                    _currentSettings = CreateDefaultSettings();
                    SaveSettings();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Failed to initialize ConfigurationManager: {ex.Message}");
                // Create default settings even if initialization fails
                _currentSettings = CreateDefaultSettings();
                try
                {
                    SaveSettings();
                }
                catch
                {
                    // Ignore save errors during initialization
                }
            }
        }

        /// <summary>
        /// Loads the settings from disk, creating default settings if none exist
        /// </summary>
        public void LoadSettings()
        {
            _configLock.EnterWriteLock();
            try
            {
                // Try to load settings from file
                if (File.Exists(SettingsFilePath))
                {
                    LoadSettingsFromPath(SettingsFilePath);
                }
                else
                {
                    // If no settings exist, create defaults
                    _currentSettings = CreateDefaultSettings();
                    SaveSettings(); // Save default settings
                }

                // Validate settings after loading
                if (_currentSettings == null || !ValidateSettings(_currentSettings))
                {
                    System.Diagnostics.Debug.WriteLine("Invalid settings detected after loading, creating defaults");
                    _currentSettings = CreateDefaultSettings();
                    SaveSettings();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Failed to load settings: {ex.Message}");
                // Create default settings if loading fails
                _currentSettings = CreateDefaultSettings();
                try
                {
                    SaveSettings();
                }
                catch
                {
                    // Ignore save errors during load failure recovery
                }
            }
            finally
            {
                _configLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Loads settings from the specified file path
        /// </summary>
        private void LoadSettingsFromPath(string path)
        {
            string jsonContent = File.ReadAllText(path);
            var loadedSettings = JsonSerializer.Deserialize<AppSettings>(jsonContent, _jsonOptions);

            // Always set default window position and size
            loadedSettings.UISettings.WindowPosition = new System.Drawing.Point(100, 100);
            loadedSettings.UISettings.WindowSize = new System.Drawing.Size(800, 600);

            var validationArgs = new SettingsValidationEventArgs(loadedSettings);
            SettingsValidating?.Invoke(this, validationArgs);

            if (validationArgs.IsValid && ValidateSettings(loadedSettings))
            {
                var previousSettings = _currentSettings;
                _currentSettings = loadedSettings;
                OnSettingsChanged("All", previousSettings, _currentSettings);
            }
            else
            {
                _currentSettings = CreateDefaultSettings();
                SaveSettings(); // Save default settings
            }
        }

        /// <summary>
        /// Saves the current settings to disk and creates a backup
        /// </summary>
        public void SaveSettings()
        {
            _configLock.EnterWriteLock();
            try
            {
                var validationArgs = new SettingsValidationEventArgs(_currentSettings);
                SettingsValidating?.Invoke(this, validationArgs);

                if (!validationArgs.IsValid || !ValidateSettings(_currentSettings))
                {
                    throw new Exception(validationArgs.Message ?? "Invalid settings state");
                }

                CreateSettingsBackup();

                string jsonContent = JsonSerializer.Serialize(_currentSettings, _jsonOptions);
                File.WriteAllText(SettingsFilePath, jsonContent);

                OnSettingsChanged("All", _currentSettings, _currentSettings);
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Failed to save settings: {ex.Message}");
            }
            finally
            {
                _configLock.ExitWriteLock();
            }
        }

        private void OnSettingsChanged(string section, AppSettings previousSettings, AppSettings newSettings)
        {
            var args = new SettingsChangedEventArgs(section, previousSettings, newSettings);
            SettingsChanged?.Invoke(this, args);
        }

        /// <summary>
        /// Creates a backup of the current settings file
        /// </summary>
        private void CreateSettingsBackup()
        {
            if (!File.Exists(SettingsFilePath)) return;

            try
            {
                string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string backupFile = Path.Combine(SettingsBackupDirectoryPath, $"settings_{timestamp}.json");

                File.Copy(SettingsFilePath, backupFile, true);
                CleanupOldBackups();

                var args = new SettingsBackupEventArgs(backupFile, true);
                SettingsBackupCompleted?.Invoke(this, args);
            }
            catch (Exception ex)
            {
                var args = new SettingsBackupEventArgs(null, false, ex.Message);
                SettingsBackupCompleted?.Invoke(this, args);
            }
        }

        /// <summary>
        /// Removes old backup files exceeding the maximum count or age
        /// </summary>
        private void CleanupOldBackups()
        {
            try
            {
                var backupFiles = Directory.GetFiles(SettingsBackupDirectoryPath, "settings_*.json")
                                         .Select(f => new FileInfo(f))
                                         .OrderByDescending(f => f.LastWriteTime)
                                         .ToList();

                // Remove files exceeding count limit
                var filesToDeleteCount = backupFiles.Skip(MaxBackupCount).ToList();
                
                // Remove files exceeding age limit
                var cutoffDate = DateTime.Now.AddDays(-MaxBackupAgeDays);
                var filesToDeleteAge = backupFiles.Where(f => f.LastWriteTime < cutoffDate).ToList();
                
                // Combine both lists and remove duplicates
                var filesToDelete = filesToDeleteCount.Union(filesToDeleteAge);

                foreach (var file in filesToDelete)
                {
                    try
                    {
                        file.Delete();
                        System.Diagnostics.Debug.WriteLine($"Deleted old backup: {file.Name}");
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine($"Failed to delete backup {file.Name}: {ex.Message}");
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Failed to cleanup backups: {ex.Message}");
            }
        }

        /// <summary>
        /// Creates necessary directories for settings storage
        /// </summary>
        private void InitializeDirectories()
        {
            try
            {
                // Create application directory if it doesn't exist
                if (!Directory.Exists(AppDirectory))
                {
                    Directory.CreateDirectory(AppDirectory);
                }

                // Create backup directory if it doesn't exist
                if (!Directory.Exists(SettingsBackupDirectoryPath))
                {
                    Directory.CreateDirectory(SettingsBackupDirectoryPath);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Failed to initialize directories: {ex.Message}");
                throw; // Rethrow to handle in constructor
            }
        }

        /// <summary>
        /// Creates a default settings with preset values
        /// </summary>
        private AppSettings CreateDefaultSettings()
        {
            var settings = new AppSettings();
            
            // Set default values
            settings.MacroSettings.JitterStrength = 3;
            settings.MacroSettings.RecoilReductionStrength = 1;
            settings.MacroSettings.AlwaysJitterMode = false;
            settings.MacroSettings.AlwaysRecoilReductionMode = false;
            settings.MacroSettings.JitterEnabled = false;
            settings.MacroSettings.RecoilReductionEnabled = false;
            settings.UISettings.MinimizeToTray = false;
            settings.UISettings.ShowStatusInTitle = true;
            settings.UISettings.ShowTrayNotifications = true;
            settings.UISettings.WindowPosition = new System.Drawing.Point(100, 100);
            settings.UISettings.WindowSize = new System.Drawing.Size(800, 600);
            
            // Default hotkeys
            settings.HotkeySettings.MacroKey = new InputBinding(Keys.Capital, InputType.Keyboard);
            settings.HotkeySettings.SwitchKey = new InputBinding(Keys.Q, InputType.Keyboard);
            
            return settings;
        }

        /// <summary>
        /// Validates the settings
        /// </summary>
        private bool ValidateSettings(AppSettings settings)
        {
            if (settings == null) return false;

            try
            {
                // Validate MacroSettings
                if (settings.MacroSettings.JitterStrength < 1 || settings.MacroSettings.JitterStrength > 20 ||
                    settings.MacroSettings.RecoilReductionStrength < 1 || settings.MacroSettings.RecoilReductionStrength > 20)
                {
                    return false;
                }

                // Validate HotkeySettings
                if (settings.HotkeySettings.MacroKey == null || settings.HotkeySettings.SwitchKey == null ||
                    settings.HotkeySettings.MacroKey.Key == Keys.None ||
                    settings.HotkeySettings.SwitchKey.Key == Keys.None)
                {
                    return false;
                }

                // Validate that keys are not the same
                if (settings.HotkeySettings.MacroKey.Key == settings.HotkeySettings.SwitchKey.Key &&
                    settings.HotkeySettings.MacroKey.Type == settings.HotkeySettings.SwitchKey.Type)
                {
                    return false;
                }

                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    _configLock.Dispose();
                }
                _disposed = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}
</file>

<file path="docs/architecture.md">
# Mouse Macro Application Architecture

## Introduction
This document provides an overview of the Mouse Macro Application architecture. The application is designed to create 
and manage mouse macros, featuring a modern dark-themed UI for keybind configuration and settings management.
IMPORTANT NOTE: For professional system integration the application presents itself as "Notes&Tasks" and "NotesAndTasks" 😊.

## System Overview

### Identity & Integration
- **Process Name**: NotesTasks.exe
- **Display Name**: Notes&Tasks
- **Window Title**: Notes&Tasks - [Status]
- **System Tray**: Notes&Tasks with corresponding icon
- **Design Rationale**:
  - Professional appearance in enterprise environments
  - Discrete system integration
  - Consistent branding across interfaces

### System Requirements
1. **Hardware**
   - Windows 10/11 compatible PC
   - DirectX compatible display
   - Mouse with standard buttons
   - Keyboard for hotkey support
   - Optional: Multi-button mouse, high refresh rate display, SSD

2. **Software**
   - Windows 10/11 (64-bit)
   - .NET 6.0 Runtime
   - Administrator privileges
   - DirectX 9.0c or later

## Usage Guide

### Installation
1. Download the latest release from the releases page
2. Extract the archive to your desired location
3. Run NotesTasks.exe (no installation required)

### First-Time Setup
1. Launch the application
2. Configure hotkeys:
   - Set Macro Toggle Key (default: Caps Lock)
   - Set Mode Switch Key (default: Q)
3. Adjust feature settings:
   - Jitter strength (1-20)
   - Recoil reduction strength (1-20)
4. Choose toggle modes:
   - Hold: Features active while key held
   - Toggle: Features toggle on/off with key press

### Basic Operation
1. **Starting the Macro**:
   - Press the Macro Toggle Key to enable/disable
   - Status shown in window title and system tray

2. **Switching Modes**:
   - Press Mode Switch Key to cycle between:
     - Jitter mode
     - Recoil reduction mode

3. **Quick Settings**:
   - Use trackbars for real-time strength adjustment
   - Toggle "Always On" for persistent effects
   - Minimize to tray for discrete operation

### Advanced Features
1. **Custom Patterns**:
   - Jitter patterns optimized for different scenarios
   - Recoil reduction with dynamic scaling
   - Combined mode synchronization

2. **Performance Optimization**:
   - Timer-based execution for consistent timing
   - Resource-efficient hook implementation
   - Automatic cleanup on exit

## Build Process

### Development Environment Setup
1. **Required Tools**:
   - Visual Studio 2022 or later
   - .NET 6.0 SDK
   - Git for version control

2. **Getting Started**:
   ```powershell
   git clone https://github.com/yourusername/MouseMacro.git
   cd MouseMacro
   dotnet restore
   ```

### Build Configuration
1. **Debug Build**:
   ```powershell
   dotnet build -c Debug
   ```
   - Includes debug symbols
   - Enhanced logging
   - Development features enabled

2. **Release Build**:
   ```powershell
   dotnet build -c Release
   ```
   - Optimized for performance
   - Minimal logging
   - Production-ready

### Testing
1. **Unit Tests**:
   ```powershell
   dotnet test
   ```
   - Validates core functionality
   - Tests hook implementation
   - Verifies configuration management

2. **Manual Testing**:
   - UI responsiveness
   - Feature functionality
   - Resource usage
   - Error handling

## Core Components

### 1. Input System
#### Low-Level Hooks
```csharp
// KeyboardHook.cs
public class KeyboardHook : IDisposable
{
    private IntPtr hookID = IntPtr.Zero;
    private readonly NativeMethods.LowLevelHookProc hookCallback;
    private bool disposed;

    public event EventHandler<KeyboardHookEventArgs> KeyDown;
    public event EventHandler<KeyboardHookEventArgs> KeyUp;

    public void Start()
    {
        if (hookID == IntPtr.Zero)
        {
            using var curProcess = Process.GetCurrentProcess();
            using var curModule = curProcess.MainModule;
            SetHook(NativeMethods.GetModuleHandle(curModule.ModuleName));
        }
    }
}

// MouseHook.cs
public class MouseHook : IDisposable
{
    private IntPtr hookID = IntPtr.Zero;
    private readonly NativeMethods.LowLevelHookProc hookProc;
    private bool disposed;

    public event EventHandler<MouseHookEventArgs> MouseDown;
    public event EventHandler<MouseHookEventArgs> MouseUp;

    public void Start()
    {
        if (hookID == IntPtr.Zero)
        {
            using var curProcess = Process.GetCurrentProcess();
            using var curModule = curProcess.MainModule;
            SetHook(NativeMethods.GetModuleHandle(curModule.ModuleName));
        }
    }
}
```

#### Input Simulation
```csharp
// InputSimulator.cs
public class InputSimulator
{
    public void MoveMouse(int dx, int dy)
    {
        var input = new INPUT
        {
            type = INPUT_MOUSE,
            u = new InputUnion
            {
                mi = new MOUSEINPUT
                {
                    dx = dx,
                    dy = dy,
                    mouseData = 0,
                    dwFlags = MOUSEEVENTF_MOVE,
                    time = 0,
                    dwExtraInfo = IntPtr.Zero
                }
            }
        };

        SendInput(1, new[] { input }, Marshal.SizeOf(typeof(INPUT)));
    }
}
```

### 2. Macro Engine

#### Base Effect Manager
```csharp
// MacroEffectBase.cs
public abstract class MacroEffectBase : IDisposable
{
    protected readonly InputSimulator InputSimulator;
    protected bool Disposed = false;
    protected int EffectStrength;
    protected bool IsEffectActive = false;
    protected System.Threading.Timer Timer;

    public event EventHandler<bool> StateChanged;
    public bool IsActive => IsEffectActive;
    public int Strength { get; protected set; }

    protected abstract void OnTimerTick(object state);
}
```

#### Recoil Reduction System
```csharp
// RecoilReductionManager.cs
public class RecoilReductionManager : MacroEffectBase
{
    public RecoilReductionManager(InputSimulator inputSimulator) : base(inputSimulator, 1)
    {
    }

    protected override void OnTimerTick(object state)
    {
        if (!IsActive) return;
        try
        {
            InputSimulator.SimulateRecoilReduction(Strength);
        }
        catch (Exception)
        {
            Stop();
        }
    }
}
```

#### Jitter System
```csharp
// JitterManager.cs
public class JitterManager : MacroEffectBase
{
    private int currentStep = 0;
    private readonly (int dx, int dy)[] jitterPattern;

    public JitterManager(InputSimulator inputSimulator) : base(inputSimulator, 3)
    {
    }

    protected override void OnTimerTick(object state)
    {
        if (!IsActive) return;
        try
        {
            var pattern = jitterPattern[currentStep];
            InputSimulator.SimulateJitterMovement(pattern, Strength);
            currentStep = (currentStep + 1) % jitterPattern.Length;
        }
        catch (Exception)
        {
            Stop();
        }
    }
}
```

### 3. Configuration System

#### Configuration Models
```csharp
// AppSettings.cs
public class AppSettings : INotifyPropertyChanged
{
    public MacroSettings MacroSettings { get; }
    public UISettings UISettings { get; }
    public HotkeySettings HotkeySettings { get; }
}

// MacroSettings.cs
public class MacroSettings : INotifyPropertyChanged
{
    [Range(1, 20)]
    public int JitterStrength { get; set; } = 3;
    [Range(1, 20)]
    public int RecoilReductionStrength { get; set; } = 1;
    public bool JitterEnabled { get; set; }
    public bool RecoilReductionEnabled { get; set; }
    public bool AlwaysJitterMode { get; set; }
    public bool AlwaysRecoilReductionMode { get; set; }
}

// UISettings.cs
public class UISettings : INotifyPropertyChanged
{
    public bool MinimizeToTray { get; set; }
    public bool ShowDebugPanel { get; set; }
    public bool ShowStatusInTitle { get; set; }
    public Point WindowPosition { get; set; }
    public Size WindowSize { get; set; }
}

// HotkeySettings.cs
public class HotkeySettings : INotifyPropertyChanged
{
    public InputBinding MacroKey { get; set; }
    public InputBinding SwitchKey { get; set; }
}
```

#### Configuration Management
```csharp
// ConfigurationManager.cs
public class ConfigurationManager : IDisposable
{
    private static readonly string AppDirectory = Path.GetDirectoryName(Application.ExecutablePath);
    private static readonly string SettingsFilePath = Path.Combine(AppDirectory, "settings.json");
    private static readonly string SettingsBackupDirectoryPath = Path.Combine(AppDirectory, "Backups");
    private static readonly int MaxBackupCount = 5;

    private readonly ReaderWriterLockSlim _configLock = new ReaderWriterLockSlim();
    private readonly JsonSerializerOptions _jsonOptions;
    private AppSettings _currentSettings;

    public event EventHandler<SettingsChangedEventArgs> SettingsChanged;
    public event EventHandler<SettingsValidationEventArgs> SettingsValidating;
    public event EventHandler<SettingsBackupEventArgs> SettingsBackupCompleted;

    public void LoadSettings()
    {
        _configLock.EnterWriteLock();
        try
        {
            if (File.Exists(SettingsFilePath))
            {
                LoadSettingsFromPath(SettingsFilePath);
            }
            else
            {
                _currentSettings = CreateDefaultSettings();
                SaveSettings();
            }
        }
        finally
        {
            _configLock.ExitWriteLock();
        }
    }
}
```

#### Configuration Events
```csharp
// ConfigurationEvents.cs
public class ConfigurationChangedEventArgs : EventArgs
{
    public string Section { get; }
    public AppSettings PreviousConfig { get; }
    public AppSettings NewConfig { get; }
}

public class ConfigurationValidationEventArgs : EventArgs
{
    public bool IsValid { get; set; }
    public string Message { get; set; }
    public AppSettings Configuration { get; }
}

public class ConfigurationBackupEventArgs : EventArgs
{
    public string BackupPath { get; }
    public bool Success { get; }
    public string ErrorMessage { get; }
}
```

### 4. UI System

#### Main Form
```csharp
// MacroForm.cs
public partial class MacroForm : Form
{
    private readonly KeyboardHook keyboardHook;
    private readonly MouseHook mouseHook;
    private readonly MacroManager macroManager;
    private readonly HotkeyManager hotkeyManager;
    private readonly UIManager uiManager;
    private readonly ToolTip toolTip;

    public MacroForm()
    {
        InitializeComponent();
        
        // Initialize managers and hooks
        macroManager = new MacroManager();
        hotkeyManager = new HotkeyManager(macroManager);
        keyboardHook = new KeyboardHook();
        mouseHook = new MouseHook();
        
        // Initialize UI Manager
        uiManager = new UIManager(
            this, macroManager, hotkeyManager,
            debugLabel, lblJitterActive, lblRecoilReductionActive,
            lblCurrentKeyValue, lblMacroSwitchKeyValue,
            lblJitterStrengthValue, lblRecoilReductionStrengthValue,
            notifyIcon, toolTip
        );
    }
}
```

#### UI Manager
```csharp
// UIManager.cs
public class UIManager : IDisposable
{
    private readonly Form form;
    private readonly MacroManager macroManager;
    private readonly HotkeyManager hotkeyManager;
    private readonly TextBox debugLabel;
    private readonly Label lblJitterActive;
    private readonly Label lblRecoilReductionActive;
    private readonly NotifyIcon notifyIcon;
    private readonly ToolTip toolTip;

    public void UpdateTitle()
    {
        string jitterMode = macroManager.IsAlwaysJitterMode ? "Always Jitter" :
            (macroManager.IsJitterEnabled ? "Jitter" : "Jitter (OFF)");

        string recoilMode = macroManager.IsAlwaysRecoilReductionMode ? "Always Recoil Reduction" :
            (macroManager.IsJitterEnabled ? "Recoil Reduction (OFF)" : "Recoil Reduction");

        form.Text = $"Notes&Tasks [{(macroManager.IsEnabled ? "ON" : "OFF")}] - {jitterMode} / {recoilMode} Mode";
    }
}
```

### 5. Event System

#### Event Categories
1. **UI Events**
   - Form state changes
   - Control value updates
   - Window management events

2. **Configuration Events**
   - Settings changes
   - Validation events
   - Backup completion events

3. **Macro Events**
   - State changes
   - Mode switches
   - Effect start/stop events

### 6. Performance Optimization

#### Resource Management
```csharp
protected virtual void Dispose(bool disposing)
{
    if (!disposed)
    {
        if (disposing)
        {
            Stop();
            Timer?.Dispose();
        }
        disposed = true;
    }
}
```

## Build Configurations

### Debug Build
- Location: `bin/Debug/net6.0-windows/`
- Debug symbols enabled
- Logging enabled
- Development features active

### Release Build
- Location: `bin/Release/net6.0-windows/`
- Optimized performance
- Production ready
- Minimal logging

## Project Structure

### Directory Organization
```
MouseMacro/
├── assets/                  # Application resources
│   ├── logo.ico            # Application icon
├── bin/                    # Compiled binaries
│   ├── Debug/             # Debug build output
│   └── Release/           # Release build output
├── docs/                   # Documentation
├── obj/                    # Intermediate build files
│   ├── Debug/             # Debug build intermediates
│   │   └── net6.0-windows/
│   │       ├── ref/       # Assembly reference files
│   │       ├── refint/    # Reference interface files
│   │       └── *.cache    # Build cache files
│   └── Release/           # Release build intermediates
├── src/
│   ├── UI/                    # User interface components
│   │   ├── Controls/         # Custom UI controls
│   │   │   ├── ModernButton.cs
│   │   │   └── ModernTrackBar.cs
│   │   ├── MacroForm.cs
│   │   ├── MacroForm.Designer.cs
│   │   ├── MacroForm.resx
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   │   └── UIManager.cs      # UI manager
│   ├── Configuration.resx
│   ├── Configuration/        # Configuration management
│   │   ├── ConfigurationEvents.cs
│   │   ├── ConfigurationManager.cs
│   │   ├── EventHandlerExtensions.cs
│   │   ├── EventHandlerManager.cs
│   │   ├── Settings.cs
│   │   ├── SettingsManager.cs
│   │   ├── SettingsValidation.cs
│   │   └── Validation.cs
│   ├── Hooks/               # System hooks
│   │   ├── KeyboardHook.cs
│   │   ├── MouseHook.cs
│   │   ├── NativeMethods.cs
│   │   └── WinMessages.cs
│   ├── Models/              # Data models
│   │   ├── AppSettings.cs
│   │   ├── MacroSettings.cs
│   │   ├── UISettings.cs
│   │   └── HotkeySettings.cs
│   ├── Utilities/           # Core functionality
│   │   ├── InputSimulator.cs
│   │   ├── JitterManager.cs
│   │   ├── MacroManager.cs
│   │   └── RecoilReductionManager.cs
│   └── Program.cs
├── tests/                   # Unit tests
├── docs/                    # Documentation
├── app.manifest            # Application manifest
├── MouseMacro.csproj       # Project configuration
└── README.md               # Project documentation
```
</file>

<file path="docs/implementation_plan.md">
# MouseMacro Improvement Implementation Plan

## Overview
This plan details the specific steps to transform the MouseMacro project into a modular, professional, and maintainable application while preserving all existing functionality. The implementation follows the 12-step approach outlined in the improvement.md document.

## Progress Tracking

| Phase | Status |
|-------|--------|
| Phase 1: Preparation and Structure | ✅ Complete |
| Phase 2: Code Modularization | ✅ Complete |
| Phase 3: Architecture Improvements | 🔄 In Progress (0%) |
| Phase 4: Documentation and Testing | Not Started |
| Phase 5: Validation and Finalization | Not Started |

## Implementation Steps

### Phase 1: Preparation and Structure

#### Step 1: Backup the Current Project
- [x] Create a full backup of the project directory
- [x] Set up version control (Git) if not already in place
- [x] Create an initial commit with the current state

```powershell
# PowerShell script to create backup
$sourceDir = "E:\CODING\Projects\CODE\Macro"
$backupDir = "E:\CODING\Projects\CODE\Macro_Backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
Copy-Item -Path $sourceDir -Destination $backupDir -Recurse
```

#### Step 2: Organize Directory Structure
- [x] Create the following directory structure:
  ```
  MouseMacro/
  ├── src/
  │   ├── UI/
  │   ├── Configuration/
  │   ├── Hooks/
  │   ├── Utilities/
  │   ├── Models/
  ├── tests/
  ├── docs/
  ```
- [x] Move existing files to their appropriate locations
- [x] Update namespace declarations in all files
- [x] Update project file (MouseMacro.csproj) to reflect new structure

### Phase 2: Code Modularization

#### Step 3: Extract Hook Logic
- [x] Create KeyboardHook.cs in src/Hooks/
- [x] Create MouseHook.cs in src/Hooks/
- [x] Move hook-related code from MacroForm.cs to these classes
- [x] Implement IDisposable pattern for proper resource cleanup
- [x] Add public methods for controlling hooks (Start, Stop)
- [x] Update MacroForm.cs to use the new hook classes

#### Step 4: Create Manager Classes
- [x] Create InputSimulator.cs in src/Utilities/
- [x] Create JitterManager.cs in src/Utilities/
- [x] Create RecoilReductionManager.cs in src/Utilities/
- [x] Create MacroManager.cs in src/Utilities/
- [x] Move relevant logic from MacroForm.cs to these classes
- [x] Update MacroForm.cs to use the new manager classes

#### Step 5: Refactor MacroForm.cs
- [x] Inject manager classes into MacroForm
- [x] Remove direct event handler assignments from designer file
- [x] Remove remaining business logic from form class
- [x] Update event handlers to call methods on manager classes
- [x] Keep UI-specific code in MacroForm.cs
- [x] Implement event handlers for manager events

### Phase 3: Architecture Improvements

#### Step 6: Improve Configuration Management
- [x] Create configuration models in src/Models/
- [x] Enhance ConfigurationManager.cs in src/Configuration/
<!-- - [ ] Integrate Microsoft.Extensions.Configuration (Ignore No longer needed) -->
- [x] Implement validation for configuration values
- [x] Add proper exception handling
- [x] Store configuration in standard location (same place as exe)
- [x] Add backup functionality for configuration

#### Step 7: Separate UI and Business Logic
- [ ] Create IMacroView interface in src/UI/
- [ ] Implement interface in MacroForm
- [ ] Create MacroPresenter in src/UI/Presenters/
- [ ] Move business logic from MacroForm to MacroPresenter
- [ ] Update MacroForm to interact with presenter

#### Step 8: Enhance Code Quality
- [ ] Rename variables and methods for clarity
- [ ] Remove unused code and variables
- [ ] Apply consistent formatting
- [ ] Consolidate duplicated code
- [ ] Use readonly and const appropriately
- [ ] Add exception handling
- [ ] Integrate Serilog for logging

### Phase 4: Documentation and Testing

#### Step 9: Add Documentation
- [ ] Add XML comments to all public classes, methods, and properties
- [ ] Update README.md with project overview, setup instructions, and usage guidelines
- [ ] Create architecture.md in docs/ with component descriptions and design decisions
- [ ] Add inline comments for complex logic

#### Step 10: Implement Unit Tests
- [ ] Create test project using xUnit
- [ ] Write tests for hook initialization and callbacks
- [ ] Write tests for jitter and recoil reduction logic
- [ ] Write tests for configuration loading/saving
- [ ] Write tests for macro state management
- [ ] Mock dependencies using Moq
- [ ] Aim for high test coverage of critical components

### Phase 5: Validation and Finalization

#### Step 11: Test the Application
- [ ] Run the application and test all features
- [ ] Verify UI updates
- [ ] Ensure hooks work correctly
- [ ] Confirm configuration persists
- [ ] Test error handling
- [ ] Validate performance

#### Step 12: Review and Iterate
- [ ] Review code for adherence to goals
- [ ] Address issues found during testing
- [ ] Refine documentation
- [ ] Optimize performance if needed
- [ ] Commit final changes to version control

## Detailed Todo Items

### 1. Create backup of the current project ✅
- **Description**: Create a full backup of the project directory to preserve the original code. This can be done by copying the entire project folder to a safe location or by setting up a Git repository and making an initial commit.
- **Complexity**: 1/10
- **Status**: Complete

### 2. Create new directory structure ✅
- **Description**: Create the new directory structure as outlined in the improvement plan. This includes creating src/, tests/, and docs/ directories, with src/ further divided into UI/, Configuration/, Hooks/, Utilities/, and Models/ subdirectories.
- **Complexity**: 2/10
- **Status**: Complete

### 3. Move existing files to new directory structure ✅
- **Description**: Move existing files to their appropriate locations in the new directory structure. Update namespace declarations in all files to reflect the new structure. Update the project file (MouseMacro.csproj) to reflect the new file paths.
- **Complexity**: 3/10
- **Status**: Complete

### 4. Create KeyboardHook class ✅
- **Description**: Create a KeyboardHook class in src/Hooks/ directory. Extract keyboard hook-related functionality from MacroForm.cs, including hook initialization, callback methods, and disposal logic. Implement IDisposable pattern for proper resource cleanup.
- **Complexity**: 5/10
- **Status**: Complete

### 5. Create MouseHook class ✅
- **Description**: Create a MouseHook class in src/Hooks/ directory. Extract mouse hook-related functionality from MacroForm.cs, including hook initialization, callback methods, and disposal logic. Implement IDisposable pattern for proper resource cleanup.
- **Complexity**: 5/10
- **Status**: Complete

### 6. Create InputSimulator class ✅
- **Description**: Create an InputSimulator class in src/Utilities/ directory to handle mouse movement simulation. Extract SendInput implementation from MacroForm.cs and add methods for mouse movement simulation.
- **Complexity**: 4/10
- **Status**: Complete

### 7. Create JitterManager class ✅
- **Description**: Create a JitterManager class in src/Utilities/ directory to handle jitter pattern generation and application. Extract jitter-related functionality from MacroForm.cs, including pattern definition, timer handling, and strength scaling.
- **Complexity**: 6/10
- **Status**: Complete

### 8. Create RecoilReductionManager class ✅
- **Description**: Create a RecoilReductionManager class in src/Utilities/ directory to handle recoil reduction functionality. Extract recoil reduction-related code from MacroForm.cs, including timer handling, strength scaling, and movement calculation.
- **Complexity**: 6/10
- **Status**: Complete

### 9. Create MacroManager class ✅
- **Description**: Create a MacroManager class in src/Utilities/ directory to coordinate between hook and feature managers. This class will handle macro state (enabled/disabled), mode switching, and delegate tasks to the appropriate managers.
- **Complexity**: 7/10
- **Status**: Complete

### 10. Create configuration models
- **Description**: Create configuration model classes in src/Models/ directory to represent the application's configuration. These models will be used by the ConfigurationManager to load and save settings.
- **Complexity**: 4/10
- **Status**: Not Started

### 11. Enhance ConfigurationManager class
- **Description**: Enhance the ConfigurationManager class in src/Configuration/ directory to use Microsoft.Extensions.Configuration for robust configuration handling. Implement validation, error handling, and store the configuration file in a standard location.
- **Complexity**: 8/10
- **Status**: Not Started

### 12. Create IMacroView interface
- **Description**: Create an IMacroView interface in src/UI/ directory to define the contract between the view (MacroForm) and the presenter (MacroPresenter). This interface will include methods for updating UI elements and properties for getting user input.
- **Complexity**: 3/10
- **Status**: Not Started

### 13. Create MacroPresenter class
- **Description**: Create a MacroPresenter class in src/UI/Presenters/ directory to handle business logic. This class will implement the MVP pattern, interacting with the view via the IMacroView interface and delegating tasks to the MacroManager.
- **Complexity**: 7/10
- **Status**: Not Started

### 14. Update MacroForm to implement IMacroView ✅
- **Description**: Update the MacroForm class to implement the IMacroView interface. Remove business logic from the form and delegate tasks to the MacroPresenter. Update event handlers to call methods on the presenter. Remove direct event handler assignments from designer file and handle them programmatically.
- **Complexity**: 8/10
- **Status**: Complete

### 15. Create unit test project
- **Description**: Create a unit test project in the tests/ directory using xUnit. Set up the project to test the core components of the application, including hook initialization, jitter and recoil reduction logic, configuration loading/saving, and macro state management.
- **Complexity**: 6/10
- **Status**: Not Started

### 16. Update project file for new structure ✅
- **Description**: Update the MouseMacro.csproj file to reflect the new directory structure and add any required package references. This includes references to Microsoft.Extensions.Configuration, Serilog, and any other packages needed for the implementation.
- **Complexity**: 3/10
- **Status**: Complete

### 17. Create test project file
- **Description**: Create a project file for the unit test project in the tests/ directory. Add references to xUnit, Moq, and the main project.
- **Complexity**: 2/10
- **Status**: Not Started

### 18. Update Program.cs for new structure ✅
- **Description**: Update the Program.cs file to work with the new structure. Initialize Serilog for logging and set up the application to use the new MacroForm with the MVP pattern.
- **Complexity**: 3/10
- **Status**: Complete

### 19. Create validation classes ✅
- **Description**: Create validation classes in src/Configuration/ directory to validate configuration values. Implement methods for validating strength values, hotkeys, and other settings.
- **Complexity**: 4/10
- **Status**: Complete

### 20. Update README.md with new structure
- **Description**: Update the README.md file to reflect the new project structure and implementation details. Include information about the modular architecture, MVP pattern, and other improvements.
- **Complexity**: 3/10
- **Status**: Not Started

## Timeline and Dependencies
- Phase 1 (Steps 1-2): 1 day
- Phase 2 (Steps 3-5): 3 days
- Phase 3 (Steps 6-8): 3 days
- Phase 4 (Steps 9-10): 2 days
- Phase 5 (Steps 11-12): 1 day

Total estimated time: 10 days

## Success Criteria
- All existing functionality is preserved
- Code is modular with clear separation of concerns
- Directory structure is logical and organized
- Configuration management is robust
- UI and business logic are properly separated
- Code quality is improved
- Documentation is comprehensive
- Unit tests validate critical functionality
- Application performs as expected
</file>

<file path="README.md">
# Notes & Tasks (Mouse Macro)

A professional Windows Forms application for advanced mouse input management, featuring recoil compensation and jitter pattern generation. IMPORTANT NOTE: For professional system integration the application presents itself as "Notes&Tasks" and "NotesAndTasks" 😊.

## Features

- **Mouse Input Management**
  - Jitter Effect: Jitter mouse movement patterns strength (1-20)
  - Recoil Reduction: Vertical mouse movement compensation strength (1-20)
  - Multiple Operation Modes: Toggle or Always-On for each effect
  - Adjustable Effect Strengths: Fine-tune the intensity of each effect

- **Modern UI**
  - Dark Theme: Easy on the eyes during extended use
  - System Tray Integration: Minimize to tray for discrete operation
  - Real-time Status Display: Active effects and modes shown in window title
  - Customizable Window Position and Size: Remembers your preferences

#### Macro Engine
- **Recoil Reduction System**
  - Three-tier strength scaling:
    - Tier 1 (1-6): Linear scaling with logarithmic base
    - Tier 2 (7-16): Enhanced scaling with 1.2x multiplier
    - Tier 3 (17-20): Exponential scaling with dynamic boost
  - Real-time strength adjustment (1-20)
  - Optimized movement patterns
  - Default strength: 1
  - Advanced vertical compensation
  - Dynamic pattern adjustment

- **Jitter System**
  - Complex 24-point movement pattern
  - Dynamic strength scaling (1-20)
  - Pattern cycling with smooth transitions
  - Default strength: 3
  - Optimized for performance
  - Pattern customization options

- **Mode Switching**
  - Intelligent mode toggling
  - Support for keyboard and mouse buttons (Mouse3-5)
  - Always mode options with validation
  - Real-time mode state tracking
  - Visual state indicators

#### Configuration System
- **Configuration Models**
  - `AppSettings`: Root configuration class containing all settings
  - `MacroSettings`: Jitter and recoil reduction settings
  - `UISettings`: Window and interface preferences
  - `HotkeySettings`: Key bindings and hotkey configuration
  - Legacy configuration files for backward compatibility
  - settings save on loaded from and to JSON
  
- **Configuration Manager**
  - Thread-safe operations with ReaderWriterLockSlim
  - Standard location in %AppData%/NotesAndTasks
  - Automatic backups with versioning
  - Real-time validation with error recovery
  - Event notifications for changes, validation, and backups
  - Support for both new models and legacy configuration
  
- **Validation System**
  - Data annotations for property validation
  - Cross-property validation
  - Pre-save validation checks
  - Error reporting with context
  - Recovery mechanisms
  - Backward compatibility validation

- **Event System**
  - Configuration change tracking
  - Validation event handling
  - Backup completion notifications
  - Error event propagation
  - State change notifications
  - Legacy event support

#### UI System
- Modern dark theme interface
- Real-time status indicators
- Professional window management
- System tray integration
- DPI-aware scaling
- Single instance enforcement
- Clean system integration

#### Event System
- Centralized event management
- Type-safe event registration
- Automatic resource cleanup
- Comprehensive error handling:
  - Exception tracking
  - State recovery
  - Debug logging
- Categories:
  - UI events
  - Configuration events
  - Macro events
  - System events

## Requirements

### Hardware
- Windows 10/11 compatible PC
- DirectX compatible display
- Mouse with standard buttons
- Keyboard for hotkey support

### Software
- Windows 10/11 (64-bit)
- .NET 6.0 Runtime
- Administrator privileges (required for input simulation)
- DirectX 9.0c or later
- Standard mouse and keyboard

## Installation

### Download Latest Release
1. Download the latest `Notes&Tasks.exe` from the [releases page](https://github.com/yourusername/MouseMacro/releases)
2. Extract the archive to your desired location
3. Run `Notes&Tasks.exe` with administrator privileges

## Usage Guide

### First-Time Setup
1. Launch the application
2. Configure hotkeys:
   - Set Macro Toggle Key (default: Caps Lock)
   - Set Mode Switch Key (default: Q)
3. Adjust feature settings:
   - Jitter strength (1-20)
   - Recoil reduction strength (1-20)
4. Choose toggle modes:
   - Hold: Features active while key held
   - Toggle: Features toggle on/off with key press

### Basic Operation
1. **Starting the Macro**
   - Press the Macro Toggle Key to enable/disable
   - Status shown in window title and system tray

2. **Switching Modes**
   - Press Mode Switch Key to cycle between:
     - Jitter mode
     - Recoil reduction mode
     - Combined mode

3. **Quick Settings**
   - Use trackbars for real-time strength adjustment
   - Toggle "Always On" for persistent effects
   - Minimize to tray for discrete operation

### Usage Scenarios

#### 1. Dynamic Mode Switching
```
1. Press Toggle Key → Macro ON
2. Press Q to switch between modes
3. Hold LMB + RMB → Current mode activates
4. Release buttons → Effect stops
5. Press Q again → Switch to other mode
```

#### 2. Always Jitter Mode
```
1. Enable "Always Jitter Mode" checkbox
2. Press Toggle Key → Macro ON
3. Hold LMB + RMB → Jitter pattern active
4. Release buttons → Jitter stops
5. Q key has no effect (locked to jitter)
```

#### 3. Always Recoil Reduction Mode
```
1. Enable "Always Recoil Reduction Mode"
2. Press Toggle Key → Macro ON
3. Hold LMB + RMB → Recoil reduction active
4. Release buttons → Effect stops
5. Q key has no effect (locked to recoil reduction)
```

#### 4. Strength Optimization
```
1. Start with default strengths:
   - Recoil Reduction: 1
   - Jitter: 3
2. Test each mode
3. Adjust strength per mode as needed
4. Settings persist between mode switches
```

### Important Notes
- Effects ONLY activate when BOTH buttons are held
- Mode switch key (Q) works in real-time
- Always mode prevents accidental switching
- Each mode maintains its own strength setting
- Visual indicators show current active mode
- Window title reflects current state

### Advanced Features
1. **Custom Patterns**
   - Jitter patterns optimized for different scenarios
   - Recoil reduction with dynamic scaling
   - Combined mode synchronization

2. **Performance Optimization**
   - Timer-based execution for consistent timing
   - Resource-efficient hook implementation
   - Automatic cleanup on exit

## Development

### Environment Setup
1. **Required Tools**
   - Visual Studio 2022 or later
   - .NET 6.0 SDK
   - Git for version control

2. **Getting Started**
   ```powershell
   git clone https://github.com/yourusername/MouseMacro.git
   cd MouseMacro
   ```

### Build From Source Options

#### Option 1: Using build.bat
1. Double-click `build.bat` in the project root
2. Script handles:
   - Admin rights elevation
   - NuGet package restoration
   - Debug and Release builds
   - Output directory creation

#### Option 2: Using Visual Studio
1. Open `MouseMacro.sln`
2. Select build configuration (Debug/Release)
3. Build solution (F6)

#### Option 3: Using Command Line
```powershell
# Debug build
dotnet build -c Debug

# Release build
dotnet build -c Release
```

### Output Locations
- Release: `bin/Release/net6.0-windows/Notes&Tasks.exe`
- Debug: `bin/Debug/net6.0-windows/Notes&Tasks.exe`

### Configuration Files
- Settings: `%AppData%/NotesAndTasks/config.json`
- Backups: `%AppData%/NotesAndTasks/Backups/`

### Testing
1. **Unit Tests**
   ```powershell
   dotnet test
   ```
   - Validates core functionality
   - Tests hook implementation
   - Verifies configuration management

2. **Manual Testing**
   - UI responsiveness
   - Feature functionality
   - Resource usage
   - Error handling

### Project Structure
```
MouseMacro/
├── assets/                  # Application resources
│   ├── logo.ico            # Application icon
├── bin/                    # Compiled binaries
│   ├── Debug/             # Debug build output
│   └── Release/           # Release build output
├── docs/                   # Documentation
├── obj/                    # Intermediate build files
│   ├── Debug/             # Debug build intermediates
│   │   └── net6.0-windows/
│   │       ├── ref/       # Assembly reference files
│   │       ├── refint/    # Reference interface files
│   │       └── *.cache    # Build cache files
│   └── Release/           # Release build intermediates
├── src/
│   ├── UI/                    # User interface components
│   │   ├── Controls/         # Custom UI controls
│   │   │   ├── ModernButton.cs
│   │   │   └── ModernTrackBar.cs
│   │   ├── MacroForm.cs
│   │   ├── MacroForm.Designer.cs
│   │   ├── MacroForm.resx
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   │   └── UIManager.cs      # UI manager
│   ├── Configuration.resx
│   ├── Configuration/        # Configuration management
│   │   ├── ConfigurationEvents.cs
│   │   ├── ConfigurationManager.cs
│   │   ├── EventHandlerExtensions.cs
│   │   ├── EventHandlerManager.cs
│   │   ├── Settings.cs
│   │   ├── SettingsManager.cs
│   │   ├── SettingsValidation.cs
│   │   └── Validation.cs
│   ├── Hooks/               # System hooks
│   │   ├── KeyboardHook.cs
│   │   ├── MouseHook.cs
│   │   ├── NativeMethods.cs
│   │   └── WinMessages.cs
│   ├── Models/              # Data models
│   │   ├── AppSettings.cs
│   │   ├── MacroSettings.cs
│   │   ├── UISettings.cs
│   │   └── HotkeySettings.cs
│   ├── Utilities/           # Core functionality
│   │   ├── InputSimulator.cs
│   │   ├── JitterManager.cs
│   │   ├── MacroManager.cs
│   │   └── RecoilReductionManager.cs
│   └── Program.cs
├── tests/                   # Unit tests
├── docs/                    # Documentation
├── app.manifest            # Application manifest
├── MouseMacro.csproj       # Project configuration
└── README.md               # Project documentation
```

## Troubleshooting

### Common Issues

1. **Application Won't Start**
   - Run as administrator
   - Check for existing instance
   - Verify .NET Runtime installation
   - Check Task Manager for hung instances
   - Verify file permissions

2. **Performance Issues**
   - Use Release build
   - Check system resources
   - Adjust timer intervals
   - Monitor debug output
   - Close resource-intensive applications

3. **Configuration Problems**
   - Delete corrupted config file
   - Check file permissions
   - Verify JSON format
   - Reset to defaults
   - Check backup configurations

### Error Handling
- **Validation Errors**
  - Automatic recovery
  - Default value fallback
  - User notification
  - State preservation

- **Runtime Errors**
  - Exception handling
  - Resource cleanup
  - State recovery
  - Debug logging
  - User feedback

## Contributing
1. Fork the repository
2. Create feature branch
3. Commit changes
4. Submit pull request

## License

This project is licensed under the [MIT License](LICENSE) - see the [LICENSE](LICENSE) file for details.

The MIT License is a permissive license that allows you to:
- ✅ Use the software commercially
- ✅ Modify the software
- ✅ Distribute the software
- ✅ Use the software privately
- ✅ Sublicense the software

Under the following conditions:
- ℹ️ License and copyright notice must be included
- ⚠️ Software is provided "as is", without warranty

## Acknowledgments

- Windows Forms (.NET 6.0)
- Windows API (user32.dll)
- .NET Community
</file>

<file path="src/UI/MacroForm.cs">
using System;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.ComponentModel;
using NotesAndTasks.Configuration;
using NotesAndTasks.Hooks;
using NotesAndTasks.Utilities;
using NotesAndTasks.UI;
using NotesAndTasks.Models;

namespace NotesAndTasks
{
    /// <summary>
    /// Main form for the Notes&Tasks application that provides mouse input management functionality.
    /// This form handles both jitter and recoil reduction features with configurable hotkeys and settings.
    /// </summary>
    /// <remarks>
    /// The form implements two main features:
    /// 1. Jitter - Applies a complex movement pattern to the mouse cursor
    /// 2. Recoil Reduction - Provides vertical compensation with configurable strength
    /// 
    /// Both features are activated when left and right mouse buttons are held simultaneously.
    /// The application can be minimized to the system tray and supports various hotkeys for control.
    /// </remarks>
    public partial class MacroForm : Form
    {
        #region Fields
        private readonly KeyboardHook keyboardHook;
        private readonly MouseHook mouseHook;
        private readonly MacroManager macroManager;
        private readonly HotkeyManager hotkeyManager;
        private readonly UIManager uiManager;
        private readonly ToolTip toolTip;
        private bool isExiting = false;
        private readonly EventHandler alwaysJitterCheckedChanged;
        private readonly EventHandler alwaysRecoilReductionCheckedChanged;
        #endregion

        /// <summary>
        /// Initializes a new instance of the MacroForm class.
        /// Sets up all necessary components, hooks, and event handlers.
        /// </summary>
        public MacroForm()
        {
            try
            {
                // Initialize managers and hooks
                macroManager = new MacroManager();
                hotkeyManager = new HotkeyManager(macroManager);
                keyboardHook = new KeyboardHook();
                mouseHook = new MouseHook();
                toolTip = new ToolTip();

                InitializeComponent();

                // Initialize UI Manager after components are initialized
                uiManager = new UIManager(
                    this,
                    macroManager,
                    hotkeyManager,
                    debugLabel,
                    lblJitterActive,
                    lblRecoilReductionActive,
                    lblCurrentKeyValue,
                    lblMacroSwitchKeyValue,
                    lblJitterStrengthValue,
                    lblRecoilReductionStrengthValue,
                    notifyIcon,
                    toolTip
                );

                // Initialize components and settings
                InitializeCustomComponents();

                // Initialize tray icon behavior
                notifyIcon.Click += (s, e) => 
                {
                    // Only respond to left clicks
                    if (((MouseEventArgs)e).Button == MouseButtons.Left)
                    {
                        uiManager.ShowWindow();
                    }
                };
                showWindowMenuItem.Click += (s, e) => uiManager.ShowWindow();
                exitMenuItem.Click += (s, e) => CleanupAndExit();

                this.FormClosing += OnFormClosingHandler;
                this.Resize += OnResizeHandler;
                this.Load += OnLoadHandler;

                // Set up hook event handlers
                keyboardHook.KeyDown += OnKeyDown;
                mouseHook.MouseDown += OnMouseDown;
                mouseHook.MouseUp += OnMouseUp;

                // Set up macro manager event handlers
                macroManager.MacroStateChanged += OnMacroStateChanged;
                macroManager.ModeChanged += OnModeChanged;
                macroManager.JitterStarted += (s, e) => uiManager.UpdateDebugInfo("Jitter started");
                macroManager.JitterStopped += (s, e) => uiManager.UpdateDebugInfo("Jitter stopped");
                macroManager.RecoilReductionStarted += (s, e) => uiManager.UpdateDebugInfo("Recoil reduction started");
                macroManager.RecoilReductionStopped += (s, e) => uiManager.UpdateDebugInfo("Recoil reduction stopped");

                // Set up hotkey manager event handlers
                hotkeyManager.MacroKeyChanged += (s, key) => uiManager.UpdateCurrentKey(key.ToString());
                hotkeyManager.SwitchKeyChanged += (s, key) => uiManager.UpdateMacroSwitchKey(key.ToString());
                hotkeyManager.KeySettingStateChanged += OnKeySettingStateChanged;
                hotkeyManager.DebugInfoUpdated += (s, info) => uiManager.UpdateDebugInfo(info);

                // Handle application exit
                Application.ApplicationExit += (s, e) =>
                {
                    if (!isExiting)
                    {
                        CleanupAndExit();
                    }
                };

                // Initialize event handlers
                alwaysJitterCheckedChanged = (sender, e) =>
                {
                    try
                    {
                        if (chkAlwaysJitter.Checked)
                        {
                            chkAlwaysRecoilReduction.Checked = false;
                            macroManager.SetAlwaysJitterMode(true);
                            ConfigurationManager.Instance.CurrentSettings.MacroSettings.AlwaysJitterMode = true;
                            ConfigurationManager.Instance.SaveSettings();
                            uiManager.UpdateTitle();
                            uiManager.UpdateModeLabels();
                        }
                        else
                        {
                            macroManager.SetAlwaysJitterMode(false);
                            ConfigurationManager.Instance.CurrentSettings.MacroSettings.AlwaysJitterMode = false;
                            ConfigurationManager.Instance.SaveSettings();
                            uiManager.UpdateTitle();
                            uiManager.UpdateModeLabels();
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Error toggling jitter: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        chkAlwaysJitter.Checked = false;
                    }
                };

                alwaysRecoilReductionCheckedChanged = (sender, e) =>
                {
                    try
                    {
                        if (chkAlwaysRecoilReduction.Checked)
                        {
                            chkAlwaysJitter.Checked = false;
                            macroManager.SetAlwaysRecoilReductionMode(true);
                            ConfigurationManager.Instance.CurrentSettings.MacroSettings.AlwaysRecoilReductionMode = true;
                            ConfigurationManager.Instance.SaveSettings();
                            uiManager.UpdateTitle();
                            uiManager.UpdateModeLabels();
                        }
                        else
                        {
                            macroManager.SetAlwaysRecoilReductionMode(false);
                            ConfigurationManager.Instance.CurrentSettings.MacroSettings.AlwaysRecoilReductionMode = false;
                            ConfigurationManager.Instance.SaveSettings();
                            uiManager.UpdateTitle();
                            uiManager.UpdateModeLabels();
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Error toggling recoil reduction: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        chkAlwaysRecoilReduction.Checked = false;
                    }
                };

                // Subscribe to events
                chkAlwaysJitter.CheckedChanged += alwaysJitterCheckedChanged;
                chkAlwaysRecoilReduction.CheckedChanged += alwaysRecoilReductionCheckedChanged;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing form: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void OnKeyDown(object sender, KeyboardHookEventArgs e)
        {
            try
            {
                hotkeyManager.HandleKeyDown(e.VirtualKeyCode);
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnKeyDown: {ex.Message}");
            }
        }

        private void OnMouseDown(object sender, MouseHookEventArgs e)
        {
            try
            {
                switch (e.Button)
                {
                    case MouseButtons.Left:
                    case MouseButtons.Right:
                        macroManager.HandleMouseButton(e.Button, true);
                        break;
                    case MouseButtons.Middle:
                    case MouseButtons.XButton1:
                    case MouseButtons.XButton2:
                        hotkeyManager.HandleMouseButton(e.Button);
                        break;
                }
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnMouseDown: {ex.Message}");
            }
        }

        private void OnMouseUp(object sender, MouseHookEventArgs e)
        {
            try
            {
                if (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right)
                {
                    macroManager.HandleMouseButton(e.Button, false);
                }
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnMouseUp: {ex.Message}");
            }
        }

        private void OnKeySettingStateChanged(object sender, bool isSettingKey)
        {
            try
            {
                btnSetKey.Enabled = !isSettingKey;
                btnSetMacroSwitch.Enabled = !isSettingKey;

                if (hotkeyManager.IsSettingMacroKey)
                {
                    btnSetKey.Text = "Press any key...";
                    btnSetMacroSwitch.Text = "Set Switch Key";
                }
                else if (hotkeyManager.IsSettingSwitchKey)
                {
                    btnSetKey.Text = "Set Toggle Key";
                    btnSetMacroSwitch.Text = "Press any key...";
                }
                else
                {
                    btnSetKey.Text = "Set Toggle Key";
                    btnSetMacroSwitch.Text = "Set Switch Key";
                }
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnKeySettingStateChanged: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles the form closing event. If minimize to tray is enabled,
        /// the form will be hidden instead of closed when the user clicks the close button.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Event data containing the close reason and cancellation option.</param>
        private void OnFormClosingHandler(object sender, FormClosingEventArgs e)
        {
            if (!isExiting && chkMinimizeToTray.Checked && e.CloseReason == CloseReason.UserClosing)
            {
                e.Cancel = true;
                this.Hide();
                notifyIcon.Visible = true;
                uiManager.UpdateDebugInfo("Application minimized to system tray");
            }
            else if (isExiting || !chkMinimizeToTray.Checked)
            {
                // Cleanup when actually closing
                CleanupAndExit();
            }
        }

        /// <summary>
        /// Handles form resize events by ensuring proper layout of controls.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Event data.</param>
        private void OnResizeHandler(object sender, EventArgs e)
        {
            // Let the anchor properties handle control resizing
            mainPanel.PerformLayout();
            this.PerformLayout();
        }

        /// <summary>
        /// Handles the form load event by initializing hooks and timers.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Event data.</param>
        private void OnLoadHandler(object sender, EventArgs e)
        {
            try
            {
                // Start the hooks
                keyboardHook.Start();
                mouseHook.Start();
                
                // Update UI
                uiManager.UpdateTitle();
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error initializing hooks: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles changes in the macro's enabled/disabled state.
        /// </summary>
        private void OnMacroStateChanged(object sender, bool isEnabled)
        {
            try
            {
                uiManager.UpdateTitle();
                uiManager.UpdateDebugInfo($"Macro {(isEnabled ? "enabled" : "disabled")}");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnMacroStateChanged: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles changes in the macro's mode (jitter/recoil reduction).
        /// </summary>
        private void OnModeChanged(object sender, bool isJitterMode)
        {
            try
            {
                uiManager.UpdateTitle();
                uiManager.UpdateModeLabels();
                uiManager.UpdateDebugInfo($"Mode switched to {(isJitterMode ? "jitter" : "recoil reduction")}");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnModeChanged: {ex.Message}");
            }
        }

        /// <summary>
        /// Initializes custom components including icons, hotkeys, tooltips, and loads saved settings.
        /// </summary>
        private void InitializeCustomComponents()
        {
            try
            {
                using var icon = Icon.ExtractAssociatedIcon(Application.ExecutablePath);
                if (icon != null)
                {
                    this.Icon = (Icon)icon.Clone();
                    notifyIcon.Icon = (Icon)icon.Clone();
                }
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error loading icon: {ex.Message}");
            }

            // Set initial text with bold formatting
            if (hotkeyManager.MacroKey != Keys.None)
                uiManager.UpdateCurrentKey(hotkeyManager.MacroKey.ToString());
            if (hotkeyManager.SwitchKey != Keys.None)
                uiManager.UpdateSwitchKey(hotkeyManager.SwitchKey.ToString());

            // Initialize tooltips
            toolTip.SetToolTip(chkAlwaysJitter, "Always keep Jitter enabled");
            toolTip.SetToolTip(trackBarJitter, "Adjust Jitter strength");
            toolTip.SetToolTip(chkAlwaysRecoilReduction, "Always keep Recoil Reduction enabled");
            toolTip.SetToolTip(trackBarRecoilReduction, "Adjust Recoil Reduction strength");
            toolTip.SetToolTip(chkMinimizeToTray, "Minimize to system tray when closing");

            // Initialize event handlers
            InitializeEventHandlers();

            // Load settings
            LoadSettings();
        }

        private void InitializeEventHandlers()
        {
            btnToggleDebug.Click += (sender, e) =>
            {
                debugPanel.Visible = !debugPanel.Visible;
                btnToggleDebug.Text = debugPanel.Visible ? "Hide Debug Info" : "Show Debug Info";
                uiManager.UpdateDebugInfo("Debug panel visibility toggled");
            };

            btnSetKey.Click += (sender, e) =>
            {
                hotkeyManager.StartSettingMacroKey();
            };

            btnSetMacroSwitch.Click += (sender, e) =>
            {
                hotkeyManager.StartSettingSwitchKey();
            };

            chkMinimizeToTray.CheckedChanged += (sender, e) =>
            {
                ConfigurationManager.Instance.CurrentSettings.UISettings.MinimizeToTray = chkMinimizeToTray.Checked;
                ConfigurationManager.Instance.SaveSettings();
            };

            trackBarJitter.ValueChanged += (sender, e) =>
            {
                macroManager.SetJitterStrength(trackBarJitter.Value);
                lblJitterStrengthValue.Text = trackBarJitter.Value.ToString();
                ConfigurationManager.Instance.CurrentSettings.MacroSettings.JitterStrength = trackBarJitter.Value;
                ConfigurationManager.Instance.SaveSettings();
            };

            trackBarRecoilReduction.ValueChanged += (sender, e) =>
            {
                macroManager.SetRecoilReductionStrength(trackBarRecoilReduction.Value);
                lblRecoilReductionStrengthValue.Text = trackBarRecoilReduction.Value.ToString();
                ConfigurationManager.Instance.CurrentSettings.MacroSettings.RecoilReductionStrength = trackBarRecoilReduction.Value;
                ConfigurationManager.Instance.SaveSettings();
            };
        }

        /// <summary>
        /// Loads saved settings from the settings manager and applies them to the form.
        /// Validates all settings before applying them and falls back to defaults if validation fails.
        /// </summary>
        private void LoadSettings()
        {
            try
            {
                var settings = ConfigurationManager.Instance.CurrentSettings;
                if (settings == null)
                {
                    uiManager.UpdateDebugInfo("Invalid settings detected, resetting to defaults");
                    ResetToDefaultSettings();
                    return;
                }

                // Apply validated settings to UI
                trackBarJitter.Value = settings.MacroSettings.JitterStrength;
                trackBarRecoilReduction.Value = settings.MacroSettings.RecoilReductionStrength;
                chkAlwaysJitter.Checked = settings.MacroSettings.AlwaysJitterMode;
                chkAlwaysRecoilReduction.Checked = settings.MacroSettings.AlwaysRecoilReductionMode;
                chkMinimizeToTray.Checked = settings.UISettings.MinimizeToTray;

                // Update UI elements
                uiManager.UpdateTitle();
                uiManager.UpdateModeLabels();
                uiManager.UpdateDebugInfo("Settings loaded successfully");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error loading settings: {ex.Message}");
                ResetToDefaultSettings();
            }
        }

        /// <summary>
        /// Saves the current settings to the settings manager.
        /// </summary>
        private void SaveCurrentSettings()
        {
            try
            {
                var settings = ConfigurationManager.Instance.CurrentSettings;
                settings.MacroSettings.JitterStrength = trackBarJitter.Value;
                settings.MacroSettings.RecoilReductionStrength = trackBarRecoilReduction.Value;
                settings.MacroSettings.AlwaysJitterMode = chkAlwaysJitter.Checked;
                settings.MacroSettings.AlwaysRecoilReductionMode = chkAlwaysRecoilReduction.Checked;
                settings.UISettings.MinimizeToTray = chkMinimizeToTray.Checked;
                ConfigurationManager.Instance.SaveSettings();
                uiManager.UpdateDebugInfo("Settings saved successfully");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error saving settings: {ex.Message}");
            }
        }

        /// <summary>
        /// Resets all settings to their default values.
        /// </summary>
        private void ResetToDefaultSettings()
        {
            try
            {
                // Reset UI controls
                trackBarJitter.Value = 3;
                trackBarRecoilReduction.Value = 1;
                chkAlwaysJitter.Checked = false;
                chkAlwaysRecoilReduction.Checked = false;
                chkMinimizeToTray.Checked = false;

                // Reset MacroManager
                macroManager.SetJitterStrength(3);
                macroManager.SetRecoilReductionStrength(1);
                macroManager.SetAlwaysJitterMode(false);
                macroManager.SetAlwaysRecoilReductionMode(false);

                // Reset hotkeys
                hotkeyManager.ResetToDefaults();

                // Save default settings
                SaveCurrentSettings();

                // Update UI
                uiManager.UpdateTitle();
                uiManager.UpdateModeLabels();
                uiManager.UpdateDebugInfo("Settings reset to defaults");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error resetting settings: {ex.Message}");
            }
        }

        /// <summary>
        /// Shows and activates the main window when restored from system tray.
        /// </summary>
        private void ShowWindow()
        {
            this.Show();
            this.WindowState = FormWindowState.Normal;
            this.Activate();
            notifyIcon.Visible = false;
            uiManager.UpdateDebugInfo("Application restored from system tray");
        }

        /// <summary>
        /// Performs cleanup operations before exiting the application.
        /// </summary>
        private void CleanupAndExit()
        {
            try
            {
                isExiting = true;
                SaveCurrentSettings();

                // Stop and dispose of hooks
                keyboardHook?.Dispose();
                mouseHook?.Dispose();

                // Stop and dispose of macro manager
                macroManager?.Dispose();

                // Clean up UI resources
                notifyIcon?.Dispose();
                toolTip?.Dispose();
                uiManager?.Dispose();

                // Close the form
                this.Close();
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error during cleanup: {ex.Message}");
            }
        }

        /// <summary>
        /// Override of OnFormClosing to ensure settings are saved.
        /// </summary>
        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            SaveCurrentSettings();
            base.OnFormClosing(e);
        }
    }
}
</file>

</files>
