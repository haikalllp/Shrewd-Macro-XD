This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
app.manifest
architecture.xml
build.bat
buildCommand.md
docs/architecture.md
MouseMacro.csproj
MouseMacro.sln
Properties/Resources.Designer.cs
Properties/Resources.resx
README.md
src/Configuration/AppConfiguration.cs
src/Configuration/ConfigurationEvents.cs
src/Configuration/ConfigurationManager.cs
src/Configuration/EventHandlerExtensions.cs
src/Configuration/EventHandlerManager.cs
src/Configuration/SettingsValidation.cs
src/MacroForm.cs
src/MacroForm.Designer.cs
src/MacroForm.resx
src/ModernButton.cs
src/ModernTrackBar.cs
src/NativeMethods.cs
src/Program.cs
src/Settings.cs
src/SettingsManager.cs
src/Validation.cs
src/WinMessages.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="architecture.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
app.manifest
build.bat
buildCommand.md
docs/architecture.md
MouseMacro.csproj
MouseMacro.sln
Properties/Resources.Designer.cs
Properties/Resources.resx
README.md
src/Configuration/AppConfiguration.cs
src/Configuration/ConfigurationEvents.cs
src/Configuration/ConfigurationManager.cs
src/Configuration/EventHandlerExtensions.cs
src/Configuration/EventHandlerManager.cs
src/Configuration/SettingsValidation.cs
src/MacroForm.cs
src/MacroForm.Designer.cs
src/MacroForm.resx
src/ModernButton.cs
src/ModernTrackBar.cs
src/NativeMethods.cs
src/Program.cs
src/Settings.cs
src/SettingsManager.cs
src/Validation.cs
src/WinMessages.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="buildCommand.md">
# Batch (CMD)
dotnet clean && rmdir /s /q bin obj && dotnet restore && dotnet build -c Debug && dotnet build -c Release

# PowerShell
dotnet clean; Remove-Item -Recurse -Force bin,obj; dotnet restore; dotnet build -c Debug; dotnet build -c Release
</file>

<file path="MouseMacro.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35818.85 d17.13
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MouseMacro", "MouseMacro.csproj", "{1FFAD009-1089-42F1-C326-6CC678F746BF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E2EE0FEB-3FDA-4BFB-A0AF-B207C69E2C25}
	EndGlobalSection
EndGlobal
</file>

<file path="Properties/Resources.Designer.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
⋮----
/// <summary>
///   A strongly-typed resource class, for looking up localized strings, etc.
/// </summary>
// This class was auto-generated by the StronglyTypedResourceBuilder
// class via a tool like ResGen or Visual Studio.
// To add or remove a member, edit your .ResX file then rerun ResGen
// with the /str option, or rebuild your VS project.
⋮----
internal class Resources {
⋮----
///   Returns the cached ResourceManager instance used by this class.
⋮----
if (object.ReferenceEquals(resourceMan, null)) {
⋮----
///   Overrides the current thread's CurrentUICulture property for all
///   resource lookups using this strongly typed resource class.
</file>

<file path="Properties/Resources.resx">
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
</file>

<file path="src/Configuration/AppConfiguration.cs">
/// <summary>
/// Root configuration class that contains all application settings.
/// </summary>
public class AppConfiguration : ICloneable
⋮----
public object Clone()
⋮----
return new AppConfiguration
⋮----
/// Configuration settings for the jitter functionality.
⋮----
public class JitterConfiguration : ICloneable
⋮----
return new JitterConfiguration
⋮----
/// Configuration settings for the recoil reduction functionality.
⋮----
public class RecoilConfiguration : ICloneable
⋮----
return new RecoilConfiguration
⋮----
/// Configuration settings for hotkeys.
⋮----
public class HotkeyConfiguration : ICloneable
⋮----
return new HotkeyConfiguration
⋮----
/// Configuration settings for the user interface.
⋮----
public class UIConfiguration : ICloneable
⋮----
return new UIConfiguration
⋮----
WindowPosition = new Point(WindowPosition.X, WindowPosition.Y),
WindowSize = new Size(WindowSize.Width, WindowSize.Height)
⋮----
/// Configuration settings for backup functionality.
⋮----
public class BackupConfiguration : ICloneable
⋮----
return new BackupConfiguration
</file>

<file path="src/Configuration/ConfigurationEvents.cs">
/// <summary>
/// Event arguments for configuration change events.
/// </summary>
public class ConfigurationChangedEventArgs : EventArgs
⋮----
/// Gets the configuration section that was changed.
⋮----
/// Gets the previous configuration state.
⋮----
/// Gets the new configuration state.
⋮----
/// Event arguments for configuration validation events.
⋮----
public class ConfigurationValidationEventArgs : EventArgs
⋮----
/// Gets or sets whether the configuration is valid.
⋮----
/// Gets or sets the validation message.
⋮----
/// Gets the configuration being validated.
⋮----
/// Event arguments for configuration backup events.
⋮----
public class ConfigurationBackupEventArgs : EventArgs
⋮----
/// Gets the backup file path.
⋮----
/// Gets whether the backup was successful.
⋮----
/// Gets any error message if the backup failed.
⋮----
/// Delegate for configuration change events.
⋮----
/// Delegate for configuration validation events.
⋮----
/// Delegate for configuration backup events.
</file>

<file path="src/Configuration/EventHandlerExtensions.cs">
/// <summary>
/// Provides extension methods for event handler registration.
/// </summary>
public static class EventHandlerExtensions
⋮----
/// Registers all event handlers for a control with the event handler manager.
⋮----
/// <param name="control">The control to register events for.</param>
/// <param name="manager">The event handler manager.</param>
/// <returns>The control for method chaining.</returns>
public static T RegisterEvents<T>(this T control, EventHandlerManager manager) where T : Control
⋮----
manager.RegisterControlEvents(control);
⋮----
/// Unregisters all event handlers for a control from the event handler manager.
⋮----
/// <param name="control">The control to unregister events for.</param>
⋮----
public static T UnregisterEvents<T>(this T control, EventHandlerManager manager) where T : Control
⋮----
manager.UnregisterControlEvents(control);
⋮----
/// Registers a specific event handler with tracking.
⋮----
/// <param name="control">The control to register the event for.</param>
/// <param name="eventName">The name of the event.</param>
/// <param name="handler">The event handler delegate.</param>
⋮----
public static T RegisterEventHandler<T>(this T control, string eventName, Delegate handler, EventHandlerManager manager) where T : Control
⋮----
if (string.IsNullOrEmpty(eventName))
throw new ArgumentNullException(nameof(eventName));
⋮----
throw new ArgumentNullException(nameof(handler));
⋮----
// Add the event handler to the manager's tracking
⋮----
.GetMethod("RegisterEventHandler", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
⋮----
/// Registers common event handlers for a TrackBar control.
⋮----
public static TrackBar RegisterTrackBarEvents(this TrackBar trackBar, EventHandlerManager manager, Action<int> onValueChanged = null)
⋮----
EventHandler valueChangedHandler = (s, e) => onValueChanged(trackBar.Value);
trackBar.RegisterEventHandler("ValueChanged", valueChangedHandler, manager);
⋮----
/// Registers common event handlers for a CheckBox control.
⋮----
public static CheckBox RegisterCheckBoxEvents(this CheckBox checkBox, EventHandlerManager manager, Action<bool> onCheckedChanged = null)
⋮----
EventHandler checkedChangedHandler = (s, e) => onCheckedChanged(checkBox.Checked);
checkBox.RegisterEventHandler("CheckedChanged", checkedChangedHandler, manager);
⋮----
/// Registers common event handlers for a Button control.
⋮----
public static Button RegisterButtonEvents(this Button button, EventHandlerManager manager, Action onClick = null)
⋮----
EventHandler clickHandler = (s, e) => onClick();
button.RegisterEventHandler("Click", clickHandler, manager);
⋮----
/// Registers common event handlers for a TextBox control.
⋮----
public static TextBox RegisterTextBoxEvents(this TextBox textBox, EventHandlerManager manager,
⋮----
EventHandler textChangedHandler = (s, e) => onTextChanged(textBox.Text);
textBox.RegisterEventHandler("TextChanged", textChangedHandler, manager);
⋮----
KeyEventHandler keyDownHandler = (s, e) => onKeyDown(e);
textBox.RegisterEventHandler("KeyDown", keyDownHandler, manager);
</file>

<file path="src/Validation.cs">
namespace NotesAndTasks
⋮----
/// <summary>
/// Provides validation methods for input values throughout the application.
/// </summary>
internal static class Validation
⋮----
/// Validates a strength value for jitter or recoil reduction.
⋮----
/// <param name="strength">The strength value to validate.</param>
/// <param name="minValue">The minimum allowed value (inclusive).</param>
/// <param name="maxValue">The maximum allowed value (inclusive).</param>
/// <param name="paramName">The name of the parameter being validated.</param>
/// <exception cref="ArgumentOutOfRangeException">Thrown when the strength value is outside the valid range.</exception>
public static void ValidateStrength(int strength, int minValue, int maxValue, string paramName)
⋮----
throw new ArgumentOutOfRangeException(
⋮----
/// Validates that a string parameter is not null or empty.
⋮----
/// <param name="value">The string value to validate.</param>
⋮----
/// <exception cref="ArgumentNullException">Thrown when the value is null.</exception>
/// <exception cref="ArgumentException">Thrown when the value is empty.</exception>
public static void ValidateStringNotNullOrEmpty(string value, string paramName)
⋮----
throw new ArgumentNullException(paramName);
⋮----
if (string.IsNullOrWhiteSpace(value))
⋮----
throw new ArgumentException("Value cannot be empty or whitespace.", paramName);
⋮----
/// Validates that a reference parameter is not null.
⋮----
/// <typeparam name="T">The type of the parameter.</typeparam>
/// <param name="value">The value to validate.</param>
⋮----
public static void ValidateNotNull<T>(T value, string paramName) where T : class
⋮----
/// Validates that a handle is not IntPtr.Zero.
⋮----
/// <param name="handle">The handle to validate.</param>
⋮----
/// <exception cref="ArgumentException">Thrown when the handle is IntPtr.Zero.</exception>
public static void ValidateHandle(IntPtr handle, string paramName)
⋮----
throw new ArgumentException("Handle cannot be zero.", paramName);
⋮----
/// Validates that a hook code is valid for processing.
⋮----
/// <param name="nCode">The hook code to validate.</param>
/// <returns>True if the hook code should be processed, false if it should be passed to the next hook.</returns>
public static bool ValidateHookCode(int nCode)
</file>

<file path="app.manifest">
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="Notes&amp;Tasks"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="requireAdministrator" uiAccess="true" />
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
</file>

<file path="src/Configuration/ConfigurationManager.cs">
/// <summary>
/// Manages application configuration, providing thread-safe access to settings
/// and handling configuration persistence.
/// </summary>
public class ConfigurationManager
⋮----
new Lazy<ConfigurationManager>(() => new ConfigurationManager(), LazyThreadSafetyMode.ExecutionAndPublication);
⋮----
private readonly ReaderWriterLockSlim configLock = new ReaderWriterLockSlim();
⋮----
private AppConfiguration currentConfig;
private readonly JsonSerializerOptions jsonOptions;
⋮----
// Add these event declarations after the existing fields
public event ConfigurationChangedEventHandler ConfigurationChanged;
public event ConfigurationValidationEventHandler ConfigurationValidating;
public event ConfigurationBackupEventHandler ConfigurationBackupCompleted;
⋮----
/// Gets the singleton instance of the ConfigurationManager.
⋮----
/// Gets the current configuration. Thread-safe access to configuration values.
⋮----
configLock.EnterReadLock();
⋮----
return (AppConfiguration)currentConfig.Clone();
⋮----
configLock.ExitReadLock();
⋮----
configFilePath = Path.Combine(
Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
⋮----
jsonOptions = new JsonSerializerOptions
⋮----
/// Initializes the configuration system, creating default config if none exists.
⋮----
private void InitializeConfiguration()
⋮----
// Ensure directory exists
Directory.CreateDirectory(Path.GetDirectoryName(configFilePath));
⋮----
if (File.Exists(configFilePath))
⋮----
System.Diagnostics.Debug.WriteLine($"Error initializing configuration: {ex.Message}");
⋮----
/// Creates a default configuration with preset values.
⋮----
private AppConfiguration CreateDefaultConfiguration()
⋮----
return new AppConfiguration
⋮----
JitterSettings = new JitterConfiguration
⋮----
RecoilSettings = new RecoilConfiguration
⋮----
HotkeySettings = new HotkeyConfiguration
⋮----
MacroToggleKey = Keys.Capital.ToString(),
ModeSwitchKey = Keys.Q.ToString()
⋮----
UISettings = new UIConfiguration
⋮----
BackupSettings = new BackupConfiguration
⋮----
BackupDirectory = Path.Combine(
⋮----
/// Updates the configuration with new values and saves to disk.
⋮----
/// <param name="newConfig">The new configuration to apply.</param>
/// <param name="section">The section being updated.</param>
/// <returns>True if the update was successful, false otherwise.</returns>
public bool UpdateConfiguration(AppConfiguration newConfig, string section = "General")
⋮----
throw new ArgumentNullException(nameof(newConfig));
⋮----
configLock.EnterWriteLock();
⋮----
// Raise validation event
var validationArgs = new ConfigurationValidationEventArgs(newConfig);
⋮----
System.Diagnostics.Debug.WriteLine($"Configuration validation failed: {validationArgs.Message}");
⋮----
currentConfig = newConfig.Clone() as AppConfiguration;
⋮----
// Raise change event
OnConfigurationChanged(new ConfigurationChangedEventArgs(section, previousConfig, currentConfig));
⋮----
System.Diagnostics.Debug.WriteLine($"Error updating configuration: {ex.Message}");
⋮----
configLock.ExitWriteLock();
⋮----
/// Validates the configuration values.
⋮----
/// <param name="config">The configuration to validate.</param>
/// <returns>True if the configuration is valid, false otherwise.</returns>
private bool ValidateConfiguration(AppConfiguration config)
⋮----
// Validate Jitter settings
⋮----
// Validate Recoil settings
⋮----
// Validate hotkeys
if (string.IsNullOrEmpty(config.HotkeySettings.MacroToggleKey) ||
string.IsNullOrEmpty(config.HotkeySettings.ModeSwitchKey))
⋮----
// Validate backup settings
⋮----
string.IsNullOrEmpty(config.BackupSettings.BackupDirectory))
⋮----
System.Diagnostics.Debug.WriteLine($"Configuration validation error: {ex.Message}");
⋮----
/// Loads the configuration from disk.
⋮----
private void LoadConfiguration()
⋮----
string jsonContent = File.ReadAllText(configFilePath);
⋮----
System.Diagnostics.Debug.WriteLine($"Error loading configuration: {ex.Message}");
⋮----
/// Saves the current configuration to disk.
⋮----
private void SaveConfiguration()
⋮----
string jsonContent = JsonSerializer.Serialize(currentConfig, jsonOptions);
File.WriteAllText(configFilePath, jsonContent);
⋮----
System.Diagnostics.Debug.WriteLine($"Error saving configuration: {ex.Message}");
⋮----
/// Creates a backup of the current configuration.
⋮----
private void CreateConfigurationBackup()
⋮----
Directory.CreateDirectory(backupDir);
⋮----
string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
string backupPath = Path.Combine(backupDir, $"config_backup_{timestamp}.json");
⋮----
File.Copy(configFilePath, backupPath, true);
⋮----
// Cleanup old backups
var backupFiles = Directory.GetFiles(backupDir, "config_backup_*.json")
.OrderByDescending(f => f)
.Skip(currentConfig.BackupSettings.MaxBackupCount);
⋮----
File.Delete(file);
⋮----
System.Diagnostics.Debug.WriteLine($"Error deleting old backup {file}: {ex.Message}");
⋮----
// Raise backup completed event
OnConfigurationBackupCompleted(new ConfigurationBackupEventArgs(backupPath, true));
⋮----
System.Diagnostics.Debug.WriteLine($"Error creating configuration backup: {ex.Message}");
OnConfigurationBackupCompleted(new ConfigurationBackupEventArgs(null, false, ex.Message));
⋮----
/// Restores configuration from a backup file.
⋮----
/// <param name="backupFilePath">Path to the backup file to restore from.</param>
/// <returns>True if restore was successful, false otherwise.</returns>
public bool RestoreFromBackup(string backupFilePath)
⋮----
if (!File.Exists(backupFilePath))
⋮----
string jsonContent = File.ReadAllText(backupFilePath);
⋮----
System.Diagnostics.Debug.WriteLine($"Error restoring configuration: {ex.Message}");
⋮----
/// Gets a list of available configuration backups.
⋮----
/// <returns>Array of backup file paths.</returns>
public string[] GetAvailableBackups()
⋮----
if (!Directory.Exists(backupDir))
⋮----
return Directory.GetFiles(backupDir, "config_backup_*.json")
⋮----
.ToArray();
⋮----
System.Diagnostics.Debug.WriteLine($"Error getting available backups: {ex.Message}");
⋮----
/// Raises the ConfigurationChanged event.
⋮----
protected virtual void OnConfigurationChanged(ConfigurationChangedEventArgs e)
⋮----
/// Raises the ConfigurationValidating event.
⋮----
protected virtual void OnConfigurationValidating(ConfigurationValidationEventArgs e)
⋮----
/// Raises the ConfigurationBackupCompleted event.
⋮----
protected virtual void OnConfigurationBackupCompleted(ConfigurationBackupEventArgs e)
</file>

<file path="src/Configuration/EventHandlerManager.cs">
/// <summary>
/// Manages event handler registration and lifecycle for the application.
/// Provides centralized control over event subscriptions and cleanup.
/// </summary>
public class EventHandlerManager : IDisposable
⋮----
private readonly ConfigurationManager configManager;
⋮----
/// Initializes a new instance of the EventHandlerManager class.
⋮----
/// <param name="configManager">The configuration manager instance.</param>
⋮----
this.configManager = configManager ?? throw new ArgumentNullException(nameof(configManager));
⋮----
/// Registers configuration-related event handlers.
⋮----
private void RegisterConfigurationEvents()
⋮----
// Configuration change handlers
⋮----
new ConfigurationChangedEventHandler(OnConfigurationChanged));
⋮----
// Configuration validation handlers
⋮----
new ConfigurationValidationEventHandler(OnConfigurationValidating));
⋮----
// Configuration backup handlers
⋮----
new ConfigurationBackupEventHandler(OnConfigurationBackupCompleted));
⋮----
/// Registers a control's event handlers.
⋮----
/// <param name="control">The control to register events for.</param>
public void RegisterControlEvents<T>(T control) where T : Control
⋮----
// Store event handlers
⋮----
// Common events
EventHandler clickHandler = (s, e) => OnControlClick(control, e);
⋮----
handlers.Add(clickHandler);
⋮----
// Mouse events
MouseEventHandler mouseDownHandler = (s, e) => OnControlMouseDown(control, e);
⋮----
handlers.Add(mouseDownHandler);
⋮----
MouseEventHandler mouseUpHandler = (s, e) => OnControlMouseUp(control, e);
⋮----
handlers.Add(mouseUpHandler);
⋮----
// Type-specific events
⋮----
EventHandler valueChangedHandler = (s, e) => OnTrackBarValueChanged(trackBar, e);
⋮----
handlers.Add(valueChangedHandler);
⋮----
EventHandler scrollHandler = (s, e) => OnTrackBarScroll(trackBar, e);
⋮----
handlers.Add(scrollHandler);
⋮----
EventHandler checkedChangedHandler = (s, e) => OnCheckBoxCheckedChanged(checkBox, e);
⋮----
handlers.Add(checkedChangedHandler);
⋮----
EventHandler textChangedHandler = (s, e) => OnTextBoxTextChanged(textBox, e);
⋮----
handlers.Add(textChangedHandler);
⋮----
KeyEventHandler keyDownHandler = (s, e) => OnTextBoxKeyDown(textBox, e);
⋮----
handlers.Add(keyDownHandler);
⋮----
/// Registers an event handler with tracking.
⋮----
private void RegisterEventHandler(string eventName, Delegate handler)
⋮----
if (!eventHandlers.ContainsKey(eventName))
⋮----
eventHandlers[eventName].Add(handler);
⋮----
/// Unregisters all event handlers for a control.
⋮----
public void UnregisterControlEvents(Control control)
⋮----
if (kvp.Key.StartsWith($"{control.Name}_"))
⋮----
handlersToRemove.Add(kvp.Key);
⋮----
eventHandlers.Remove(handlerName);
⋮----
/// Configuration changed event handler.
⋮----
private void OnConfigurationChanged(object sender, ConfigurationChangedEventArgs e)
⋮----
// Handle configuration changes based on section
⋮----
System.Diagnostics.Debug.WriteLine($"Error handling configuration change: {ex.Message}");
⋮----
/// Configuration validating event handler.
⋮----
private void OnConfigurationValidating(object sender, ConfigurationValidationEventArgs e)
⋮----
// Perform additional validation if needed
⋮----
System.Diagnostics.Debug.WriteLine($"Error during configuration validation: {ex.Message}");
⋮----
/// Configuration backup completed event handler.
⋮----
private void OnConfigurationBackupCompleted(object sender, ConfigurationBackupEventArgs e)
⋮----
System.Diagnostics.Debug.WriteLine($"Configuration backup created successfully at: {e.BackupPath}");
⋮----
System.Diagnostics.Debug.WriteLine($"Configuration backup failed: {e.ErrorMessage}");
⋮----
System.Diagnostics.Debug.WriteLine($"Error handling backup completion: {ex.Message}");
⋮----
/// Validates configuration consistency.
⋮----
private void ValidateConfigurationConsistency(ConfigurationValidationEventArgs e)
⋮----
// Validate mode consistency
⋮----
// Validate hotkey conflicts
⋮----
// Validate backup settings
⋮----
/// Handles changes to jitter settings.
⋮----
private void HandleJitterSettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
⋮----
System.Diagnostics.Debug.WriteLine($"Jitter strength changed from {previousConfig?.JitterSettings.Strength} to {newConfig.JitterSettings.Strength}");
⋮----
System.Diagnostics.Debug.WriteLine($"Jitter enabled state changed from {previousConfig?.JitterSettings.IsEnabled} to {newConfig.JitterSettings.IsEnabled}");
⋮----
/// Handles changes to recoil reduction settings.
⋮----
private void HandleRecoilSettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
⋮----
System.Diagnostics.Debug.WriteLine($"Recoil reduction strength changed from {previousConfig?.RecoilSettings.Strength} to {newConfig.RecoilSettings.Strength}");
⋮----
System.Diagnostics.Debug.WriteLine($"Recoil reduction enabled state changed from {previousConfig?.RecoilSettings.IsEnabled} to {newConfig.RecoilSettings.IsEnabled}");
⋮----
/// Handles changes to hotkey settings.
⋮----
private void HandleHotkeySettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
⋮----
System.Diagnostics.Debug.WriteLine($"Macro toggle key changed from {previousConfig?.HotkeySettings.MacroToggleKey} to {newConfig.HotkeySettings.MacroToggleKey}");
⋮----
System.Diagnostics.Debug.WriteLine($"Mode switch key changed from {previousConfig?.HotkeySettings.ModeSwitchKey} to {newConfig.HotkeySettings.ModeSwitchKey}");
⋮----
/// Handles changes to UI settings.
⋮----
private void HandleUISettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
⋮----
System.Diagnostics.Debug.WriteLine($"Minimize to tray setting changed from {previousConfig?.UISettings.MinimizeToTray} to {newConfig.UISettings.MinimizeToTray}");
⋮----
System.Diagnostics.Debug.WriteLine($"Debug panel visibility changed from {previousConfig?.UISettings.ShowDebugPanel} to {newConfig.UISettings.ShowDebugPanel}");
⋮----
// Event handler methods
private void OnControlClick(Control control, EventArgs e)
⋮----
// Handle click event
⋮----
private void OnControlMouseDown(Control control, MouseEventArgs e)
⋮----
// Handle mouse down
⋮----
private void OnControlMouseUp(Control control, MouseEventArgs e)
⋮----
// Handle mouse up
⋮----
private void OnTrackBarValueChanged(TrackBar trackBar, EventArgs e)
⋮----
// Handle value changed
⋮----
private void OnTrackBarScroll(TrackBar trackBar, EventArgs e)
⋮----
// Handle scroll
⋮----
private void OnCheckBoxCheckedChanged(CheckBox checkBox, EventArgs e)
⋮----
// Handle checked changed
⋮----
private void OnTextBoxTextChanged(TextBox textBox, EventArgs e)
⋮----
// Handle text changed
⋮----
private void OnTextBoxKeyDown(TextBox textBox, KeyEventArgs e)
⋮----
// Handle key down
⋮----
/// Disposes of the event handler manager and unregisters all events.
⋮----
public void Dispose()
⋮----
GC.SuppressFinalize(this);
⋮----
/// Protected implementation of Dispose pattern.
⋮----
protected virtual void Dispose(bool disposing)
⋮----
// Unregister all event handlers
⋮----
eventHandlers.Clear();
</file>

<file path="src/Configuration/SettingsValidation.cs">
public static class SettingsValidation
⋮----
public static bool IsValidHotkey(Keys key)
⋮----
// Validate that the key is a valid hotkey
⋮----
public static bool ValidateSettings(Settings settings, int minStrength, int maxStrength)
⋮----
// Validate strength values
⋮----
// Validate hotkeys
if (string.IsNullOrEmpty(settings.MacroToggleKey) || string.IsNullOrEmpty(settings.ModeSwitchKey))
⋮----
var toggleKey = (Keys)Enum.Parse(typeof(Keys), settings.MacroToggleKey);
var switchKey = (Keys)Enum.Parse(typeof(Keys), settings.ModeSwitchKey);
</file>

<file path="src/ModernButton.cs">
namespace NotesAndTasks
⋮----
public class ModernButton : Button
⋮----
private Color borderColor = Color.FromArgb(250, 91, 101);
private Color hoverBackColor = Color.FromArgb(214, 37, 106);
⋮----
BackColor = Color.FromArgb(30, 1, 62);
⋮----
Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
Size = new Size(150, 40);
⋮----
protected override void OnPaint(PaintEventArgs e)
⋮----
var graphicsPath = new GraphicsPath();
var rect = new Rectangle(0, 0, Width - 1, Height - 1);
⋮----
// Create rounded rectangle path
graphicsPath.AddArc(rect.X, rect.Y, radius * 2, radius * 2, 180, 90);
graphicsPath.AddArc(rect.Right - radius * 2, rect.Y, radius * 2, radius * 2, 270, 90);
graphicsPath.AddArc(rect.Right - radius * 2, rect.Bottom - radius * 2, radius * 2, radius * 2, 0, 90);
graphicsPath.AddArc(rect.X, rect.Bottom - radius * 2, radius * 2, radius * 2, 90, 90);
graphicsPath.CloseFigure();
⋮----
// Fill background
using (var brush = new SolidBrush(isHovered ? hoverBackColor : BackColor))
⋮----
e.Graphics.FillPath(brush, graphicsPath);
⋮----
// Draw border
using (var pen = new Pen(borderColor, 1))
⋮----
e.Graphics.DrawPath(pen, graphicsPath);
⋮----
// Draw text
var textRect = new Rectangle(0, 0, Width, Height);
TextRenderer.DrawText(e.Graphics, Text, Font, textRect, ForeColor,
⋮----
graphicsPath.Dispose();
</file>

<file path="src/ModernTrackBar.cs">
namespace NotesAndTasks
⋮----
public class ModernTrackBar : TrackBar
⋮----
private Color tickColor = Color.FromArgb(250, 91, 101);
private Color trackColor = Color.FromArgb(214, 37, 106);
private Color thumbColor = Color.FromArgb(255,255,255);
⋮----
protected override void OnMouseDown(MouseEventArgs e)
⋮----
base.OnMouseDown(e);
⋮----
protected override void OnMouseMove(MouseEventArgs e)
⋮----
base.OnMouseMove(e);
⋮----
protected override void OnMouseUp(MouseEventArgs e)
⋮----
base.OnMouseUp(e);
⋮----
private void UpdateValue(int mouseX)
⋮----
protected override void OnPaint(PaintEventArgs e)
⋮----
e.Graphics.Clear(BackColor);
⋮----
var trackRect = new Rectangle(0, Height / 2 - 2, Width - 1, 4);
using (var trackBrush = new SolidBrush(trackColor))
⋮----
e.Graphics.FillRectangle(trackBrush, trackRect);
⋮----
// Draw ticks
⋮----
using (var tickPen = new Pen(tickColor, 1))
⋮----
e.Graphics.DrawLine(tickPen, x, Height / 2 + 5, x, Height / 2 + 10);
⋮----
// Draw thumb
⋮----
var thumbRect = new Rectangle((int)thumbPosition - 6, Height / 2 - 6, 12, 12);
using (var thumbBrush = new SolidBrush(thumbColor))
⋮----
e.Graphics.FillEllipse(thumbBrush, thumbRect);
</file>

<file path="src/NativeMethods.cs">
namespace NotesAndTasks
⋮----
/// <summary>
/// Contains P/Invoke declarations for Windows API functions and related structures.
/// This class follows security best practices by isolating native method declarations.
/// </summary>
/// <remarks>
/// This class encapsulates all external Windows API calls used by the application.
/// It implements the recommended pattern for P/Invoke declarations by:
/// - Using internal access to limit exposure
/// - Properly declaring structures with correct marshaling attributes
/// - Including security-related attributes where needed
/// - Providing comprehensive documentation for each member
/// </remarks>
internal static class NativeMethods
⋮----
/// Delegate for low-level keyboard and mouse hook callbacks.
⋮----
/// <param name="nCode">Hook code. If nCode is less than zero, the hook procedure must pass the message to CallNextHookEx.</param>
/// <param name="wParam">Message identifier.</param>
/// <param name="lParam">Pointer to a KBDLLHOOKSTRUCT or MSLLHOOKSTRUCT structure.</param>
/// <returns>If nCode is less than zero, the hook procedure must return the value returned by CallNextHookEx.</returns>
⋮----
/// Represents a point in a two-dimensional coordinate system.
⋮----
/// <summary>The x-coordinate of the point.</summary>
⋮----
/// <summary>The y-coordinate of the point.</summary>
⋮----
/// Contains information about a low-level mouse input event.
⋮----
/// <summary>The x- and y-coordinates of the cursor, in screen coordinates.</summary>
public POINT pt;
⋮----
/// Additional information about the mouse event.
/// If the message is WM_XBUTTONDOWN, WM_XBUTTONUP, WM_XBUTTONDBLCLK, WM_NCXBUTTONDOWN, WM_NCXBUTTONUP,
/// or WM_NCXBUTTONDBLCLK, the high-order word specifies which X button was pressed or released.
⋮----
/// <summary>The event-injected flag.</summary>
⋮----
/// <summary>The time stamp for this message.</summary>
⋮----
/// <summary>Additional information associated with the message.</summary>
public IntPtr dwExtraInfo;
⋮----
/// Contains information about simulated mouse or keyboard input events.
⋮----
/// <summary>The type of the input event (1 for mouse input, 2 for keyboard input).</summary>
⋮----
/// <summary>The mouse input data when the type is INPUT_MOUSE.</summary>
public MOUSEINPUT mi;
⋮----
/// Contains information about a simulated mouse event.
⋮----
/// <summary>The absolute position of the mouse, or the amount of motion since the last mouse event.</summary>
⋮----
/// <summary>If the mouse wheel is moved, indicates the amount of wheel movement.</summary>
⋮----
/// <summary>A set of bit flags that specify various aspects of mouse motion and button clicks.</summary>
⋮----
/// <summary>The time stamp for the event, in milliseconds.</summary>
⋮----
/// <summary>Additional information associated with the event.</summary>
⋮----
/// Sets a Windows hook that monitors low-level keyboard or mouse input events.
⋮----
/// <param name="idHook">The type of hook to be installed (WH_KEYBOARD_LL or WH_MOUSE_LL).</param>
/// <param name="lpfn">A pointer to the hook procedure.</param>
/// <param name="hMod">A handle to the DLL containing the hook procedure.</param>
/// <param name="dwThreadId">The identifier of the thread with which the hook procedure is to be associated.</param>
/// <returns>If successful, returns a handle to the hook procedure. If unsuccessful, returns IntPtr.Zero.</returns>
⋮----
/// The hook procedure should process the message and return the value returned by CallNextHookEx.
/// For low-level hooks, the hook procedure must be in the same desktop as the running application.
⋮----
internal static extern IntPtr SetWindowsHookEx(
⋮----
/// Removes a previously set Windows hook.
⋮----
/// <param name="hhk">A handle to the hook to be removed. This parameter is obtained by a previous call to SetWindowsHookEx.</param>
/// <returns>If successful, returns true. If unsuccessful, returns false.</returns>
⋮----
/// The hook procedure must be in the state to be removed, that is, it must not be in the middle of processing a message.
/// This function must be called on the same thread that installed the hook.
⋮----
internal static extern bool UnhookWindowsHookEx(IntPtr hhk);
⋮----
/// Passes the hook information to the next hook procedure in the current hook chain.
⋮----
/// <param name="hhk">This parameter is ignored.</param>
/// <param name="nCode">The hook code passed to the current hook procedure.</param>
/// <param name="wParam">The wParam value passed to the current hook procedure.</param>
/// <param name="lParam">The lParam value passed to the current hook procedure.</param>
/// <returns>The value returned by the next hook procedure in the chain.</returns>
⋮----
/// This function must be called by the hook procedure if it is not processing the message.
/// The hook procedure can modify the values pointed to by wParam and lParam before passing them to CallNextHookEx.
⋮----
internal static extern IntPtr CallNextHookEx(
⋮----
/// Retrieves the current cursor position.
⋮----
/// <param name="lpPoint">A pointer to a POINT structure that receives the screen coordinates of the cursor.</param>
/// <returns>Returns true if successful, false otherwise.</returns>
⋮----
/// The cursor position is always specified in screen coordinates and is not affected by the mapping mode of the window that contains the cursor.
⋮----
internal static extern bool GetCursorPos(out POINT lpPoint);
⋮----
/// Synthesizes mouse motion and button clicks.
⋮----
/// <param name="dwFlags">A set of bit flags that specify various aspects of mouse motion and button clicking.</param>
/// <param name="dx">The mouse's absolute position along the x-axis or its amount of motion since the last mouse event.</param>
/// <param name="dy">The mouse's absolute position along the y-axis or its amount of motion since the last mouse event.</param>
/// <param name="dwData">If dwFlags contains MOUSEEVENTF_WHEEL, then dwData specifies the amount of wheel movement.</param>
/// <param name="dwExtraInfo">Additional information associated with the mouse event.</param>
⋮----
/// The mouse_event function has been superseded by SendInput. Use SendInput instead.
⋮----
internal static extern void mouse_event(
⋮----
/// Synthesizes keystrokes, mouse motions, and button clicks.
⋮----
/// <param name="nInputs">The number of structures in the pInputs array.</param>
/// <param name="pInputs">An array of INPUT structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</param>
/// <param name="cbSize">The size, in bytes, of an INPUT structure.</param>
/// <returns>The function returns the number of events that it successfully inserted into the keyboard or mouse input stream.</returns>
⋮----
/// This function is the preferred method for synthesizing input, as it supports more features and is more efficient than mouse_event and keybd_event.
⋮----
internal static extern uint SendInput(
⋮----
/// Retrieves a module handle for the specified module.
⋮----
/// <param name="lpModuleName">The name of the loaded module (either a .dll or .exe file).</param>
/// <returns>If successful, returns a handle to the specified module. If unsuccessful, returns IntPtr.Zero.</returns>
⋮----
/// If lpModuleName is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).
/// The returned handle is not global or inheritable. It cannot be duplicated or used by another process.
⋮----
internal static extern IntPtr GetModuleHandle(string lpModuleName);
</file>

<file path="src/WinMessages.cs">
namespace NotesAndTasks
⋮----
/// <summary>
/// Contains Windows message constants used for low-level hooks and input handling.
/// </summary>
/// <remarks>
/// This class provides a centralized location for all Windows message constants used in the application.
/// The constants are organized into logical groups:
/// - Hook-related constants (WH_*)
/// - Keyboard message constants (WM_KEY*)
/// - Mouse button message constants (WM_*BUTTON*)
/// - Mouse button identifiers (XBUTTON*)
/// - Mouse event flags (MOUSEEVENTF_*)
/// - Input type identifiers (INPUT_*)
/// - Base values for calculations
/// </remarks>
public static class WinMessages
⋮----
/// Windows hook constant for low-level keyboard events.
/// Used with SetWindowsHookEx to install a hook procedure that monitors low-level keyboard input events.
⋮----
/// Windows hook constant for low-level mouse events.
/// Used with SetWindowsHookEx to install a hook procedure that monitors low-level mouse input events.
⋮----
/// Posted when a nonsystem key is pressed.
/// A nonsystem key is a key that is pressed when the ALT key is not pressed.
⋮----
/// Posted when the left mouse button is pressed.
⋮----
/// Posted when the left mouse button is released.
⋮----
/// Posted when the right mouse button is pressed.
⋮----
/// Posted when the right mouse button is released.
⋮----
/// Posted when the middle mouse button is pressed.
⋮----
/// Posted when an X button is pressed.
/// The specific button (XBUTTON1 or XBUTTON2) is indicated in the high-order word of the mouseData field.
⋮----
/// First X button identifier (typically the fourth mouse button).
/// Used to identify which X button was pressed in WM_XBUTTONDOWN events.
⋮----
/// Second X button identifier (typically the fifth mouse button).
⋮----
/// Mouse event flag indicating relative mouse movement.
/// When used with SendInput, specifies that dx and dy contain relative movement data.
⋮----
/// Input type constant indicating mouse input.
/// Used with the INPUT structure to specify that the input event is mouse-related.
⋮----
/// Base strength value for recoil calculations.
/// Used as a multiplier in basic recoil reduction calculations.
⋮----
/// Secondary base strength value for enhanced recoil calculations.
/// Used as a multiplier in advanced recoil reduction calculations.
⋮----
/// Speed multiplier for the lowest level of movement adjustment.
/// Applied to movement calculations when minimal adjustment is needed.
⋮----
/// Speed multiplier for the medium-low level of movement adjustment.
/// Applied to movement calculations when moderate adjustment is needed.
⋮----
/// Speed multiplier for the medium level of movement adjustment.
/// Applied to movement calculations when significant adjustment is needed.
</file>

<file path="build.bat">
@echo off
:: Check for admin privileges
net session >nul 2>&1
if %errorLevel% == 0 (
    goto :admin
) else (
    echo Requesting administrative privileges...
    goto :UACPrompt
)

:UACPrompt
echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
echo UAC.ShellExecute "%~s0", "", "", "runas", 1 >> "%temp%\getadmin.vbs"
"%temp%\getadmin.vbs"
del "%temp%\getadmin.vbs"
exit /B

:admin
cd /d "%~dp0"

echo Starting Mouse Macro build process...
echo.

echo === Cleaning solution ===
dotnet clean
if errorlevel 1 goto error

echo === Removing build directories ===
if exist "bin" rmdir /s /q "bin"
if exist "obj" rmdir /s /q "obj"
if errorlevel 1 goto error

echo === Restoring packages ===
dotnet restore
if errorlevel 1 goto error

echo === Building Debug configuration ===
dotnet build -c Debug
if errorlevel 1 goto error

echo === Building Release configuration ===
dotnet build -c Release
if errorlevel 1 goto error

echo.
echo === Build Complete! ===
echo.
echo Debug build: %~dp0bin\Debug\net6.0-windows\NotesAndTasks.exe
echo Release build: %~dp0bin\Release\net6.0-windows\NotesAndTasks.exe
echo.
goto end

:error
echo.
echo Build failed! See error message above.
pause
exit /b 1

:end
echo Press any key to exit...
pause >nul
</file>

<file path="src/MacroForm.resx">
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="notifyIcon.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="trayContextMenu.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>125, 17</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>45</value>
  </metadata>
</root>
</file>

<file path="src/SettingsManager.cs">
namespace NotesAndTasks
⋮----
public static class SettingsManager
⋮----
private static readonly string _configPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "macro_config.json");
⋮----
CurrentSettings = new Settings();
⋮----
// If we can't save settings, at least we have defaults in memory
⋮----
private static void LoadOrCreateSettings()
⋮----
if (File.Exists(_configPath))
⋮----
string jsonContent = File.ReadAllText(_configPath);
CurrentSettings = JsonConvert.DeserializeObject<Settings>(jsonContent) ?? new Settings();
⋮----
public static void SaveSettings()
⋮----
string jsonContent = JsonConvert.SerializeObject(CurrentSettings, Formatting.Indented);
File.WriteAllText(_configPath, jsonContent);
⋮----
// Consider adding logging here if needed
</file>

<file path="src/Settings.cs">
namespace NotesAndTasks
⋮----
public class Settings
⋮----
// Jitter settings
⋮----
// Recoil reduction settings
⋮----
// Key bindings
⋮----
// UI preferences
</file>

<file path="src/Program.cs">
namespace NotesAndTasks
⋮----
internal static class Program
⋮----
private static Mutex mutex = new Mutex(true, "NotesTasksGlobalMutex");
⋮----
static void Main()
⋮----
// Check for administrative privileges
WindowsIdentity identity = WindowsIdentity.GetCurrent();
WindowsPrincipal principal = new WindowsPrincipal(identity);
bool isAdmin = principal.IsInRole(WindowsBuiltInRole.Administrator);
⋮----
// Restart the application with admin rights
ProcessStartInfo startInfo = new ProcessStartInfo();
⋮----
Process.Start(startInfo);
⋮----
MessageBox.Show("This application requires administrative privileges to run.", "Notes&Tasks",
⋮----
// Try to get mutex ownership
if (!mutex.WaitOne(TimeSpan.Zero, true))
⋮----
MessageBox.Show("Another instance of Notes&Tasks is already running.", "Notes&Tasks",
⋮----
// Optimize process settings for background operation alongside games
using (Process currentProcess = Process.GetCurrentProcess())
⋮----
// Set process priority to BelowNormal to avoid competing with games
⋮----
// Set CPU affinity to use last core
// This keeps the macro off the primary cores that games typically use
⋮----
// Enable Windows 11 Efficiency Mode
// This helps reduce resource competition with games
⋮----
if (Environment.OSVersion.Version.Build >= 22621) // Windows 11 22H2 build
⋮----
catch (Exception) { /* Ignore if not supported */ }
⋮----
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
⋮----
Application.Run(new MacroForm());
⋮----
// Release mutex when application exits
mutex.ReleaseMutex();
⋮----
MessageBox.Show($"An error occurred: {ex.Message}", "Notes&Tasks Error",
⋮----
mutex.Dispose();
</file>

<file path="MouseMacro.csproj">
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net6.0-windows</TargetFramework>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
    <UacUIApproved>true</UacUIApproved>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <AssemblyName>Notes&amp;Tasks</AssemblyName>
    <RootNamespace>Notes&amp;Tasks</RootNamespace>
    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>
    <ApplicationIcon>assets\logo.ico</ApplicationIcon>
    <Title>Notes &amp; Tasks</Title>
    <Authors>HaikalllP</Authors>
    <Description>Task Management and Note Taking Application</Description>
    <SignAssembly>true</SignAssembly>
    <EnableUnsafeBinaryFormatterSerialization>true</EnableUnsafeBinaryFormatterSerialization>
    <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
    <Version>1.0.0.1</Version> <!-- Incrementing the version for the next release -->
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DebugType>embedded</DebugType>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
    <DebugType>none</DebugType>
    <Optimize>true</Optimize>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="src\**\*.cs" />
  </ItemGroup>

  <ItemGroup>
    <Compile Include="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
</Project>
</file>

<file path=".gitignore">
# Build output directories
bin/*
obj/*

# Visual Studio files
.vs/
*.user
*.suo

# Temporary files
*.tmp
*.bak

# Log files
*.log

# User-specific configuration
*.userprefs

# Nuget packages (if using NuGet)
*.nupkg
obj/Debug/net6.0-windows/MouseMacro.assets.cache
obj/Debug/net6.0-windows/MouseMacro.GeneratedMSBuildEditorConfig.editorconfig

# RepoMix
.cursor/*
.git/*
.idea/*
.vs/*
.vscode/*
bin/*
obj/*
</file>

<file path="docs/architecture.md">
# Mouse Macro Application Architecture

## Introduction
This document provides an overview of the Mouse Macro Application architecture. The application is designed to create and manage mouse macros, featuring a modern dark-themed UI for keybind configuration and settings management.IMPORTANT For professional system integration the application presents itself as "Notes&Tasks" and "NotesAndTasks" 😊.

## System Overview

### Identity & Integration
- **Process Name**: NotesTasks.exe
- **Display Name**: Notes&Tasks
- **Window Title**: Notes&Tasks - [Status]
- **System Tray**: Notes&Tasks with corresponding icon
- **Design Rationale**:
  - Professional appearance in enterprise environments
  - Discrete system integration
  - Consistent branding across interfaces

### System Requirements
1. **Hardware**
   - Windows 10/11 compatible PC
   - DirectX compatible display
   - Mouse with standard buttons
   - Keyboard for hotkey support
   - Optional: Multi-button mouse, high refresh rate display, SSD

2. **Software**
   - Windows 10/11 (64-bit)
   - .NET 6.0 Runtime
   - Administrator privileges
   - DirectX 9.0c or later

## Project Structure

### Directory Organization
```
MouseMacro/
├── assets/                  # Application resources
│   ├── logo.ico            # Application icon
├── bin/                    # Compiled binaries
│   ├── Debug/             # Debug build output
│   └── Release/           # Release build output
├── docs/                   # Documentation
├── obj/                    # Intermediate build files
│   ├── Debug/             # Debug build intermediates
│   │   └── net6.0-windows/
│   │       ├── ref/       # Assembly reference files
│   │       ├── refint/    # Reference interface files
│   │       └── *.cache    # Build cache files
│   └── Release/           # Release build intermediates
├── src/                    # Source code
│   ├── MacroForm.cs       # Main form implementation
│   ├── MacroForm.Designer.cs # Form designer code
│   ├── ModernButton.cs    # Custom button control
│   ├── ModernTrackBar.cs  # Custom trackbar control
│   └── Program.cs         # Application entry point
├── MouseMacro.csproj      # Project configuration
├── README.md              # Project documentation and setup guide
└── app.manifest           # Application manifest
```

## Core Components

### 1. Input System
- **Low-Level Hooks**
  - Keyboard Hook (WH_KEYBOARD_LL)
  - Mouse Hook (WH_MOUSE_LL)
  - Global event capture
  
- **Input Simulation**
  - SendInput API implementation
  - Physical mouse movement simulation
  - Game compatibility optimizations

- **Toggle System**
  - Keyboard key support
  - Mouse button support (Mouse3-5)
  - State tracking via GetAsyncKeyState

### 2. Macro Engine
- **Recoil Reduction System**
  - Vertical compensation
  - Three-tier strength distribution:
    - Tier 1 (1-6): Linear scaling
    - Tier 2 (7-16): Enhanced scaling
    - Tier 3 (17-20): Maximum impact
  - Dynamic strength adjustment
  - Default strength: 1
  
- **Jitter System**
  - Complex movement patterns
  - Strength control (1-20)
  - Optional activation
  - Default strength: 3
  
- **Mode Switching**
  - Toggle between Jitter and Recoil Reduction modes
  - Default switch key: Q
  - Always mode options (locks to either Jitter or Recoil Reduction mode at all times)
  - Independent mode states

- **Timer Management**
  - Dual timer implementation
  - Independent operation
  - Performance optimized

### 3. User Interface
- **Main Window**
  - Modern dark theme with consistent color scheme
  - Responsive layout with fluid transitions
  - DPI scaling support
  - Professional visual design
  
- **Custom Controls**
  - ModernButton
    - Customizable hover and click effects
    - Smooth color transitions
    - Consistent styling with theme
    - Professional rounded corners
  - ModernTrackBar
    - Custom slider design
    - Visual value feedback
    - Smooth drag operations
    - Theme-consistent appearance
  
- **Standard Controls**
  - Macro Toggle key display/configuration (Default: Capital)
  - Macro Switch key configuration (Default: Q)
  - Strength sliders (1-20)
  - Mode toggles and indicators
  - Always mode checkboxes
  - Debug panel (collapsible)
  
- **System Tray**
  - Minimize to tray support
  - Context menu
  - Status indication

### 4. Process Management
- **Instance Control**
  - Global mutex implementation
  - Single instance enforcement
  - Clean termination handling
  
- **Security**
  - UAC integration
  - Privilege management
  - Secure API access

### 5. Settings Configuration System
- **Configuration Manager (`ConfigurationManager.cs`)**
  - Singleton pattern implementation
  - Thread-safe operations using `ReaderWriterLockSlim`
  - JSON-based configuration storage
  - Automatic configuration backup
  - Event-driven configuration changes
  - Validation system

#### 5.1 Configuration Components
```csharp
// Root configuration
public class AppConfiguration : ICloneable
{
    public JitterConfiguration JitterSettings { get; set; }
    public RecoilConfiguration RecoilSettings { get; set; }
    public HotkeyConfiguration HotkeySettings { get; set; }
    public UIConfiguration UISettings { get; set; }
    public BackupConfiguration BackupSettings { get; set; }
}

// Feature-specific configurations
public class JitterConfiguration : ICloneable
public class RecoilConfiguration : ICloneable
public class HotkeyConfiguration : ICloneable
public class UIConfiguration : ICloneable
public class BackupConfiguration : ICloneable
```

#### 5.2 Configuration Events
```csharp
// Event Arguments
public class ConfigurationChangedEventArgs : EventArgs
public class ConfigurationValidationEventArgs : EventArgs
public class ConfigurationBackupEventArgs : EventArgs

// Event Handlers
public delegate void ConfigurationChangedEventHandler(object sender, ConfigurationChangedEventArgs e);
public delegate void ConfigurationValidationEventHandler(object sender, ConfigurationValidationEventArgs e);
public delegate void ConfigurationBackupEventHandler(object sender, ConfigurationBackupEventArgs e);
```

#### 5.3 Configuration Validation
```csharp
public static class Validation
{
    // Core validation methods
    public static void ValidateStrength(int strength, int minValue, int maxValue, string paramName)
    public static void ValidateStringNotNullOrEmpty(string value, string paramName)
    public static void ValidateNotNull<T>(T value, string paramName)
    public static void ValidateHandle(IntPtr handle, string paramName)
    public static bool ValidateHookCode(int nCode)
}

public static class SettingsValidation
{
    // Settings-specific validation
    public static bool ValidateSettings(Settings settings, int minStrength, int maxStrength)
    public static bool IsValidHotkey(Keys key)
    public static bool ValidateStrengthValue(int strength, int min, int max)
    public static bool ValidateModeStates(bool jitterEnabled, bool recoilEnabled)
}
```

#### Validation Features
1. **Input Validation**
   - Parameter validation
   - Range checking
   - Null checks
   - Empty string prevention
   
2. **Settings Validation**
   - Configuration integrity
   - Hotkey validation
   - Mode state validation
   - Strength range validation
   
3. **Handle Validation**
   - Windows handle validation
   - Hook code validation
   - Resource validation

4. **Recovery Mechanisms**
   - Default value fallback
   - State preservation
   - Error reporting
   - Automatic recovery

### 5.4 Error Handling

#### 1. Validation Errors
```csharp
try
{
    Validation.ValidateStrength(strength, min, max, paramName);
}
catch (ArgumentOutOfRangeException ex)
{
    // Reset to default value
    strength = defaultValue;
    UpdateDebugInfo($"Reset to default strength: {ex.Message}");
}
```

#### 2. Runtime Errors
```csharp
try
{
    // Critical operation
}
catch (Exception ex)
{
    UpdateDebugInfo($"Error: {ex.Message}");
    // Cleanup and recovery
    CleanupResources();
    RestoreState();
}
```

#### 3. Resource Management
```csharp
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        // Cleanup resources
        jitterTimer?.Dispose();
        keyboardHookID = IntPtr.Zero;
        mouseHookID = IntPtr.Zero;
    }
    base.Dispose(disposing);
}
```

#### 4. Debug System
```csharp
private void UpdateDebugInfo(string message)
{
    if (debugLabel.InvokeRequired)
    {
        debugLabel.Invoke(new Action(() => UpdateDebugInfo(message)));
        return;
    }

    string timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
    string newLine = $"[{timestamp}] {message}";
    
    // Keep last 100 lines
    var lines = debugLabel.Lines.ToList();
    lines.Add(newLine);
    if (lines.Count > 100)
        lines.RemoveAt(0);
        
    debugLabel.Lines = lines.ToArray();
    debugLabel.SelectionStart = debugLabel.TextLength;
    debugLabel.ScrollToCaret();
}
```

### 6. Event Handler System

#### 6.1 Event Handler Manager
```csharp
public class EventHandlerManager : IDisposable
{
    private readonly Dictionary<string, List<Delegate>> eventHandlers;
    private readonly ConfigurationManager configManager;
    
    // Event registration methods
    public void RegisterControlEvents(Control control)
    public void UnregisterControlEvents(Control control)
    private void RegisterEventHandler(string eventName, Delegate handler)
    
    // Configuration event handlers
    private void OnConfigurationChanged(object sender, ConfigurationChangedEventArgs e)
    private void OnConfigurationValidating(object sender, ConfigurationValidationEventArgs e)
    private void OnConfigurationBackupCompleted(object sender, ConfigurationBackupEventArgs e)
}
```

#### 6.2 Event Handler Extensions
```csharp
public static class EventHandlerExtensions
{
    // Generic registration
    public static T RegisterEvents<T>(this T control, EventHandlerManager manager)
    public static T UnregisterEvents<T>(this T control, EventHandlerManager manager)
    
    // Control-specific registration
    public static TrackBar RegisterTrackBarEvents(...)
    public static CheckBox RegisterCheckBoxEvents(...)
    public static Button RegisterButtonEvents(...)
    public static TextBox RegisterTextBoxEvents(...)
}
```

#### 6.3 Event Categories
1. **Configuration Events**
   - Configuration changes
   - Validation events
   - Backup events

2. **Control Events**
   - TrackBar events (ValueChanged, Scroll)
   - CheckBox events (CheckedChanged)
   - Button events (Click, MouseDown, MouseUp)
   - TextBox events (TextChanged, KeyDown)

3. **System Events**
   - Window events
   - Application lifecycle events
   - Error events

#### 6.4 Event Handler Features
- Centralized event management
- Automatic cleanup on disposal
- Type-safe event registration
- Fluent API support
- Event tracking and logging
- Error handling and recovery

### 7. Project Structure Update
```
MouseMacro/
├── src/
│   ├── Configuration/           # Configuration system
│   │   ├── ConfigurationManager.cs
│   │   ├── AppConfiguration.cs
│   │   ├── ConfigurationEvents.cs
│   │   ├── EventHandlerManager.cs
│   │   └── EventHandlerExtensions.cs
│   ├── Controls/               # UI Controls
│   │   ├── ModernButton.cs
│   │   └── ModernTrackBar.cs
│   ├── MacroForm.cs           # Main form
│   ├── MacroForm.Designer.cs  # Form designer
│   └── Program.cs             # Entry point
```

## Macro Implementation Details

### 1. Core Macro Logic
- **Language**: C#
- **Primary Components**:
  - Recoil reduction system
  - Jitter pattern generation
  - State management
  - Timer-based execution

#### 1.1 Recoil Reduction System
- **Implementation**:
  ```csharp
  private void OnRecoilReductionTimer(object state)
  {
      if (IsRecoilReductionActive)
      {
          int strength = recoilReductionStrength.Value;
          int scaledStrength = CalculateScaledStrength(strength);
          SendInput.MoveMouse(0, scaledStrength);
      }
  }

  private int CalculateScaledStrength(int strength)
  {
      if (strength <= 6) // Tier 1
          return strength;
      else if (strength <= 13) // Tier 2
          return 6 + (strength - 6) * 2;
      else // Tier 3
          return 20 + (strength - 13) * 3;
  }
  ```
- **Features**:
  - Vertical movement compensation
  - Three-tier strength scaling system
  - Dynamic strength calculation
  - Optimized performance
  - Smooth movement patterns

#### 1.2 Jitter System
- **Pattern Definition**:
  ```csharp
  private readonly (int dx, int dy)[] jitterPattern = {
      (0, 6), (7, 7), (-7, -7), (7, -7), (-7, 7),
      (0, -6), (-6, 0), (6, 0), (5, 5), (-5, -5)
  };
  ```
- **Implementation**:
  ```csharp
  private void OnJitterTimer(object state)
  {
      if (IsJitterActive && currentPattern < jitterPattern.Length)
      {
          var (dx, dy) = jitterPattern[currentPattern];
          SendInput.MoveMouse(
              dx * jitterStrength.Value / 10,
              dy * jitterStrength.Value / 10
          );
          currentPattern = (currentPattern + 1) % jitterPattern.Length;
      }
  }
  ```
- **Features**:
  - Complex movement patterns
  - Pattern cycling
  - Strength scaling
  - Independent activation

### 2. State Management

#### 2.1 Activation States
```csharp
private bool IsRecoilReductionActive => 
    MacroEnabled && 
    (GetAsyncKeyState(VK_LBUTTON) < 0) && 
    (GetAsyncKeyState(VK_RBUTTON) < 0);

private bool IsJitterActive =>
    MacroEnabled && 
    (JitterEnabled || alwaysJitterMode) && 
    !alwaysRecoilReductionMode && 
    IsRecoilReductionActive;
```

#### 2.2 Mode Management
```csharp
private void ToggleMacroMode()
{
    // If either always mode is on, we can't switch modes
    if (alwaysJitterMode || alwaysRecoilReductionMode)
        return;

    // Toggle between jitter and recoil reduction modes
    jitterEnabled = !jitterEnabled;
    UpdateModeLabels();
}

private void UpdateModeLabels()
{
    lblJitterActive.Text = jitterEnabled || alwaysJitterMode ? "[Active]" : "";
    lblRecoilReductionActive.Text = !jitterEnabled || alwaysRecoilReductionMode ? "[Active]" : "";
}
```

#### 2.3 Toggle System
- **Keyboard Implementation**:
  ```csharp
  private IntPtr KeyboardProc(int nCode, IntPtr wParam, IntPtr lParam)
  {
      if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
      {
          var kb = (KBDLLHOOKSTRUCT)Marshal.PtrToStructure(lParam, typeof(KBDLLHOOKSTRUCT));
          if (kb.vkCode == ToggleKey)
          {
              MacroEnabled = !MacroEnabled;
              UpdateWindowTitle();
          }
      }
      return CallNextHookEx(KeyboardHook, nCode, wParam, lParam);
  }
  ```

- **Mouse Implementation**:
  ```csharp
  private IntPtr MouseProc(int nCode, IntPtr wParam, IntPtr lParam)
  {
      if (nCode >= 0)
      {
          var mouseData = (MSLLHOOKSTRUCT)Marshal.PtrToStructure(lParam, typeof(MSLLHOOKSTRUCT));
          if (wParam == (IntPtr)WM_XBUTTONDOWN)
          {
              int button = mouseData.mouseData >> 16;
              if (button == ToggleButton)
              {
                  MacroEnabled = !MacroEnabled;
                  UpdateWindowTitle();
              }
          }
      }
      return CallNextHookEx(MouseHook, nCode, wParam, lParam);
  }
  ```

### 3. Timer System

#### 3.1 Timer Configuration
```csharp
private readonly System.Windows.Forms.Timer recoilReductionTimer;
private readonly System.Windows.Forms.Timer jitterTimer;

private void InitializeTimers()
{
    recoilReductionTimer = new System.Windows.Forms.Timer
    {
        Interval = 16,  // ~60Hz
        Enabled = true
    };
    recoilReductionTimer.Tick += OnRecoilReductionTimer;

    jitterTimer = new System.Windows.Forms.Timer
    {
        Interval = 25,  // 40Hz
        Enabled = true
    };
    jitterTimer.Tick += OnJitterTimer;
}
```

#### 3.2 Performance Optimization
- **Timer Intervals**:
  - Recoil Reduction: 16ms (60Hz) for smooth movement
  - Jitter: 25ms (40Hz) for pattern execution
  - Balanced for performance and responsiveness

- **Resource Management**:
  ```csharp
  protected override void Dispose(bool disposing)
  {
      if (disposing)
      {
          recoilReductionTimer?.Dispose();
          jitterTimer?.Dispose();
      }
      base.Dispose(disposing);
  }
  ```

### 4. Input Simulation

#### 4.1 SendInput Implementation
```csharp
public static class SendInput
{
    [DllImport("user32.dll")]
    private static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

    public static void MoveMouse(int dx, int dy)
    {
        var input = new INPUT
        {
            type = INPUT_MOUSE,
            u = new InputUnion
            {
                mi = new MOUSEINPUT
                {
                    dx = dx,
                    dy = dy,
                    mouseData = 0,
                    dwFlags = MOUSEEVENTF_MOVE,
                    time = 0,
                    dwExtraInfo = IntPtr.Zero
                }
            }
        };

        SendInput(1, new[] { input }, Marshal.SizeOf(typeof(INPUT)));
    }
}
```

#### 4.2 Low-Level Hooks
```csharp
private const int WH_KEYBOARD_LL = 13;
private const int WH_MOUSE_LL = 14;

private IntPtr SetWindowsHookEx(int idHook, HookProc lpfn)
{
    using var curProcess = Process.GetCurrentProcess();
    using var curModule = curProcess.MainModule;
    return SetWindowsHookEx(idHook, lpfn, 
        GetModuleHandle(curModule.ModuleName), 0);
}
```

### 5. Debug System

#### 5.1 State Monitoring
```csharp
private void UpdateDebugInfo()
{
    if (debugTextBox.Visible)
    {
        var info = $"[{DateTime.Now:HH:mm:ss.fff}] " +
                   $"Macro: {(MacroEnabled ? "ON" : "OFF")} | " +
                   $"Recoil Reduction: {(IsRecoilReductionActive ? "Active" : "Inactive")} | " +
                   $"Jitter: {(IsJitterActive ? "Active" : "Inactive")} | " +
                   $"LMB: {(GetAsyncKeyState(VK_LBUTTON) < 0)} | " +
                   $"RMB: {(GetAsyncKeyState(VK_RBUTTON) < 0)}";
        
        debugTextBox.AppendText(info + Environment.NewLine);
    }
}
```

#### 5.2 Performance Monitoring
```csharp
private readonly Stopwatch perfTimer = new();
private void MeasurePerformance(Action action, string operation)
{
    if (debugTextBox.Visible)
    {
        perfTimer.Restart();
        action();
        perfTimer.Stop();
        
        UpdateDebugInfo($"{operation}: {perfTimer.ElapsedMilliseconds}ms");
    }
    else
    {
        action();
    }
}
```

## Build System

### Configurations
1. **Debug Build**
   - Location: `bin/Debug/net6.0-windows/`
   - Debug symbols and logging
   - Development features enabled
   
2. **Release Build**
   - Location: `bin/Release/net6.0-windows/`
   - Optimized performance
   - Production ready

### Build Process
- **Automated Script**: `build.bat`
  - Admin privilege elevation
  - Environment preparation
  - Dual configuration builds
  - Error handling

## Usage Guide

### Application Lifecycle
1. **Startup**
   - Admin rights elevation
   - Single instance check
   - System tray initialization

2. **Runtime**
   - Background operation
   - Resource optimization
   - State management
   
3. **Shutdown**
   - Clean termination
   - Resource cleanup
   - Settings preservation

### Troubleshooting
1. **Common Issues**
   - Instance conflicts
   - Admin privileges
   - Performance optimization
   - Resource management

2. **Debug Mode**
   - Real-time monitoring
   - Event logging
   - Performance metrics
   - Error tracking

## Performance Optimization
1. **Resource Management**
   - Efficient hook handling
   - Minimal GC impact
   - Handle management
   
2. **CPU Usage**
   - Timer optimization
   - Event throttling
   - Efficient state checks

## Security Considerations
1. **Process Protection**
   - Mutex implementation
   - Process name obfuscation
   
2. **Privilege Management**
   - Manifest-based elevation
   - Runtime privilege checks
   - Secure API access

## Maintenance
1. **Regular Updates**
   - Runtime compatibility
   - Security patches
   - Feature updates
   
2. **Code Maintenance**
   - Performance optimization
   - Security audits
   - Documentation updates
</file>

<file path="README.md">
# Notes & Tasks (Mouse Macro)

A professional Windows Forms application for advanced mouse input management, featuring recoil compensation and jitter pattern generation. IMPORTANT For professional system integration the application presents itself as "Notes&Tasks" and "NotesAndTasks" 😊.

## Features

- **Recoil Reduction System**
  - Advanced vertical compensation with three-tier scaling:
    - Tier 1 (1-6): Linear scaling with logarithmic base
    - Tier 2 (7-16): Enhanced scaling with 1.2x multiplier
    - Tier 3 (17-20): Exponential scaling with dynamic boost
  - Real-time strength adjustment (1-20)
  - Default strength: 1
  - Optimized movement patterns

- **Jitter System**
  - Complex 24-point movement pattern
  - Dynamic strength scaling (1-20)
  - Default strength: 3
  - Pattern cycling with smooth transitions
  - Optimized for performance

- **Mode Switching**
  - Intelligent mode toggling
  - Support for keyboard and mouse buttons (Mouse3-5)
  - Always mode options with validation
  - Real-time mode state tracking
  - Visual state indicators

- **Professional Integration**
  - Clean system tray integration
  - Modern dark theme UI
  - DPI-aware scaling
  - Single instance enforcement
  - Professional window management

- **Configuration Management System**
  - Thread-safe configuration handling
  - JSON-based settings storage
  - Automatic configuration backup
  - Comprehensive validation system:
    - Pre-save validation
    - Type validation
    - Range validation
    - Cross-property validation
  - Event-driven updates
  - Configuration sections:
    - Jitter settings
    - Recoil reduction settings
    - Hotkey bindings
    - UI preferences
    - Backup settings

- **Event Handler System**
  - Centralized event management
  - Automatic resource cleanup
  - Type-safe event registration
  - Fluent API for control events
  - Comprehensive error handling:
    - Exception tracking
    - State recovery
    - Debug logging
  - Event categories:
    - Configuration events
    - Control events
    - System events

- **Debug System**
  - Real-time state monitoring
  - Performance tracking
  - Event logging
  - Error tracking
  - Thread-safe logging

- **Settings Saved with JSON**
  - Settings saved automatically into a JSON file
  - JSON file located at the executable directory
  - Settings automatically saved while running the Application
  - Settings automatically loaded upon starting the Application

## Requirements

### Hardware
- Windows 10/11 compatible PC
- DirectX compatible display
- Mouse with standard buttons
- Keyboard for hotkey support

### Software
- Windows 10/11 (64-bit)
- .NET 6.0 Runtime
- Administrator privileges
- DirectX 9.0c or later

### Optional
- Multi-button mouse for extended features
- High refresh rate display (recommended)
- SSD for faster startup (recommended)

## Installation

1. **Download**
   - Get the latest release from the releases page
   - Choose between Debug and Release builds

2. **Setup**
   - Extract the files to your preferred location
   - No installation required (portable application)
   - Run `NotesAndTasks.exe` with administrator privileges

## Building from Source

### Method 1: Using Build Script
1. Clone the repository
2. Double-click `build.bat`
   - Script automatically requests admin rights
   - Builds both Debug and Release configurations

### Method 2: Manual Build
1. Open command prompt
2. Navigate to project directory
3. Run commands:
   ```cmd
   # Debug build
   dotnet build -c Debug

   # Release build
   dotnet build -c Release
   ```

### Output Locations
- Debug: `bin/Debug/net6.0-windows/NotesAndTasks.exe`
- Release: `bin/Release/net6.0-windows/NotesAndTasks.exe`

## Usage Guide

### Basic Controls
1. **Macro Toggle Key (Macro ON/OFF)**
   - Click "Set Toggle Key" button
   - Press any key to set as macro toggle
   - Default: 'Capital' key
   - Supports keyboard and mouse buttons (Mouse3-5)
   - LMB/RMB reserved for activation

2. **Mode Switch Key**
   - Click "Set Switch Key" button
   - Press any key to set as switch toggle
   - Default: 'Q' key
   - Supports keyboard and mouse buttons (Mouse3-5)
   - LMB/RMB reserved for activation

3. **Strength Adjustment**
   - Use slider to set strength (1-20)
   - Changes apply immediately
   - Recoil Reduction default: 1
   - Jitter default: 3

4. **Always Mode Options**
   - Always Jitter Mode: Locks to jitter
   - Always Recoil Reduction Mode: Locks to recoil reduction
   - Prevents mode switching while active

5. **System Tray**
   - Optional minimize to tray
   - Double-click tray icon to restore
   - Right-click for context menu
   - Clean exit via tray menu

### Usage Scenarios

#### 1. Dynamic Mode Switching
```
1. Press Toggle Key → Macro ON
2. Press Q to switch between modes
3. Hold LMB + RMB → Current mode activates
4. Release buttons → Effect stops
5. Press Q again → Switch to other mode
```

#### 2. Always Jitter Mode
```
1. Enable "Always Jitter Mode" checkbox
2. Press Toggle Key → Macro ON
3. Hold LMB + RMB → Jitter pattern active
4. Release buttons → Jitter stops
5. Q key has no effect (locked to jitter)
```

#### 3. Always Recoil Reduction Mode
```
1. Enable "Always Recoil Reduction Mode"
2. Press Toggle Key → Macro ON
3. Hold LMB + RMB → Recoil reduction active
4. Release buttons → Effect stops
5. Q key has no effect (locked to recoil reduction)
```

#### 4. Strength Optimization
```
1. Start with default strengths:
   - Recoil Reduction: 1
   - Jitter: 3
2. Test each mode
3. Adjust strength per mode as needed
4. Settings persist between mode switches
```

### Important Notes
- Effects ONLY activate when BOTH buttons are held
- Mode switch key (Q) works in real-time
- Always mode prevents accidental switching
- Each mode maintains its own strength setting
- Visual indicators show current active mode
- Window title reflects current state

### Settings Configuration
- **Configuration Manager**
  - Thread-safe operations with ReaderWriterLockSlim
  - Automatic backups with versioning
  - Real-time validation with error recovery
  - Event notifications with detailed state
  
- **Validation System**
  - Comprehensive input validation
  - Type safety checks
  - Range validation
  - Cross-property validation
  - Error reporting with context
  - Recovery mechanisms

- **Event System**
  - Configuration change tracking
  - Validation event handling
  - Backup completion notifications
  - Error event propagation
  - State change notifications

### Error Handling
- **Validation Errors**
  - Automatic recovery
  - Default value fallback
  - User notification
  - State preservation

- **Runtime Errors**
  - Exception handling
  - Resource cleanup
  - State recovery
  - Debug logging
  - User feedback

## Troubleshooting

### Common Issues

1. **"Another instance is running"**
   - Check Task Manager
   - End existing process if necessary
   - Restart application

2. **Admin Rights Required**
   - Run as administrator
   - Use build.bat for automatic elevation
   - Check app.manifest settings

3. **Performance Issues**
   - Switch to Release build
   - Check system resources
   - Adjust timer intervals
   - Monitor debug panel

## Development

### Environment Setup
1. Install Visual Studio 2022 or later
2. Install .NET 6.0 SDK
3. Clone repository
4. Open solution file

### Project Structure
```
MouseMacro/
├── assets/                  # Application resources
│   ├── logo.ico            # Application icon
├── bin/                    # Compiled binaries
│   ├── Debug/             # Debug build output
│   └── Release/           # Release build output
├── docs/                   # Documentation
│   ├── architecture.md    # Detailed architecture documentation
├── src/                   # Source code
│   ├── Configuration/     # Configuration system
│   │   ├── ConfigurationManager.cs
│   │   ├── AppConfiguration.cs
│   │   ├── ConfigurationEvents.cs
│   │   ├── EventHandlerManager.cs
│   │   ├── EventHandlerExtensions.cs
│   │   ├── SettingsValidation.cs
│   │   └── Validation.cs
│   ├── Controls/         # UI Controls
│   │   ├── ModernButton.cs
│   │   └── ModernTrackBar.cs
│   ├── MacroForm.cs      # Main form implementation
│   ├── MacroForm.Designer.cs
│   ├── NativeMethods.cs  # Windows API interop
│   ├── WinMessages.cs    # Windows message constants
│   └── Program.cs        # Application entry point
├── MouseMacro.csproj     # Project configuration
├── README.md             # Project documentation
└── app.manifest         # Application manifest
```

## Contributing
1. Fork the repository
2. Create feature branch
3. Commit changes
4. Submit pull request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- Windows Forms (.NET 6.0)
- Windows API (user32.dll)
- .NET Community
</file>

<file path="src/MacroForm.Designer.cs">
namespace NotesAndTasks
⋮----
partial class MacroForm
⋮----
/// <summary>
///  Required designer variable.
/// </summary>
⋮----
///  Clean up any resources being used.
⋮----
/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
protected override void Dispose(bool disposing)
⋮----
components.Dispose();
⋮----
jitterTimer.Change(Timeout.Infinite, Timeout.Infinite);
jitterTimer.Dispose();
⋮----
NativeMethods.UnhookWindowsHookEx(keyboardHookID);
⋮----
NativeMethods.UnhookWindowsHookEx(mouseHookID);
⋮----
notifyIcon.Dispose();
⋮----
toolTip.Dispose();
⋮----
base.Dispose(disposing);
⋮----
///  Required method for Designer support - do not modify
///  the contents of this method with the code editor.
⋮----
private void InitializeComponent()
⋮----
mainPanel = new Panel();
debugPanel = new Panel();
debugLabel = new TextBox();
btnToggleDebug = new ModernButton();
strengthPanel1 = new Panel();
lblRecoilReductionStrengthValue = new Label();
lblRecoilReductionStrengthPrefix = new Label();
trackBarRecoilReduction = new ModernTrackBar();
lblRecoilReductionActive = new Label();
strengthPanel2 = new Panel();
lblJitterStrengthValue = new Label();
lblJitterStrengthPrefix = new Label();
trackBarJitter = new ModernTrackBar();
lblJitterActive = new Label();
settingsPanel = new Panel();
lblCurrentKeyValue = new Label();
lblCurrentKeyPrefix = new Label();
btnSetKey = new ModernButton();
chkMinimizeToTray = new CheckBox();
lblMacroSwitchKeyValue = new Label();
btnSetMacroSwitch = new ModernButton();
lblMacroSwitchKeyPrefix = new Label();
chkAlwaysJitter = new CheckBox();
chkAlwaysRecoilReduction = new CheckBox();
notifyIcon = new NotifyIcon(components);
trayContextMenu = new ContextMenuStrip(components);
showWindowMenuItem = new ToolStripMenuItem();
exitMenuItem = new ToolStripMenuItem();
mainPanel.SuspendLayout();
debugPanel.SuspendLayout();
strengthPanel1.SuspendLayout();
((System.ComponentModel.ISupportInitialize)trackBarRecoilReduction).BeginInit();
strengthPanel2.SuspendLayout();
((System.ComponentModel.ISupportInitialize)trackBarJitter).BeginInit();
settingsPanel.SuspendLayout();
trayContextMenu.SuspendLayout();
⋮----
//
// mainPanel
⋮----
mainPanel.BackColor = Color.FromArgb(16, 2, 31);
mainPanel.Controls.Add(debugPanel);
mainPanel.Controls.Add(btnToggleDebug);
mainPanel.Controls.Add(strengthPanel1);
mainPanel.Controls.Add(strengthPanel2);
mainPanel.Controls.Add(settingsPanel);
mainPanel.Controls.Add(chkAlwaysJitter);
mainPanel.Controls.Add(chkAlwaysRecoilReduction);
mainPanel.Location = new Point(0, 0);
mainPanel.Margin = new Padding(3, 2, 3, 2);
⋮----
mainPanel.Padding = new Padding(14, 12, 14, 12);
mainPanel.Size = new Size(477, 676);
⋮----
// debugPanel
⋮----
debugPanel.BackColor = Color.FromArgb(214, 37, 106);
⋮----
debugPanel.Controls.Add(debugLabel);
debugPanel.Location = new Point(20, 541);
debugPanel.Margin = new Padding(3, 2, 3, 2);
⋮----
debugPanel.Padding = new Padding(7, 6, 7, 6);
debugPanel.Size = new Size(438, 124);
⋮----
// debugLabel
⋮----
debugLabel.BackColor = Color.FromArgb(16, 2, 31);
⋮----
debugLabel.Font = new Font("JetBrains Mono", 9.75F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
debugLabel.Location = new Point(7, 6);
debugLabel.Margin = new Padding(3, 2, 3, 2);
⋮----
debugLabel.Size = new Size(422, 110);
⋮----
// btnToggleDebug
⋮----
btnToggleDebug.BackColor = Color.FromArgb(30, 1, 62);
btnToggleDebug.BorderColor = Color.FromArgb(250, 91, 101);
⋮----
btnToggleDebug.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
btnToggleDebug.HoverBackColor = Color.FromArgb(214, 37, 106);
btnToggleDebug.Location = new Point(21, 495);
btnToggleDebug.Margin = new Padding(0, 0, 0, 12);
⋮----
btnToggleDebug.Size = new Size(437, 35);
⋮----
// strengthPanel1
⋮----
strengthPanel1.Controls.Add(lblRecoilReductionStrengthValue);
strengthPanel1.Controls.Add(lblRecoilReductionStrengthPrefix);
strengthPanel1.Controls.Add(trackBarRecoilReduction);
strengthPanel1.Controls.Add(lblRecoilReductionActive);
strengthPanel1.Location = new Point(20, 225);
strengthPanel1.Margin = new Padding(0, 0, 0, 12);
⋮----
strengthPanel1.Size = new Size(438, 84);
⋮----
// lblRecoilReductionStrengthValue
⋮----
lblRecoilReductionStrengthValue.Font = new Font("JetBrains Mono", 10F, FontStyle.Bold, GraphicsUnit.Point);
⋮----
lblRecoilReductionStrengthValue.Location = new Point(212, 6);
lblRecoilReductionStrengthValue.Margin = new Padding(0);
⋮----
lblRecoilReductionStrengthValue.Size = new Size(16, 18);
⋮----
// lblRecoilReductionStrengthPrefix
⋮----
lblRecoilReductionStrengthPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
lblRecoilReductionStrengthPrefix.Location = new Point(0, 6);
lblRecoilReductionStrengthPrefix.Margin = new Padding(0);
⋮----
lblRecoilReductionStrengthPrefix.Size = new Size(216, 18);
⋮----
// trackBarRecoilReduction
⋮----
trackBarRecoilReduction.Location = new Point(0, 37);
trackBarRecoilReduction.Margin = new Padding(0);
⋮----
trackBarRecoilReduction.Size = new Size(438, 45);
⋮----
trackBarRecoilReduction.ThumbColor = Color.FromArgb(255, 255, 255);
trackBarRecoilReduction.TickColor = Color.FromArgb(250, 91, 101);
trackBarRecoilReduction.TrackColor = Color.FromArgb(214, 37, 106);
⋮----
// lblRecoilReductionActive (RecoilReduction Active Label)
⋮----
lblRecoilReductionActive.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
lblRecoilReductionActive.ForeColor = Color.FromArgb(250, 91, 101);
lblRecoilReductionActive.Location = new Point(350, 5);
⋮----
lblRecoilReductionActive.Size = new Size(0, 20);
⋮----
// strengthPanel2
⋮----
strengthPanel2.Controls.Add(lblJitterStrengthValue);
strengthPanel2.Controls.Add(lblJitterStrengthPrefix);
strengthPanel2.Controls.Add(trackBarJitter);
strengthPanel2.Controls.Add(lblJitterActive);
strengthPanel2.Location = new Point(20, 331);
strengthPanel2.Margin = new Padding(0, 0, 0, 12);
⋮----
strengthPanel2.Size = new Size(438, 81);
⋮----
// lblJitterStrengthValue
⋮----
lblJitterStrengthValue.Font = new Font("JetBrains Mono", 10F, FontStyle.Bold, GraphicsUnit.Point);
⋮----
lblJitterStrengthValue.Location = new Point(132, 6);
lblJitterStrengthValue.Margin = new Padding(0);
⋮----
lblJitterStrengthValue.Size = new Size(16, 18);
⋮----
// lblJitterStrengthPrefix
⋮----
lblJitterStrengthPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
lblJitterStrengthPrefix.Location = new Point(0, 6);
lblJitterStrengthPrefix.Margin = new Padding(0);
⋮----
lblJitterStrengthPrefix.Size = new Size(144, 18);
⋮----
// trackBarJitter
⋮----
trackBarJitter.Location = new Point(0, 34);
trackBarJitter.Margin = new Padding(0);
⋮----
trackBarJitter.Size = new Size(438, 45);
⋮----
trackBarJitter.ThumbColor = Color.FromArgb(255, 255, 255);
trackBarJitter.TickColor = Color.FromArgb(250, 91, 101);
trackBarJitter.TrackColor = Color.FromArgb(214, 37, 106);
⋮----
// lblJitterActive (Jitter Active Label)
⋮----
lblJitterActive.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
lblJitterActive.ForeColor = Color.FromArgb(250, 91, 101);
lblJitterActive.Location = new Point(350, 5);
⋮----
lblJitterActive.Size = new Size(0, 20);
⋮----
// settingsPanel
⋮----
settingsPanel.Controls.Add(lblCurrentKeyValue);
settingsPanel.Controls.Add(lblCurrentKeyPrefix);
settingsPanel.Controls.Add(btnSetKey);
settingsPanel.Controls.Add(chkMinimizeToTray);
settingsPanel.Controls.Add(lblMacroSwitchKeyValue);
settingsPanel.Controls.Add(btnSetMacroSwitch);
settingsPanel.Controls.Add(lblMacroSwitchKeyPrefix);
settingsPanel.Location = new Point(20, 25);
settingsPanel.Margin = new Padding(0, 0, 0, 12);
⋮----
settingsPanel.Size = new Size(438, 179);
⋮----
// lblCurrentKeyValue
⋮----
lblCurrentKeyValue.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Bold, GraphicsUnit.Point);
⋮----
lblCurrentKeyValue.Location = new Point(141, 22);
lblCurrentKeyValue.Margin = new Padding(0);
⋮----
lblCurrentKeyValue.Size = new Size(64, 18);
⋮----
// lblCurrentKeyPrefix
⋮----
lblCurrentKeyPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
lblCurrentKeyPrefix.Location = new Point(0, 21);
lblCurrentKeyPrefix.Margin = new Padding(0);
⋮----
lblCurrentKeyPrefix.Size = new Size(144, 18);
⋮----
// btnSetKey
⋮----
btnSetKey.BackColor = Color.FromArgb(30, 1, 62);
btnSetKey.BorderColor = Color.FromArgb(250, 91, 101);
⋮----
btnSetKey.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
btnSetKey.HoverBackColor = Color.FromArgb(214, 37, 106);
btnSetKey.Location = new Point(1, 49);
btnSetKey.Margin = new Padding(0, 0, 0, 12);
⋮----
btnSetKey.Size = new Size(437, 35);
⋮----
// chkMinimizeToTray
⋮----
chkMinimizeToTray.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
chkMinimizeToTray.Location = new Point(280, 3);
chkMinimizeToTray.Margin = new Padding(3, 2, 3, 2);
⋮----
chkMinimizeToTray.Size = new Size(155, 22);
⋮----
// lblMacroSwitchKeyValue
⋮----
lblMacroSwitchKeyValue.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Bold, GraphicsUnit.Point);
⋮----
lblMacroSwitchKeyValue.Location = new Point(148, 105);
⋮----
lblMacroSwitchKeyValue.Size = new Size(20, 19);
⋮----
// btnSetMacroSwitch
⋮----
btnSetMacroSwitch.BackColor = Color.FromArgb(30, 1, 62);
btnSetMacroSwitch.BorderColor = Color.FromArgb(250, 91, 101);
⋮----
btnSetMacroSwitch.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
btnSetMacroSwitch.HoverBackColor = Color.FromArgb(214, 37, 106);
btnSetMacroSwitch.Location = new Point(1, 133);
btnSetMacroSwitch.Margin = new Padding(0, 0, 0, 12);
⋮----
btnSetMacroSwitch.Size = new Size(437, 35);
⋮----
// lblMacroSwitchKeyPrefix
⋮----
lblMacroSwitchKeyPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
lblMacroSwitchKeyPrefix.Location = new Point(0, 106);
⋮----
lblMacroSwitchKeyPrefix.Size = new Size(152, 18);
⋮----
// chkAlwaysJitter
⋮----
chkAlwaysJitter.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
chkAlwaysJitter.Location = new Point(24, 459);
chkAlwaysJitter.Margin = new Padding(3, 2, 3, 2);
⋮----
chkAlwaysJitter.Size = new Size(171, 22);
⋮----
// chkAlwaysRecoilReduction
⋮----
chkAlwaysRecoilReduction.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
⋮----
chkAlwaysRecoilReduction.Location = new Point(24, 429);
chkAlwaysRecoilReduction.Margin = new Padding(3, 2, 3, 2);
⋮----
chkAlwaysRecoilReduction.Size = new Size(251, 22);
⋮----
// notifyIcon
⋮----
// trayContextMenu
⋮----
trayContextMenu.Items.AddRange(new ToolStripItem[] { showWindowMenuItem, exitMenuItem });
⋮----
trayContextMenu.Size = new Size(151, 48);
⋮----
// showWindowMenuItem
⋮----
showWindowMenuItem.Size = new Size(150, 22);
⋮----
// exitMenuItem
⋮----
exitMenuItem.Size = new Size(150, 22);
⋮----
// MacroForm
⋮----
AutoScaleDimensions = new SizeF(7F, 15F);
⋮----
BackColor = Color.FromArgb(30, 30, 30);
ClientSize = new Size(477, 676);
Controls.Add(mainPanel);
Margin = new Padding(3, 2, 3, 2);
MinimumSize = new Size(493, 422);
⋮----
mainPanel.ResumeLayout(false);
mainPanel.PerformLayout();
debugPanel.ResumeLayout(false);
debugPanel.PerformLayout();
strengthPanel1.ResumeLayout(false);
strengthPanel1.PerformLayout();
((System.ComponentModel.ISupportInitialize)trackBarRecoilReduction).EndInit();
strengthPanel2.ResumeLayout(false);
strengthPanel2.PerformLayout();
((System.ComponentModel.ISupportInitialize)trackBarJitter).EndInit();
settingsPanel.ResumeLayout(false);
settingsPanel.PerformLayout();
trayContextMenu.ResumeLayout(false);
⋮----
private ModernButton btnSetKey;
⋮----
private ModernTrackBar trackBarJitter;
⋮----
private ModernTrackBar trackBarRecoilReduction;
⋮----
private ModernButton btnToggleDebug;
⋮----
private ModernButton btnSetMacroSwitch;
</file>

<file path="src/MacroForm.cs">
namespace NotesAndTasks
⋮----
/// <summary>
/// Main form for the Notes&Tasks application that provides mouse input management functionality.
/// This form handles both jitter and recoil reduction features with configurable hotkeys and settings.
/// </summary>
/// <remarks>
/// The form implements two main features:
/// 1. Jitter - Applies a complex movement pattern to the mouse cursor
/// 2. Recoil Reduction - Provides vertical compensation with configurable strength
///
/// Both features are activated when left and right mouse buttons are held simultaneously.
/// The application can be minimized to the system tray and supports various hotkeys for control.
/// </remarks>
public partial class MacroForm : Form
⋮----
private IntPtr keyboardHookID = IntPtr.Zero;
private IntPtr mouseHookID = IntPtr.Zero;
⋮----
private readonly ToolTip toolTip;
⋮----
/// Defines the types of input that can be used to toggle the macro functionality.
⋮----
/// <summary>Keyboard key input</summary>
⋮----
/// <summary>Middle mouse button input</summary>
⋮----
/// <summary>Mouse button 4 (XButton1) input</summary>
⋮----
/// <summary>Mouse button 5 (XButton2) input</summary>
⋮----
// Surpress warnings as first time build might not know about these
⋮----
private ToggleType currentToggleType = ToggleType.Keyboard;
private Keys toggleKey = Keys.Capital;  // Default to Capital
private Keys macroSwitchKey = Keys.Q;  // Default to Q
⋮----
private int jitterStrength = 3;  // Default to 3
private int recoilReductionStrength = 1;  // Default to 1
⋮----
private Keys currentMacroKey = Keys.Capital;  // Default to Caps Lock
private Keys currentSwitchKey = Keys.Q;      // Default to Q
⋮----
/// Initializes a new instance of the MacroForm class.
/// Sets up all necessary components, hooks, and event handlers.
⋮----
toolTip = new ToolTip();
⋮----
// Initialize tray icon behavior
⋮----
// Handle application exit
⋮----
MessageBox.Show($"Error initializing form: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
⋮----
/// Handles the form closing event. If minimize to tray is enabled,
/// the form will be hidden instead of closed when the user clicks the close button.
⋮----
/// <param name="sender">The source of the event.</param>
/// <param name="e">Event data containing the close reason and cancellation option.</param>
private void OnFormClosingHandler(object sender, FormClosingEventArgs e)
⋮----
this.Hide();
⋮----
// Cleanup when actually closing
⋮----
/// Handles form resize events by ensuring proper layout of controls.
⋮----
/// <param name="e">Event data.</param>
private void OnResizeHandler(object sender, EventArgs e)
⋮----
// Let the anchor properties handle control resizing
mainPanel.PerformLayout();
this.PerformLayout();
⋮----
/// Handles the form load event by initializing hooks and timers.
⋮----
private void OnLoadHandler(object sender, EventArgs e)
⋮----
/// Initializes custom components including icons, hotkeys, tooltips, and loads saved settings.
⋮----
private void InitializeCustomComponents()
⋮----
// Set initial text with bold formatting
⋮----
UpdateCurrentKey(currentMacroKey.ToString());
⋮----
UpdateSwitchKey(currentSwitchKey.ToString());
⋮----
// Initialize event handlers
⋮----
/// Initializes all event handlers for form controls.
/// Sets up click events, value change events, and checkbox state change events.
⋮----
private void InitializeEventHandlers()
⋮----
Validation.ValidateStrength(trackBarJitter.Value, trackBarJitter.Minimum, trackBarJitter.Maximum, nameof(trackBarJitter.Value));
⋮----
SettingsManager.SaveSettings();
⋮----
trackBarJitter.Value = Math.Max(trackBarJitter.Minimum, Math.Min(trackBarJitter.Maximum, jitterStrength));
⋮----
Validation.ValidateStrength(trackBarRecoilReduction.Value, trackBarRecoilReduction.Minimum, trackBarRecoilReduction.Maximum, nameof(trackBarRecoilReduction.Value));
⋮----
trackBarRecoilReduction.Value = Math.Max(trackBarRecoilReduction.Minimum, Math.Min(trackBarRecoilReduction.Maximum, recoilReductionStrength));
⋮----
/// Loads saved settings from the settings manager and applies them to the form.
/// Validates all settings before applying them and falls back to defaults if validation fails.
⋮----
private void LoadSettings()
⋮----
Validation.ValidateNotNull(settings, nameof(settings));
⋮----
// Validate all settings before applying them
if (!SettingsValidation.ValidateSettings(settings,
Math.Min(trackBarJitter.Minimum, trackBarRecoilReduction.Minimum),
Math.Max(trackBarJitter.Maximum, trackBarRecoilReduction.Maximum)))
⋮----
// Apply validated settings
⋮----
// Load and validate hotkeys
if (!string.IsNullOrEmpty(settings.MacroToggleKey))
⋮----
currentMacroKey = (Keys)Enum.Parse(typeof(Keys), settings.MacroToggleKey);
if (!SettingsValidation.IsValidHotkey(currentMacroKey))
⋮----
if (!string.IsNullOrEmpty(settings.ModeSwitchKey))
⋮----
currentSwitchKey = (Keys)Enum.Parse(typeof(Keys), settings.ModeSwitchKey);
if (!SettingsValidation.IsValidHotkey(currentSwitchKey))
⋮----
// Update UI
⋮----
/// Saves current settings to persistent storage through the settings manager.
/// Validates settings before saving to ensure data integrity.
⋮----
private void SaveCurrentSettings()
⋮----
// Update settings object with current values
⋮----
settings.MacroToggleKey = currentMacroKey.ToString();
settings.ModeSwitchKey = currentSwitchKey.ToString();
⋮----
// Validate settings before saving
⋮----
throw new InvalidOperationException("Settings validation failed");
⋮----
// Save validated settings
⋮----
// Consider showing a message box to the user here
MessageBox.Show(
⋮----
/// Resets all settings to their default values.
/// Called when settings loading fails or when invalid settings are detected.
⋮----
private void ResetToDefaultSettings()
⋮----
// Reset strength values
⋮----
// Reset mode states
⋮----
// Reset UI preferences
⋮----
// Reset hotkeys
⋮----
// Save default settings
⋮----
/// Initializes low-level keyboard and mouse hooks for input monitoring.
⋮----
/// <exception cref="InvalidOperationException">Thrown when hook initialization fails.</exception>
private void InitializeHooks()
⋮----
using var curProcess = Process.GetCurrentProcess();
⋮----
Validation.ValidateNotNull(curModule, nameof(curModule));
⋮----
Validation.ValidateStringNotNullOrEmpty(moduleName, nameof(moduleName));
⋮----
IntPtr moduleHandle = NativeMethods.GetModuleHandle(moduleName);
Validation.ValidateHandle(moduleHandle, nameof(moduleHandle));
⋮----
keyboardHookID = NativeMethods.SetWindowsHookEx(WinMessages.WH_KEYBOARD_LL, keyboardProc,
⋮----
Validation.ValidateHandle(keyboardHookID, "keyboardHookID");
⋮----
mouseHookID = NativeMethods.SetWindowsHookEx(WinMessages.WH_MOUSE_LL, mouseProc,
⋮----
Validation.ValidateHandle(mouseHookID, "mouseHookID");
⋮----
/// Callback function for the low-level mouse hook.
/// Handles mouse button events and manages macro activation states.
⋮----
/// <param name="nCode">Hook code; if less than zero, the hook procedure must pass the message to CallNextHookEx.</param>
/// <param name="wParam">Message identifier.</param>
/// <param name="lParam">Pointer to a MSLLHOOKSTRUCT structure.</param>
/// <returns>If nCode is less than zero, the hook procedure must return the value returned by CallNextHookEx.</returns>
private IntPtr MouseHookCallback(int nCode, IntPtr wParam, IntPtr lParam)
⋮----
if (Validation.ValidateHookCode(nCode))
⋮----
return NativeMethods.CallNextHookEx(mouseHookID, nCode, wParam, lParam);
⋮----
/// Callback function for the low-level keyboard hook.
/// Handles keyboard events for macro toggling and mode switching.
⋮----
/// <param name="lParam">Pointer to a KBDLLHOOKSTRUCT structure.</param>
⋮----
private IntPtr KeyboardHookCallback(int nCode, IntPtr wParam, IntPtr lParam)
⋮----
var vkCode = Marshal.ReadInt32(lParam);
⋮----
UpdateMacroSwitchKey(currentSwitchKey.ToString());
⋮----
return NativeMethods.CallNextHookEx(keyboardHookID, nCode, wParam, lParam);
⋮----
/// Checks and updates the jitter/recoil reduction state based on mouse button states.
/// Activates or deactivates the jitter timer based on current conditions.
⋮----
private void CheckJitterState()
⋮----
// Always require both mouse buttons
⋮----
jitterTimer.Change(0, 10);
⋮----
// Use alwaysJitterMode/alwaysRecoilReductionMode to determine which macro to run
⋮----
jitterTimer.Change(Timeout.Infinite, 10);
⋮----
/// Timer callback that handles mouse movement for both jitter and recoil reduction modes.
/// Includes comprehensive validation of movement parameters and state.
⋮----
/// <param name="state">State object (not used).</param>
private void OnJitterTimer(object state)
⋮----
// Validate current state
⋮----
// Validate mouse button state
⋮----
// Validate jitter pattern index
⋮----
// Validate and apply jitter strength
⋮----
Validation.ValidateStrength(jitterStrength, 1, 20, nameof(jitterStrength));
⋮----
// Use default strength if current value is invalid
⋮----
// Validate recoil reduction strength
⋮----
Validation.ValidateStrength(recoilReductionStrength, 1, 20, nameof(recoilReductionStrength));
⋮----
input.mi.dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * 0.3));
⋮----
input.mi.dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * Math.Log(recoilReductionStrength + 1, logBase)));
⋮----
input.mi.dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * recoilReductionStrength * 1.2));
⋮----
input.mi.dy = Math.Max(1, (int)Math.Round(
⋮----
Math.Pow(scalingFactor, recoilReductionStrength - 13) *
Math.Pow(exponentialBoost, (recoilReductionStrength - 13) / 2)
⋮----
// Validate final movement values
if (Math.Abs(input.mi.dx) > 100 || Math.Abs(input.mi.dy) > 100)
⋮----
NativeMethods.SendInput(1, ref input, Marshal.SizeOf(input));
⋮----
// Stop the timer on critical errors
⋮----
catch { /* Ignore cleanup errors */ }
⋮----
/// Updates the form title to reflect current macro state and mode.
⋮----
private void UpdateTitle()
⋮----
/// Updates the displayed current key binding for macro toggle.
⋮----
/// <param name="key">The key name to display.</param>
private void UpdateCurrentKey(string key)
⋮----
/// Updates the displayed key binding for mode switching.
⋮----
private void UpdateSwitchKey(string key)
⋮----
/// Updates the displayed jitter strength value.
/// Thread-safe method that can be called from any thread.
⋮----
/// <param name="strength">The strength value to display (1-20).</param>
private void UpdateJitterStrength(int strength)
⋮----
Validation.ValidateStrength(strength, trackBarJitter.Minimum, trackBarJitter.Maximum, nameof(strength));
⋮----
lblJitterStrengthValue.Text = strength.ToString();
⋮----
/// Updates the displayed recoil reduction strength value.
⋮----
private void UpdateRecoilReductionStrength(int strength)
⋮----
Validation.ValidateStrength(strength, trackBarRecoilReduction.Minimum, trackBarRecoilReduction.Maximum, nameof(strength));
⋮----
lblRecoilReductionStrengthValue.Text = strength.ToString();
⋮----
/// Updates the displayed macro switch key value.
⋮----
private void UpdateMacroSwitchKey(string key)
⋮----
/// Adds a debug message to the debug panel with timestamp.
⋮----
/// <param name="message">The debug message to display.</param>
private void UpdateDebugInfo(string message)
⋮----
debugLabel.Invoke(new Action(() => UpdateDebugInfo(message)));
⋮----
string timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
⋮----
// Keep last 100 lines of debug info
var lines = debugLabel.Lines.ToList();
lines.Add(newLine);
⋮----
lines.RemoveAt(0);
⋮----
debugLabel.Lines = lines.ToArray();
⋮----
// Auto-scroll to bottom
⋮----
debugLabel.ScrollToCaret();
⋮----
/// Shows and activates the main window when restored from system tray.
⋮----
private void ShowWindow()
⋮----
this.Show();
⋮----
this.Activate();
⋮----
/// Performs cleanup and exits the application.
/// Ensures all resources are properly disposed and hooks are unregistered.
⋮----
private void CleanupAndExit()
⋮----
// Use Dispose pattern for cleanup
this.Dispose();
⋮----
Debug.WriteLine($"Error during cleanup: {ex.Message}");
⋮----
// Force process to exit
⋮----
using (var process = Process.GetCurrentProcess())
⋮----
process.Kill();
⋮----
Environment.Exit(0);
⋮----
/// Toggles the macro on/off state and updates the UI accordingly.
⋮----
private void ToggleMacro()
⋮----
/// Handles switching between jitter and recoil reduction modes.
/// Only works when neither "Always" mode is enabled.
/// Validates mode state before switching.
⋮----
private void HandleModeSwitch()
⋮----
// Don't switch if either "Always" mode is enabled
⋮----
// Toggle between jitter and recoil reduction with validation
⋮----
// Validate the new state
⋮----
// Invalid state detected, revert changes
⋮----
// Save the new state
⋮----
// Revert changes if settings save fails
⋮----
/// Updates the active mode labels in the UI.
⋮----
private void UpdateModeLabels()
⋮----
Invoke(new Action(UpdateModeLabels));
⋮----
private void lblJitterActive_Click(object sender, EventArgs e)
⋮----
private void lblCurrentKeyPrefix_Click(object sender, EventArgs e)
⋮----
private void strengthPanel2_Paint(object sender, PaintEventArgs e)
⋮----
// This is an empty Paint event handler for strengthPanel2
⋮----
protected override void OnFormClosing(FormClosingEventArgs e)
⋮----
base.OnFormClosing(e);
⋮----
/// Initializes the application icon for both the main window and system tray.
⋮----
private void InitializeIcon()
⋮----
using var icon = Icon.ExtractAssociatedIcon(Application.ExecutablePath);
⋮----
this.Icon = (Icon)icon.Clone();
notifyIcon.Icon = (Icon)icon.Clone();
⋮----
/// Initializes default hotkey bindings and updates the UI to reflect them.
⋮----
private void InitializeHotkeys()
⋮----
// Initialize default hotkeys
⋮----
/// Initializes tooltips for various UI controls to provide user guidance.
⋮----
private void InitializeTooltips()
⋮----
// Initialize tooltips for controls using the managed ToolTip instance
toolTip.SetToolTip(chkAlwaysJitter, "Always keep Jitter enabled");
toolTip.SetToolTip(trackBarJitter, "Adjust Jitter strength");
toolTip.SetToolTip(chkAlwaysRecoilReduction, "Always keep Recoil Reduction enabled");
toolTip.SetToolTip(trackBarRecoilReduction, "Adjust Recoil Reduction strength");
toolTip.SetToolTip(chkMinimizeToTray, "Minimize to system tray when closing");
⋮----
private void chkMinimizeToTray_CheckedChanged(object sender, EventArgs e)
</file>

</files>
</file>

<file path="buildCommand.md">
# Batch (CMD)
dotnet clean && rmdir /s /q bin obj && dotnet restore && dotnet build -c Debug && dotnet build -c Release

# PowerShell
dotnet clean; Remove-Item -Recurse -Force bin,obj; dotnet restore; dotnet build -c Debug; dotnet build -c Release
</file>

<file path="MouseMacro.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35818.85 d17.13
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MouseMacro", "MouseMacro.csproj", "{1FFAD009-1089-42F1-C326-6CC678F746BF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E2EE0FEB-3FDA-4BFB-A0AF-B207C69E2C25}
	EndGlobalSection
EndGlobal
</file>

<file path="Properties/Resources.Designer.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NotesTasks.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("NotesTasks.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
</file>

<file path="Properties/Resources.resx">
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
</file>

<file path="src/Configuration/AppConfiguration.cs">
using System;
using System.Drawing;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Root configuration class that contains all application settings.
    /// </summary>
    public class AppConfiguration : ICloneable
    {
        public JitterConfiguration JitterSettings { get; set; }
        public RecoilConfiguration RecoilSettings { get; set; }
        public HotkeyConfiguration HotkeySettings { get; set; }
        public UIConfiguration UISettings { get; set; }
        public BackupConfiguration BackupSettings { get; set; }

        public object Clone()
        {
            return new AppConfiguration
            {
                JitterSettings = (JitterConfiguration)JitterSettings?.Clone(),
                RecoilSettings = (RecoilConfiguration)RecoilSettings?.Clone(),
                HotkeySettings = (HotkeyConfiguration)HotkeySettings?.Clone(),
                UISettings = (UIConfiguration)UISettings?.Clone(),
                BackupSettings = (BackupConfiguration)BackupSettings?.Clone()
            };
        }
    }

    /// <summary>
    /// Configuration settings for the jitter functionality.
    /// </summary>
    public class JitterConfiguration : ICloneable
    {
        public int Strength { get; set; }
        public bool IsEnabled { get; set; }
        public bool AlwaysEnabled { get; set; }

        public object Clone()
        {
            return new JitterConfiguration
            {
                Strength = Strength,
                IsEnabled = IsEnabled,
                AlwaysEnabled = AlwaysEnabled
            };
        }
    }

    /// <summary>
    /// Configuration settings for the recoil reduction functionality.
    /// </summary>
    public class RecoilConfiguration : ICloneable
    {
        public int Strength { get; set; }
        public bool IsEnabled { get; set; }
        public bool AlwaysEnabled { get; set; }

        public object Clone()
        {
            return new RecoilConfiguration
            {
                Strength = Strength,
                IsEnabled = IsEnabled,
                AlwaysEnabled = AlwaysEnabled
            };
        }
    }

    /// <summary>
    /// Configuration settings for hotkeys.
    /// </summary>
    public class HotkeyConfiguration : ICloneable
    {
        public string MacroToggleKey { get; set; }
        public string ModeSwitchKey { get; set; }

        public object Clone()
        {
            return new HotkeyConfiguration
            {
                MacroToggleKey = MacroToggleKey,
                ModeSwitchKey = ModeSwitchKey
            };
        }
    }

    /// <summary>
    /// Configuration settings for the user interface.
    /// </summary>
    public class UIConfiguration : ICloneable
    {
        public bool MinimizeToTray { get; set; }
        public bool ShowDebugPanel { get; set; }
        public Point WindowPosition { get; set; }
        public Size WindowSize { get; set; }

        public object Clone()
        {
            return new UIConfiguration
            {
                MinimizeToTray = MinimizeToTray,
                ShowDebugPanel = ShowDebugPanel,
                WindowPosition = new Point(WindowPosition.X, WindowPosition.Y),
                WindowSize = new Size(WindowSize.Width, WindowSize.Height)
            };
        }
    }

    /// <summary>
    /// Configuration settings for backup functionality.
    /// </summary>
    public class BackupConfiguration : ICloneable
    {
        public bool AutoBackupEnabled { get; set; }
        public int BackupIntervalHours { get; set; }
        public int MaxBackupCount { get; set; }
        public string BackupDirectory { get; set; }

        public object Clone()
        {
            return new BackupConfiguration
            {
                AutoBackupEnabled = AutoBackupEnabled,
                BackupIntervalHours = BackupIntervalHours,
                MaxBackupCount = MaxBackupCount,
                BackupDirectory = BackupDirectory
            };
        }
    }
}
</file>

<file path="src/Configuration/ConfigurationEvents.cs">
using System;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Event arguments for configuration change events.
    /// </summary>
    public class ConfigurationChangedEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the configuration section that was changed.
        /// </summary>
        public string Section { get; }

        /// <summary>
        /// Gets the previous configuration state.
        /// </summary>
        public AppConfiguration PreviousConfig { get; }

        /// <summary>
        /// Gets the new configuration state.
        /// </summary>
        public AppConfiguration NewConfig { get; }

        public ConfigurationChangedEventArgs(string section, AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            Section = section;
            PreviousConfig = previousConfig;
            NewConfig = newConfig;
        }
    }

    /// <summary>
    /// Event arguments for configuration validation events.
    /// </summary>
    public class ConfigurationValidationEventArgs : EventArgs
    {
        /// <summary>
        /// Gets or sets whether the configuration is valid.
        /// </summary>
        public bool IsValid { get; set; }

        /// <summary>
        /// Gets or sets the validation message.
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// Gets the configuration being validated.
        /// </summary>
        public AppConfiguration Configuration { get; }

        public ConfigurationValidationEventArgs(AppConfiguration configuration)
        {
            Configuration = configuration;
            IsValid = true;
        }
    }

    /// <summary>
    /// Event arguments for configuration backup events.
    /// </summary>
    public class ConfigurationBackupEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the backup file path.
        /// </summary>
        public string BackupPath { get; }

        /// <summary>
        /// Gets whether the backup was successful.
        /// </summary>
        public bool Success { get; }

        /// <summary>
        /// Gets any error message if the backup failed.
        /// </summary>
        public string ErrorMessage { get; }

        public ConfigurationBackupEventArgs(string backupPath, bool success, string errorMessage = null)
        {
            BackupPath = backupPath;
            Success = success;
            ErrorMessage = errorMessage;
        }
    }

    /// <summary>
    /// Delegate for configuration change events.
    /// </summary>
    public delegate void ConfigurationChangedEventHandler(object sender, ConfigurationChangedEventArgs e);

    /// <summary>
    /// Delegate for configuration validation events.
    /// </summary>
    public delegate void ConfigurationValidationEventHandler(object sender, ConfigurationValidationEventArgs e);

    /// <summary>
    /// Delegate for configuration backup events.
    /// </summary>
    public delegate void ConfigurationBackupEventHandler(object sender, ConfigurationBackupEventArgs e);
}
</file>

<file path="src/Configuration/EventHandlerExtensions.cs">
using System;
using System.Windows.Forms;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Provides extension methods for event handler registration.
    /// </summary>
    public static class EventHandlerExtensions
    {
        /// <summary>
        /// Registers all event handlers for a control with the event handler manager.
        /// </summary>
        /// <param name="control">The control to register events for.</param>
        /// <param name="manager">The event handler manager.</param>
        /// <returns>The control for method chaining.</returns>
        public static T RegisterEvents<T>(this T control, EventHandlerManager manager) where T : Control
        {
            manager.RegisterControlEvents(control);
            return control;
        }

        /// <summary>
        /// Unregisters all event handlers for a control from the event handler manager.
        /// </summary>
        /// <param name="control">The control to unregister events for.</param>
        /// <param name="manager">The event handler manager.</param>
        /// <returns>The control for method chaining.</returns>
        public static T UnregisterEvents<T>(this T control, EventHandlerManager manager) where T : Control
        {
            manager.UnregisterControlEvents(control);
            return control;
        }

        /// <summary>
        /// Registers a specific event handler with tracking.
        /// </summary>
        /// <param name="control">The control to register the event for.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The event handler delegate.</param>
        /// <param name="manager">The event handler manager.</param>
        /// <returns>The control for method chaining.</returns>
        public static T RegisterEventHandler<T>(this T control, string eventName, Delegate handler, EventHandlerManager manager) where T : Control
        {
            if (string.IsNullOrEmpty(eventName))
                throw new ArgumentNullException(nameof(eventName));

            if (handler == null)
                throw new ArgumentNullException(nameof(handler));

            // Add the event handler to the manager's tracking
            typeof(EventHandlerManager)
                .GetMethod("RegisterEventHandler", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
                ?.Invoke(manager, new object[] { $"{control.Name}_{eventName}", handler });

            return control;
        }

        /// <summary>
        /// Registers common event handlers for a TrackBar control.
        /// </summary>
        public static TrackBar RegisterTrackBarEvents(this TrackBar trackBar, EventHandlerManager manager, Action<int> onValueChanged = null)
        {
            if (onValueChanged != null)
            {
                EventHandler valueChangedHandler = (s, e) => onValueChanged(trackBar.Value);
                trackBar.RegisterEventHandler("ValueChanged", valueChangedHandler, manager);
                trackBar.ValueChanged += valueChangedHandler;
            }
            return trackBar;
        }

        /// <summary>
        /// Registers common event handlers for a CheckBox control.
        /// </summary>
        public static CheckBox RegisterCheckBoxEvents(this CheckBox checkBox, EventHandlerManager manager, Action<bool> onCheckedChanged = null)
        {
            if (onCheckedChanged != null)
            {
                EventHandler checkedChangedHandler = (s, e) => onCheckedChanged(checkBox.Checked);
                checkBox.RegisterEventHandler("CheckedChanged", checkedChangedHandler, manager);
                checkBox.CheckedChanged += checkedChangedHandler;
            }
            return checkBox;
        }

        /// <summary>
        /// Registers common event handlers for a Button control.
        /// </summary>
        public static Button RegisterButtonEvents(this Button button, EventHandlerManager manager, Action onClick = null)
        {
            if (onClick != null)
            {
                EventHandler clickHandler = (s, e) => onClick();
                button.RegisterEventHandler("Click", clickHandler, manager);
                button.Click += clickHandler;
            }
            return button;
        }

        /// <summary>
        /// Registers common event handlers for a TextBox control.
        /// </summary>
        public static TextBox RegisterTextBoxEvents(this TextBox textBox, EventHandlerManager manager, 
            Action<string> onTextChanged = null,
            Action<KeyEventArgs> onKeyDown = null)
        {
            if (onTextChanged != null)
            {
                EventHandler textChangedHandler = (s, e) => onTextChanged(textBox.Text);
                textBox.RegisterEventHandler("TextChanged", textChangedHandler, manager);
                textBox.TextChanged += textChangedHandler;
            }

            if (onKeyDown != null)
            {
                KeyEventHandler keyDownHandler = (s, e) => onKeyDown(e);
                textBox.RegisterEventHandler("KeyDown", keyDownHandler, manager);
                textBox.KeyDown += keyDownHandler;
            }

            return textBox;
        }
    }
}
</file>

<file path="src/Validation.cs">
using System;

namespace NotesAndTasks
{
    /// <summary>
    /// Provides validation methods for input values throughout the application.
    /// </summary>
    internal static class Validation
    {
        /// <summary>
        /// Validates a strength value for jitter or recoil reduction.
        /// </summary>
        /// <param name="strength">The strength value to validate.</param>
        /// <param name="minValue">The minimum allowed value (inclusive).</param>
        /// <param name="maxValue">The maximum allowed value (inclusive).</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the strength value is outside the valid range.</exception>
        public static void ValidateStrength(int strength, int minValue, int maxValue, string paramName)
        {
            if (strength < minValue || strength > maxValue)
            {
                throw new ArgumentOutOfRangeException(
                    paramName,
                    strength,
                    $"Strength value must be between {minValue} and {maxValue}."
                );
            }
        }

        /// <summary>
        /// Validates that a string parameter is not null or empty.
        /// </summary>
        /// <param name="value">The string value to validate.</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentNullException">Thrown when the value is null.</exception>
        /// <exception cref="ArgumentException">Thrown when the value is empty.</exception>
        public static void ValidateStringNotNullOrEmpty(string value, string paramName)
        {
            if (value == null)
            {
                throw new ArgumentNullException(paramName);
            }
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Value cannot be empty or whitespace.", paramName);
            }
        }

        /// <summary>
        /// Validates that a reference parameter is not null.
        /// </summary>
        /// <typeparam name="T">The type of the parameter.</typeparam>
        /// <param name="value">The value to validate.</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentNullException">Thrown when the value is null.</exception>
        public static void ValidateNotNull<T>(T value, string paramName) where T : class
        {
            if (value == null)
            {
                throw new ArgumentNullException(paramName);
            }
        }

        /// <summary>
        /// Validates that a handle is not IntPtr.Zero.
        /// </summary>
        /// <param name="handle">The handle to validate.</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentException">Thrown when the handle is IntPtr.Zero.</exception>
        public static void ValidateHandle(IntPtr handle, string paramName)
        {
            if (handle == IntPtr.Zero)
            {
                throw new ArgumentException("Handle cannot be zero.", paramName);
            }
        }

        /// <summary>
        /// Validates that a hook code is valid for processing.
        /// </summary>
        /// <param name="nCode">The hook code to validate.</param>
        /// <returns>True if the hook code should be processed, false if it should be passed to the next hook.</returns>
        public static bool ValidateHookCode(int nCode)
        {
            return nCode >= 0;
        }
    }
}
</file>

<file path="app.manifest">
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="Notes&amp;Tasks"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="requireAdministrator" uiAccess="true" />
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
</file>

<file path="src/Configuration/ConfigurationManager.cs">
using System;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Windows.Forms;
using System.Linq;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Manages application configuration, providing thread-safe access to settings
    /// and handling configuration persistence.
    /// </summary>
    public class ConfigurationManager
    {
        private static readonly Lazy<ConfigurationManager> instance = 
            new Lazy<ConfigurationManager>(() => new ConfigurationManager(), LazyThreadSafetyMode.ExecutionAndPublication);

        private readonly ReaderWriterLockSlim configLock = new ReaderWriterLockSlim();
        private readonly string configFilePath;
        private AppConfiguration currentConfig;
        private readonly JsonSerializerOptions jsonOptions;

        // Add these event declarations after the existing fields
        public event ConfigurationChangedEventHandler ConfigurationChanged;
        public event ConfigurationValidationEventHandler ConfigurationValidating;
        public event ConfigurationBackupEventHandler ConfigurationBackupCompleted;

        /// <summary>
        /// Gets the singleton instance of the ConfigurationManager.
        /// </summary>
        public static ConfigurationManager Instance => instance.Value;

        /// <summary>
        /// Gets the current configuration. Thread-safe access to configuration values.
        /// </summary>
        public AppConfiguration CurrentConfig
        {
            get
            {
                configLock.EnterReadLock();
                try
                {
                    return (AppConfiguration)currentConfig.Clone();
                }
                finally
                {
                    configLock.ExitReadLock();
                }
            }
        }

        private ConfigurationManager()
        {
            configFilePath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                "NotesAndTasks",
                "config.json"
            );

            jsonOptions = new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNameCaseInsensitive = true
            };

            InitializeConfiguration();
        }

        /// <summary>
        /// Initializes the configuration system, creating default config if none exists.
        /// </summary>
        private void InitializeConfiguration()
        {
            try
            {
                // Ensure directory exists
                Directory.CreateDirectory(Path.GetDirectoryName(configFilePath));

                if (File.Exists(configFilePath))
                {
                    LoadConfiguration();
                }
                else
                {
                    currentConfig = CreateDefaultConfiguration();
                    SaveConfiguration();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error initializing configuration: {ex.Message}");
                currentConfig = CreateDefaultConfiguration();
            }
        }

        /// <summary>
        /// Creates a default configuration with preset values.
        /// </summary>
        private AppConfiguration CreateDefaultConfiguration()
        {
            return new AppConfiguration
            {
                JitterSettings = new JitterConfiguration
                {
                    Strength = 3,
                    IsEnabled = false,
                    AlwaysEnabled = false
                },
                RecoilSettings = new RecoilConfiguration
                {
                    Strength = 1,
                    IsEnabled = true,
                    AlwaysEnabled = false
                },
                HotkeySettings = new HotkeyConfiguration
                {
                    MacroToggleKey = Keys.Capital.ToString(),
                    ModeSwitchKey = Keys.Q.ToString()
                },
                UISettings = new UIConfiguration
                {
                    MinimizeToTray = false,
                    ShowDebugPanel = false,
                    WindowPosition = new System.Drawing.Point(100, 100),
                    WindowSize = new System.Drawing.Size(800, 600)
                },
                BackupSettings = new BackupConfiguration
                {
                    AutoBackupEnabled = true,
                    BackupIntervalHours = 24,
                    MaxBackupCount = 5,
                    BackupDirectory = Path.Combine(
                        Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                        "NotesAndTasks",
                        "Backups"
                    )
                }
            };
        }

        /// <summary>
        /// Updates the configuration with new values and saves to disk.
        /// </summary>
        /// <param name="newConfig">The new configuration to apply.</param>
        /// <param name="section">The section being updated.</param>
        /// <returns>True if the update was successful, false otherwise.</returns>
        public bool UpdateConfiguration(AppConfiguration newConfig, string section = "General")
        {
            if (newConfig == null)
                throw new ArgumentNullException(nameof(newConfig));

            configLock.EnterWriteLock();
            try
            {
                // Raise validation event
                var validationArgs = new ConfigurationValidationEventArgs(newConfig);
                OnConfigurationValidating(validationArgs);

                if (!validationArgs.IsValid || !ValidateConfiguration(newConfig))
                {
                    System.Diagnostics.Debug.WriteLine($"Configuration validation failed: {validationArgs.Message}");
                    return false;
                }

                var previousConfig = currentConfig?.Clone() as AppConfiguration;
                currentConfig = newConfig.Clone() as AppConfiguration;
                SaveConfiguration();

                // Raise change event
                OnConfigurationChanged(new ConfigurationChangedEventArgs(section, previousConfig, currentConfig));
                return true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error updating configuration: {ex.Message}");
                return false;
            }
            finally
            {
                configLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Validates the configuration values.
        /// </summary>
        /// <param name="config">The configuration to validate.</param>
        /// <returns>True if the configuration is valid, false otherwise.</returns>
        private bool ValidateConfiguration(AppConfiguration config)
        {
            if (config == null) return false;

            try
            {
                // Validate Jitter settings
                if (config.JitterSettings.Strength < 1 || config.JitterSettings.Strength > 20)
                    return false;

                // Validate Recoil settings
                if (config.RecoilSettings.Strength < 1 || config.RecoilSettings.Strength > 20)
                    return false;

                // Validate hotkeys
                if (string.IsNullOrEmpty(config.HotkeySettings.MacroToggleKey) ||
                    string.IsNullOrEmpty(config.HotkeySettings.ModeSwitchKey))
                    return false;

                // Validate backup settings
                if (config.BackupSettings.AutoBackupEnabled)
                {
                    if (config.BackupSettings.BackupIntervalHours < 1 ||
                        config.BackupSettings.MaxBackupCount < 1 ||
                        string.IsNullOrEmpty(config.BackupSettings.BackupDirectory))
                        return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Configuration validation error: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Loads the configuration from disk.
        /// </summary>
        private void LoadConfiguration()
        {
            configLock.EnterWriteLock();
            try
            {
                string jsonContent = File.ReadAllText(configFilePath);
                var loadedConfig = JsonSerializer.Deserialize<AppConfiguration>(jsonContent, jsonOptions);

                if (ValidateConfiguration(loadedConfig))
                {
                    currentConfig = loadedConfig;
                }
                else
                {
                    currentConfig = CreateDefaultConfiguration();
                    SaveConfiguration();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error loading configuration: {ex.Message}");
                currentConfig = CreateDefaultConfiguration();
            }
            finally
            {
                configLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Saves the current configuration to disk.
        /// </summary>
        private void SaveConfiguration()
        {
            try
            {
                string jsonContent = JsonSerializer.Serialize(currentConfig, jsonOptions);
                File.WriteAllText(configFilePath, jsonContent);

                if (currentConfig.BackupSettings.AutoBackupEnabled)
                {
                    CreateConfigurationBackup();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error saving configuration: {ex.Message}");
            }
        }

        /// <summary>
        /// Creates a backup of the current configuration.
        /// </summary>
        private void CreateConfigurationBackup()
        {
            try
            {
                string backupDir = currentConfig.BackupSettings.BackupDirectory;
                Directory.CreateDirectory(backupDir);

                string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string backupPath = Path.Combine(backupDir, $"config_backup_{timestamp}.json");

                File.Copy(configFilePath, backupPath, true);

                // Cleanup old backups
                var backupFiles = Directory.GetFiles(backupDir, "config_backup_*.json")
                    .OrderByDescending(f => f)
                    .Skip(currentConfig.BackupSettings.MaxBackupCount);

                foreach (var file in backupFiles)
                {
                    try
                    {
                        File.Delete(file);
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine($"Error deleting old backup {file}: {ex.Message}");
                    }
                }

                // Raise backup completed event
                OnConfigurationBackupCompleted(new ConfigurationBackupEventArgs(backupPath, true));
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error creating configuration backup: {ex.Message}");
                OnConfigurationBackupCompleted(new ConfigurationBackupEventArgs(null, false, ex.Message));
            }
        }

        /// <summary>
        /// Restores configuration from a backup file.
        /// </summary>
        /// <param name="backupFilePath">Path to the backup file to restore from.</param>
        /// <returns>True if restore was successful, false otherwise.</returns>
        public bool RestoreFromBackup(string backupFilePath)
        {
            if (!File.Exists(backupFilePath))
                return false;

            configLock.EnterWriteLock();
            try
            {
                string jsonContent = File.ReadAllText(backupFilePath);
                var restoredConfig = JsonSerializer.Deserialize<AppConfiguration>(jsonContent, jsonOptions);

                if (ValidateConfiguration(restoredConfig))
                {
                    currentConfig = restoredConfig;
                    SaveConfiguration();
                    return true;
                }
                return false;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error restoring configuration: {ex.Message}");
                return false;
            }
            finally
            {
                configLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Gets a list of available configuration backups.
        /// </summary>
        /// <returns>Array of backup file paths.</returns>
        public string[] GetAvailableBackups()
        {
            try
            {
                string backupDir = currentConfig.BackupSettings.BackupDirectory;
                if (!Directory.Exists(backupDir))
                    return Array.Empty<string>();

                return Directory.GetFiles(backupDir, "config_backup_*.json")
                    .OrderByDescending(f => f)
                    .ToArray();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error getting available backups: {ex.Message}");
                return Array.Empty<string>();
            }
        }

        /// <summary>
        /// Raises the ConfigurationChanged event.
        /// </summary>
        protected virtual void OnConfigurationChanged(ConfigurationChangedEventArgs e)
        {
            ConfigurationChanged?.Invoke(this, e);
        }

        /// <summary>
        /// Raises the ConfigurationValidating event.
        /// </summary>
        protected virtual void OnConfigurationValidating(ConfigurationValidationEventArgs e)
        {
            ConfigurationValidating?.Invoke(this, e);
        }

        /// <summary>
        /// Raises the ConfigurationBackupCompleted event.
        /// </summary>
        protected virtual void OnConfigurationBackupCompleted(ConfigurationBackupEventArgs e)
        {
            ConfigurationBackupCompleted?.Invoke(this, e);
        }
    }
}
</file>

<file path="src/Configuration/EventHandlerManager.cs">
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Manages event handler registration and lifecycle for the application.
    /// Provides centralized control over event subscriptions and cleanup.
    /// </summary>
    public class EventHandlerManager : IDisposable
    {
        private readonly Dictionary<string, List<Delegate>> eventHandlers;
        private readonly ConfigurationManager configManager;
        private bool isDisposed;

        /// <summary>
        /// Initializes a new instance of the EventHandlerManager class.
        /// </summary>
        /// <param name="configManager">The configuration manager instance.</param>
        public EventHandlerManager(ConfigurationManager configManager)
        {
            this.configManager = configManager ?? throw new ArgumentNullException(nameof(configManager));
            this.eventHandlers = new Dictionary<string, List<Delegate>>();
            RegisterConfigurationEvents();
        }

        /// <summary>
        /// Registers configuration-related event handlers.
        /// </summary>
        private void RegisterConfigurationEvents()
        {
            // Configuration change handlers
            RegisterEventHandler("ConfigChanged", 
                new ConfigurationChangedEventHandler(OnConfigurationChanged));
            configManager.ConfigurationChanged += OnConfigurationChanged;

            // Configuration validation handlers
            RegisterEventHandler("ConfigValidating",
                new ConfigurationValidationEventHandler(OnConfigurationValidating));
            configManager.ConfigurationValidating += OnConfigurationValidating;

            // Configuration backup handlers
            RegisterEventHandler("ConfigBackup",
                new ConfigurationBackupEventHandler(OnConfigurationBackupCompleted));
            configManager.ConfigurationBackupCompleted += OnConfigurationBackupCompleted;
        }

        /// <summary>
        /// Registers a control's event handlers.
        /// </summary>
        /// <param name="control">The control to register events for.</param>
        public void RegisterControlEvents<T>(T control) where T : Control
        {
            if (control == null) return;

            // Store event handlers
            var handlers = new List<Delegate>();
            eventHandlers[control.Name] = handlers;

            // Common events
            EventHandler clickHandler = (s, e) => OnControlClick(control, e);
            control.Click += clickHandler;
            handlers.Add(clickHandler);

            // Mouse events
            MouseEventHandler mouseDownHandler = (s, e) => OnControlMouseDown(control, e);
            control.MouseDown += mouseDownHandler;
            handlers.Add(mouseDownHandler);

            MouseEventHandler mouseUpHandler = (s, e) => OnControlMouseUp(control, e);
            control.MouseUp += mouseUpHandler;
            handlers.Add(mouseUpHandler);

            // Type-specific events
            if (control is TrackBar trackBar)
            {
                EventHandler valueChangedHandler = (s, e) => OnTrackBarValueChanged(trackBar, e);
                trackBar.ValueChanged += valueChangedHandler;
                handlers.Add(valueChangedHandler);

                EventHandler scrollHandler = (s, e) => OnTrackBarScroll(trackBar, e);
                trackBar.Scroll += scrollHandler;
                handlers.Add(scrollHandler);
            }
            else if (control is CheckBox checkBox)
            {
                EventHandler checkedChangedHandler = (s, e) => OnCheckBoxCheckedChanged(checkBox, e);
                checkBox.CheckedChanged += checkedChangedHandler;
                handlers.Add(checkedChangedHandler);
            }
            else if (control is TextBox textBox)
            {
                EventHandler textChangedHandler = (s, e) => OnTextBoxTextChanged(textBox, e);
                textBox.TextChanged += textChangedHandler;
                handlers.Add(textChangedHandler);

                KeyEventHandler keyDownHandler = (s, e) => OnTextBoxKeyDown(textBox, e);
                textBox.KeyDown += keyDownHandler;
                handlers.Add(keyDownHandler);
            }
        }

        /// <summary>
        /// Registers an event handler with tracking.
        /// </summary>
        private void RegisterEventHandler(string eventName, Delegate handler)
        {
            if (!eventHandlers.ContainsKey(eventName))
            {
                eventHandlers[eventName] = new List<Delegate>();
            }
            eventHandlers[eventName].Add(handler);
        }

        /// <summary>
        /// Unregisters all event handlers for a control.
        /// </summary>
        public void UnregisterControlEvents(Control control)
        {
            if (control == null) return;

            var handlersToRemove = new List<string>();
            foreach (var kvp in eventHandlers)
            {
                if (kvp.Key.StartsWith($"{control.Name}_"))
                {
                    handlersToRemove.Add(kvp.Key);
                }
            }

            foreach (var handlerName in handlersToRemove)
            {
                eventHandlers.Remove(handlerName);
            }
        }

        /// <summary>
        /// Configuration changed event handler.
        /// </summary>
        private void OnConfigurationChanged(object sender, ConfigurationChangedEventArgs e)
        {
            try
            {
                // Handle configuration changes based on section
                switch (e.Section)
                {
                    case "JitterSettings":
                        HandleJitterSettingsChanged(e.PreviousConfig, e.NewConfig);
                        break;
                    case "RecoilSettings":
                        HandleRecoilSettingsChanged(e.PreviousConfig, e.NewConfig);
                        break;
                    case "HotkeySettings":
                        HandleHotkeySettingsChanged(e.PreviousConfig, e.NewConfig);
                        break;
                    case "UISettings":
                        HandleUISettingsChanged(e.PreviousConfig, e.NewConfig);
                        break;
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error handling configuration change: {ex.Message}");
            }
        }

        /// <summary>
        /// Configuration validating event handler.
        /// </summary>
        private void OnConfigurationValidating(object sender, ConfigurationValidationEventArgs e)
        {
            try
            {
                // Perform additional validation if needed
                if (e.Configuration != null)
                {
                    ValidateConfigurationConsistency(e);
                }
            }
            catch (Exception ex)
            {
                e.IsValid = false;
                e.Message = $"Validation error: {ex.Message}";
                System.Diagnostics.Debug.WriteLine($"Error during configuration validation: {ex.Message}");
            }
        }

        /// <summary>
        /// Configuration backup completed event handler.
        /// </summary>
        private void OnConfigurationBackupCompleted(object sender, ConfigurationBackupEventArgs e)
        {
            try
            {
                if (e.Success)
                {
                    System.Diagnostics.Debug.WriteLine($"Configuration backup created successfully at: {e.BackupPath}");
                }
                else
                {
                    System.Diagnostics.Debug.WriteLine($"Configuration backup failed: {e.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error handling backup completion: {ex.Message}");
            }
        }

        /// <summary>
        /// Validates configuration consistency.
        /// </summary>
        private void ValidateConfigurationConsistency(ConfigurationValidationEventArgs e)
        {
            var config = e.Configuration;

            // Validate mode consistency
            if (config.JitterSettings.AlwaysEnabled && config.RecoilSettings.AlwaysEnabled)
            {
                e.IsValid = false;
                e.Message = "Both jitter and recoil reduction cannot be in always-enabled mode";
                return;
            }

            // Validate hotkey conflicts
            if (config.HotkeySettings.MacroToggleKey == config.HotkeySettings.ModeSwitchKey)
            {
                e.IsValid = false;
                e.Message = "Macro toggle key and mode switch key cannot be the same";
                return;
            }

            // Validate backup settings
            if (config.BackupSettings.AutoBackupEnabled)
            {
                if (config.BackupSettings.BackupIntervalHours < 1)
                {
                    e.IsValid = false;
                    e.Message = "Backup interval must be at least 1 hour";
                    return;
                }
                if (config.BackupSettings.MaxBackupCount < 1)
                {
                    e.IsValid = false;
                    e.Message = "Maximum backup count must be at least 1";
                    return;
                }
            }
        }

        /// <summary>
        /// Handles changes to jitter settings.
        /// </summary>
        private void HandleJitterSettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            if (previousConfig?.JitterSettings.Strength != newConfig.JitterSettings.Strength)
            {
                System.Diagnostics.Debug.WriteLine($"Jitter strength changed from {previousConfig?.JitterSettings.Strength} to {newConfig.JitterSettings.Strength}");
            }
            if (previousConfig?.JitterSettings.IsEnabled != newConfig.JitterSettings.IsEnabled)
            {
                System.Diagnostics.Debug.WriteLine($"Jitter enabled state changed from {previousConfig?.JitterSettings.IsEnabled} to {newConfig.JitterSettings.IsEnabled}");
            }
        }

        /// <summary>
        /// Handles changes to recoil reduction settings.
        /// </summary>
        private void HandleRecoilSettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            if (previousConfig?.RecoilSettings.Strength != newConfig.RecoilSettings.Strength)
            {
                System.Diagnostics.Debug.WriteLine($"Recoil reduction strength changed from {previousConfig?.RecoilSettings.Strength} to {newConfig.RecoilSettings.Strength}");
            }
            if (previousConfig?.RecoilSettings.IsEnabled != newConfig.RecoilSettings.IsEnabled)
            {
                System.Diagnostics.Debug.WriteLine($"Recoil reduction enabled state changed from {previousConfig?.RecoilSettings.IsEnabled} to {newConfig.RecoilSettings.IsEnabled}");
            }
        }

        /// <summary>
        /// Handles changes to hotkey settings.
        /// </summary>
        private void HandleHotkeySettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            if (previousConfig?.HotkeySettings.MacroToggleKey != newConfig.HotkeySettings.MacroToggleKey)
            {
                System.Diagnostics.Debug.WriteLine($"Macro toggle key changed from {previousConfig?.HotkeySettings.MacroToggleKey} to {newConfig.HotkeySettings.MacroToggleKey}");
            }
            if (previousConfig?.HotkeySettings.ModeSwitchKey != newConfig.HotkeySettings.ModeSwitchKey)
            {
                System.Diagnostics.Debug.WriteLine($"Mode switch key changed from {previousConfig?.HotkeySettings.ModeSwitchKey} to {newConfig.HotkeySettings.ModeSwitchKey}");
            }
        }

        /// <summary>
        /// Handles changes to UI settings.
        /// </summary>
        private void HandleUISettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            if (previousConfig?.UISettings.MinimizeToTray != newConfig.UISettings.MinimizeToTray)
            {
                System.Diagnostics.Debug.WriteLine($"Minimize to tray setting changed from {previousConfig?.UISettings.MinimizeToTray} to {newConfig.UISettings.MinimizeToTray}");
            }
            if (previousConfig?.UISettings.ShowDebugPanel != newConfig.UISettings.ShowDebugPanel)
            {
                System.Diagnostics.Debug.WriteLine($"Debug panel visibility changed from {previousConfig?.UISettings.ShowDebugPanel} to {newConfig.UISettings.ShowDebugPanel}");
            }
        }

        // Event handler methods
        private void OnControlClick(Control control, EventArgs e)
        {
            // Handle click event
        }

        private void OnControlMouseDown(Control control, MouseEventArgs e)
        {
            // Handle mouse down
        }

        private void OnControlMouseUp(Control control, MouseEventArgs e)
        {
            // Handle mouse up
        }

        private void OnTrackBarValueChanged(TrackBar trackBar, EventArgs e)
        {
            // Handle value changed
        }

        private void OnTrackBarScroll(TrackBar trackBar, EventArgs e)
        {
            // Handle scroll
        }

        private void OnCheckBoxCheckedChanged(CheckBox checkBox, EventArgs e)
        {
            // Handle checked changed
        }

        private void OnTextBoxTextChanged(TextBox textBox, EventArgs e)
        {
            // Handle text changed
        }

        private void OnTextBoxKeyDown(TextBox textBox, KeyEventArgs e)
        {
            // Handle key down
        }

        /// <summary>
        /// Disposes of the event handler manager and unregisters all events.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Protected implementation of Dispose pattern.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (!isDisposed)
            {
                if (disposing)
                {
                    // Unregister all event handlers
                    configManager.ConfigurationChanged -= OnConfigurationChanged;
                    configManager.ConfigurationValidating -= OnConfigurationValidating;
                    configManager.ConfigurationBackupCompleted -= OnConfigurationBackupCompleted;

                    eventHandlers.Clear();
                }

                isDisposed = true;
            }
        }
    }
}
</file>

<file path="src/Configuration/SettingsValidation.cs">
using System;
using System.Windows.Forms;

namespace NotesAndTasks.Configuration
{
    public static class SettingsValidation
    {
        public static bool IsValidHotkey(Keys key)
        {
            // Validate that the key is a valid hotkey
            return key != Keys.None && 
                   key != Keys.LButton && 
                   key != Keys.RButton;
        }

        public static bool ValidateSettings(Settings settings, int minStrength, int maxStrength)
        {
            if (settings == null) return false;

            // Validate strength values
            if (settings.JitterStrength < minStrength || settings.JitterStrength > maxStrength ||
                settings.RecoilReductionStrength < minStrength || settings.RecoilReductionStrength > maxStrength)
                return false;

            // Validate hotkeys
            if (string.IsNullOrEmpty(settings.MacroToggleKey) || string.IsNullOrEmpty(settings.ModeSwitchKey))
                return false;

            try
            {
                var toggleKey = (Keys)Enum.Parse(typeof(Keys), settings.MacroToggleKey);
                var switchKey = (Keys)Enum.Parse(typeof(Keys), settings.ModeSwitchKey);

                if (!IsValidHotkey(toggleKey) || !IsValidHotkey(switchKey))
                    return false;

                if (toggleKey == switchKey)
                    return false;
            }
            catch
            {
                return false;
            }

            return true;
        }
    }
}
</file>

<file path="src/ModernButton.cs">
using System.Drawing.Drawing2D;
using System.ComponentModel;

namespace NotesAndTasks
{
    public class ModernButton : Button
    {
        private int borderRadius = 10;
        private Color borderColor = Color.FromArgb(250, 91, 101);
        private Color hoverBackColor = Color.FromArgb(214, 37, 106);
        private bool isHovered = false;

        [Category("Modern Button")]
        public int BorderRadius
        {
            get => borderRadius;
            set
            {
                borderRadius = value;
                Invalidate();
            }
        }

        [Category("Modern Button")]
        public Color BorderColor
        {
            get => borderColor;
            set
            {
                borderColor = value;
                Invalidate();
            }
        }

        [Category("Modern Button")]
        public Color HoverBackColor
        {
            get => hoverBackColor;
            set
            {
                hoverBackColor = value;
                Invalidate();
            }
        }

        public ModernButton()
        {
            FlatStyle = FlatStyle.Flat;
            FlatAppearance.BorderSize = 0;
            BackColor = Color.FromArgb(30, 1, 62);
            ForeColor = Color.White;
            Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            Size = new Size(150, 40);
            Cursor = Cursors.Hand;

            MouseEnter += (s, e) =>
            {
                isHovered = true;
                Invalidate();
            };

            MouseLeave += (s, e) =>
            {
                isHovered = false;
                Invalidate();
            };
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            var graphicsPath = new GraphicsPath();
            var rect = new Rectangle(0, 0, Width - 1, Height - 1);
            int radius = borderRadius;

            // Create rounded rectangle path
            graphicsPath.AddArc(rect.X, rect.Y, radius * 2, radius * 2, 180, 90);
            graphicsPath.AddArc(rect.Right - radius * 2, rect.Y, radius * 2, radius * 2, 270, 90);
            graphicsPath.AddArc(rect.Right - radius * 2, rect.Bottom - radius * 2, radius * 2, radius * 2, 0, 90);
            graphicsPath.AddArc(rect.X, rect.Bottom - radius * 2, radius * 2, radius * 2, 90, 90);
            graphicsPath.CloseFigure();

            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;

            // Fill background
            using (var brush = new SolidBrush(isHovered ? hoverBackColor : BackColor))
            {
                e.Graphics.FillPath(brush, graphicsPath);
            }

            // Draw border
            using (var pen = new Pen(borderColor, 1))
            {
                e.Graphics.DrawPath(pen, graphicsPath);
            }

            // Draw text
            var textRect = new Rectangle(0, 0, Width, Height);
            TextRenderer.DrawText(e.Graphics, Text, Font, textRect, ForeColor,
                TextFormatFlags.HorizontalCenter | TextFormatFlags.VerticalCenter);

            graphicsPath.Dispose();
        }
    }
}
</file>

<file path="src/ModernTrackBar.cs">
using System.Drawing.Drawing2D;
using System.ComponentModel;

namespace NotesAndTasks
{
    public class ModernTrackBar : TrackBar
    {
        private Color tickColor = Color.FromArgb(250, 91, 101);
        private Color trackColor = Color.FromArgb(214, 37, 106);
        private Color thumbColor = Color.FromArgb(255,255,255);
        private bool isDragging = false;

        [Category("Modern TrackBar")]
        public Color TickColor
        {
            get => tickColor;
            set
            {
                tickColor = value;
                Invalidate();
            }
        }

        [Category("Modern TrackBar")]
        public Color TrackColor
        {
            get => trackColor;
            set
            {
                trackColor = value;
                Invalidate();
            }
        }

        [Category("Modern TrackBar")]
        public Color ThumbColor
        {
            get => thumbColor;
            set
            {
                thumbColor = value;
                Invalidate();
            }
        }

        public ModernTrackBar()
        {
            SetStyle(ControlStyles.UserPaint | 
                    ControlStyles.AllPaintingInWmPaint | 
                    ControlStyles.OptimizedDoubleBuffer, true);

            ValueChanged += (s, e) => Invalidate();
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                isDragging = true;
                UpdateValue(e.X);
            }
            base.OnMouseDown(e);
        }

        protected override void OnMouseMove(MouseEventArgs e)
        {
            if (isDragging)
            {
                UpdateValue(e.X);
            }
            base.OnMouseMove(e);
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                isDragging = false;
            }
            base.OnMouseUp(e);
        }

        private void UpdateValue(int mouseX)
        {
            if (mouseX < 10) mouseX = 10;
            if (mouseX > Width - 10) mouseX = Width - 10;

            float valueRange = Maximum - Minimum;
            float pixelRange = Width - 20;
            float valuePerPixel = valueRange / pixelRange;

            int newValue = (int)((mouseX - 10) * valuePerPixel) + Minimum;
            if (newValue < Minimum) newValue = Minimum;
            if (newValue > Maximum) newValue = Maximum;

            Value = newValue;
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
            e.Graphics.Clear(BackColor);

            var trackRect = new Rectangle(0, Height / 2 - 2, Width - 1, 4);
            using (var trackBrush = new SolidBrush(trackColor))
            {
                e.Graphics.FillRectangle(trackBrush, trackRect);
            }

            // Draw ticks
            if (TickStyle != TickStyle.None)
            {
                using (var tickPen = new Pen(tickColor, 1))
                {
                    int tickCount = Maximum - Minimum;
                    float tickSpacing = (Width - 20) / (float)tickCount;
                    for (int i = 0; i <= tickCount; i++)
                    {
                        int x = 10 + (int)(i * tickSpacing);
                        e.Graphics.DrawLine(tickPen, x, Height / 2 + 5, x, Height / 2 + 10);
                    }
                }
            }

            // Draw thumb
            float thumbPosition = (Value - Minimum) * (Width - 20) / (float)(Maximum - Minimum) + 10;
            var thumbRect = new Rectangle((int)thumbPosition - 6, Height / 2 - 6, 12, 12);
            using (var thumbBrush = new SolidBrush(thumbColor))
            {
                e.Graphics.FillEllipse(thumbBrush, thumbRect);
            }
        }
    }
}
</file>

<file path="src/NativeMethods.cs">
using System;
using System.Runtime.InteropServices;

namespace NotesAndTasks
{
    /// <summary>
    /// Contains P/Invoke declarations for Windows API functions and related structures.
    /// This class follows security best practices by isolating native method declarations.
    /// </summary>
    /// <remarks>
    /// This class encapsulates all external Windows API calls used by the application.
    /// It implements the recommended pattern for P/Invoke declarations by:
    /// - Using internal access to limit exposure
    /// - Properly declaring structures with correct marshaling attributes
    /// - Including security-related attributes where needed
    /// - Providing comprehensive documentation for each member
    /// </remarks>
    internal static class NativeMethods
    {
        #region Delegates
        /// <summary>
        /// Delegate for low-level keyboard and mouse hook callbacks.
        /// </summary>
        /// <param name="nCode">Hook code. If nCode is less than zero, the hook procedure must pass the message to CallNextHookEx.</param>
        /// <param name="wParam">Message identifier.</param>
        /// <param name="lParam">Pointer to a KBDLLHOOKSTRUCT or MSLLHOOKSTRUCT structure.</param>
        /// <returns>If nCode is less than zero, the hook procedure must return the value returned by CallNextHookEx.</returns>
        internal delegate IntPtr LowLevelHookProc(int nCode, IntPtr wParam, IntPtr lParam);
        #endregion

        #region Structures
        /// <summary>
        /// Represents a point in a two-dimensional coordinate system.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct POINT
        {
            /// <summary>The x-coordinate of the point.</summary>
            public int X;
            /// <summary>The y-coordinate of the point.</summary>
            public int Y;
        }

        /// <summary>
        /// Contains information about a low-level mouse input event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct MSLLHOOKSTRUCT
        {
            /// <summary>The x- and y-coordinates of the cursor, in screen coordinates.</summary>
            public POINT pt;
            /// <summary>
            /// Additional information about the mouse event.
            /// If the message is WM_XBUTTONDOWN, WM_XBUTTONUP, WM_XBUTTONDBLCLK, WM_NCXBUTTONDOWN, WM_NCXBUTTONUP,
            /// or WM_NCXBUTTONDBLCLK, the high-order word specifies which X button was pressed or released.
            /// </summary>
            public uint mouseData;
            /// <summary>The event-injected flag.</summary>
            public uint flags;
            /// <summary>The time stamp for this message.</summary>
            public uint time;
            /// <summary>Additional information associated with the message.</summary>
            public IntPtr dwExtraInfo;
        }

        /// <summary>
        /// Contains information about simulated mouse or keyboard input events.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct INPUT
        {
            /// <summary>The type of the input event (1 for mouse input, 2 for keyboard input).</summary>
            public uint type;
            /// <summary>The mouse input data when the type is INPUT_MOUSE.</summary>
            public MOUSEINPUT mi;
        }

        /// <summary>
        /// Contains information about a simulated mouse event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct MOUSEINPUT
        {
            /// <summary>The absolute position of the mouse, or the amount of motion since the last mouse event.</summary>
            public int dx;
            /// <summary>The absolute position of the mouse, or the amount of motion since the last mouse event.</summary>
            public int dy;
            /// <summary>If the mouse wheel is moved, indicates the amount of wheel movement.</summary>
            public uint mouseData;
            /// <summary>A set of bit flags that specify various aspects of mouse motion and button clicks.</summary>
            public uint dwFlags;
            /// <summary>The time stamp for the event, in milliseconds.</summary>
            public uint time;
            /// <summary>Additional information associated with the event.</summary>
            public IntPtr dwExtraInfo;
        }
        #endregion

        #region User32.dll Functions
        /// <summary>
        /// Sets a Windows hook that monitors low-level keyboard or mouse input events.
        /// </summary>
        /// <param name="idHook">The type of hook to be installed (WH_KEYBOARD_LL or WH_MOUSE_LL).</param>
        /// <param name="lpfn">A pointer to the hook procedure.</param>
        /// <param name="hMod">A handle to the DLL containing the hook procedure.</param>
        /// <param name="dwThreadId">The identifier of the thread with which the hook procedure is to be associated.</param>
        /// <returns>If successful, returns a handle to the hook procedure. If unsuccessful, returns IntPtr.Zero.</returns>
        /// <remarks>
        /// The hook procedure should process the message and return the value returned by CallNextHookEx.
        /// For low-level hooks, the hook procedure must be in the same desktop as the running application.
        /// </remarks>
        [DllImport("user32.dll", SetLastError = true)]
        internal static extern IntPtr SetWindowsHookEx(
            int idHook,
            LowLevelHookProc lpfn,
            IntPtr hMod,
            uint dwThreadId);

        /// <summary>
        /// Removes a previously set Windows hook.
        /// </summary>
        /// <param name="hhk">A handle to the hook to be removed. This parameter is obtained by a previous call to SetWindowsHookEx.</param>
        /// <returns>If successful, returns true. If unsuccessful, returns false.</returns>
        /// <remarks>
        /// The hook procedure must be in the state to be removed, that is, it must not be in the middle of processing a message.
        /// This function must be called on the same thread that installed the hook.
        /// </remarks>
        [DllImport("user32.dll", SetLastError = true)]
        internal static extern bool UnhookWindowsHookEx(IntPtr hhk);

        /// <summary>
        /// Passes the hook information to the next hook procedure in the current hook chain.
        /// </summary>
        /// <param name="hhk">This parameter is ignored.</param>
        /// <param name="nCode">The hook code passed to the current hook procedure.</param>
        /// <param name="wParam">The wParam value passed to the current hook procedure.</param>
        /// <param name="lParam">The lParam value passed to the current hook procedure.</param>
        /// <returns>The value returned by the next hook procedure in the chain.</returns>
        /// <remarks>
        /// This function must be called by the hook procedure if it is not processing the message.
        /// The hook procedure can modify the values pointed to by wParam and lParam before passing them to CallNextHookEx.
        /// </remarks>
        [DllImport("user32.dll")]
        internal static extern IntPtr CallNextHookEx(
            IntPtr hhk,
            int nCode,
            IntPtr wParam,
            IntPtr lParam);

        /// <summary>
        /// Retrieves the current cursor position.
        /// </summary>
        /// <param name="lpPoint">A pointer to a POINT structure that receives the screen coordinates of the cursor.</param>
        /// <returns>Returns true if successful, false otherwise.</returns>
        /// <remarks>
        /// The cursor position is always specified in screen coordinates and is not affected by the mapping mode of the window that contains the cursor.
        /// </remarks>
        [DllImport("user32.dll")]
        internal static extern bool GetCursorPos(out POINT lpPoint);

        /// <summary>
        /// Synthesizes mouse motion and button clicks.
        /// </summary>
        /// <param name="dwFlags">A set of bit flags that specify various aspects of mouse motion and button clicking.</param>
        /// <param name="dx">The mouse's absolute position along the x-axis or its amount of motion since the last mouse event.</param>
        /// <param name="dy">The mouse's absolute position along the y-axis or its amount of motion since the last mouse event.</param>
        /// <param name="dwData">If dwFlags contains MOUSEEVENTF_WHEEL, then dwData specifies the amount of wheel movement.</param>
        /// <param name="dwExtraInfo">Additional information associated with the mouse event.</param>
        /// <remarks>
        /// The mouse_event function has been superseded by SendInput. Use SendInput instead.
        /// </remarks>
        [DllImport("user32.dll")]
        internal static extern void mouse_event(
            uint dwFlags,
            int dx,
            int dy,
            uint dwData,
            int dwExtraInfo);

        /// <summary>
        /// Synthesizes keystrokes, mouse motions, and button clicks.
        /// </summary>
        /// <param name="nInputs">The number of structures in the pInputs array.</param>
        /// <param name="pInputs">An array of INPUT structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</param>
        /// <param name="cbSize">The size, in bytes, of an INPUT structure.</param>
        /// <returns>The function returns the number of events that it successfully inserted into the keyboard or mouse input stream.</returns>
        /// <remarks>
        /// This function is the preferred method for synthesizing input, as it supports more features and is more efficient than mouse_event and keybd_event.
        /// </remarks>
        [DllImport("user32.dll", SetLastError = true)]
        internal static extern uint SendInput(
            uint nInputs,
            ref INPUT pInputs,
            int cbSize);
        #endregion

        #region Kernel32.dll Functions
        /// <summary>
        /// Retrieves a module handle for the specified module.
        /// </summary>
        /// <param name="lpModuleName">The name of the loaded module (either a .dll or .exe file).</param>
        /// <returns>If successful, returns a handle to the specified module. If unsuccessful, returns IntPtr.Zero.</returns>
        /// <remarks>
        /// If lpModuleName is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).
        /// The returned handle is not global or inheritable. It cannot be duplicated or used by another process.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        internal static extern IntPtr GetModuleHandle(string lpModuleName);
        #endregion
    }
}
</file>

<file path="src/WinMessages.cs">
using System;

namespace NotesAndTasks
{
    /// <summary>
    /// Contains Windows message constants used for low-level hooks and input handling.
    /// </summary>
    /// <remarks>
    /// This class provides a centralized location for all Windows message constants used in the application.
    /// The constants are organized into logical groups:
    /// - Hook-related constants (WH_*)
    /// - Keyboard message constants (WM_KEY*)
    /// - Mouse button message constants (WM_*BUTTON*)
    /// - Mouse button identifiers (XBUTTON*)
    /// - Mouse event flags (MOUSEEVENTF_*)
    /// - Input type identifiers (INPUT_*)
    /// - Base values for calculations
    /// </remarks>
    public static class WinMessages
    {
        /// <summary>
        /// Windows hook constant for low-level keyboard events.
        /// Used with SetWindowsHookEx to install a hook procedure that monitors low-level keyboard input events.
        /// </summary>
        public const int WH_KEYBOARD_LL = 13;

        /// <summary>
        /// Windows hook constant for low-level mouse events.
        /// Used with SetWindowsHookEx to install a hook procedure that monitors low-level mouse input events.
        /// </summary>
        public const int WH_MOUSE_LL = 14;

        /// <summary>
        /// Posted when a nonsystem key is pressed.
        /// A nonsystem key is a key that is pressed when the ALT key is not pressed.
        /// </summary>
        public const int WM_KEYDOWN = 0x0100;

        /// <summary>
        /// Posted when the left mouse button is pressed.
        /// </summary>
        public const int WM_LBUTTONDOWN = 0x0201;

        /// <summary>
        /// Posted when the left mouse button is released.
        /// </summary>
        public const int WM_LBUTTONUP = 0x0202;

        /// <summary>
        /// Posted when the right mouse button is pressed.
        /// </summary>
        public const int WM_RBUTTONDOWN = 0x0204;

        /// <summary>
        /// Posted when the right mouse button is released.
        /// </summary>
        public const int WM_RBUTTONUP = 0x0205;

        /// <summary>
        /// Posted when the middle mouse button is pressed.
        /// </summary>
        public const int WM_MBUTTONDOWN = 0x0207;

        /// <summary>
        /// Posted when an X button is pressed.
        /// The specific button (XBUTTON1 or XBUTTON2) is indicated in the high-order word of the mouseData field.
        /// </summary>
        public const int WM_XBUTTONDOWN = 0x020B;

        /// <summary>
        /// First X button identifier (typically the fourth mouse button).
        /// Used to identify which X button was pressed in WM_XBUTTONDOWN events.
        /// </summary>
        public const int XBUTTON1 = 0x0001;

        /// <summary>
        /// Second X button identifier (typically the fifth mouse button).
        /// Used to identify which X button was pressed in WM_XBUTTONDOWN events.
        /// </summary>
        public const int XBUTTON2 = 0x0002;

        /// <summary>
        /// Mouse event flag indicating relative mouse movement.
        /// When used with SendInput, specifies that dx and dy contain relative movement data.
        /// </summary>
        public const uint MOUSEEVENTF_MOVE = 0x0001;

        /// <summary>
        /// Input type constant indicating mouse input.
        /// Used with the INPUT structure to specify that the input event is mouse-related.
        /// </summary>
        public const uint INPUT_MOUSE = 0;

        /// <summary>
        /// Base strength value for recoil calculations.
        /// Used as a multiplier in basic recoil reduction calculations.
        /// </summary>
        public const double BASE_RECOIL_STRENGTH = 0.75;

        /// <summary>
        /// Secondary base strength value for enhanced recoil calculations.
        /// Used as a multiplier in advanced recoil reduction calculations.
        /// </summary>
        public const double BASE_RECOIL_STRENGTH_2 = 2.0;

        /// <summary>
        /// Speed multiplier for the lowest level of movement adjustment.
        /// Applied to movement calculations when minimal adjustment is needed.
        /// </summary>
        public const double LOW_LEVEL_1_SPEED = 0.25;

        /// <summary>
        /// Speed multiplier for the medium-low level of movement adjustment.
        /// Applied to movement calculations when moderate adjustment is needed.
        /// </summary>
        public const double LOW_LEVEL_2_SPEED = 0.5;

        /// <summary>
        /// Speed multiplier for the medium level of movement adjustment.
        /// Applied to movement calculations when significant adjustment is needed.
        /// </summary>
        public const double LOW_LEVEL_3_SPEED = 0.75;
    }
}
</file>

<file path="build.bat">
@echo off
:: Check for admin privileges
net session >nul 2>&1
if %errorLevel% == 0 (
    goto :admin
) else (
    echo Requesting administrative privileges...
    goto :UACPrompt
)

:UACPrompt
echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
echo UAC.ShellExecute "%~s0", "", "", "runas", 1 >> "%temp%\getadmin.vbs"
"%temp%\getadmin.vbs"
del "%temp%\getadmin.vbs"
exit /B

:admin
cd /d "%~dp0"

echo Starting Mouse Macro build process...
echo.

echo === Cleaning solution ===
dotnet clean
if errorlevel 1 goto error

echo === Removing build directories ===
if exist "bin" rmdir /s /q "bin"
if exist "obj" rmdir /s /q "obj"
if errorlevel 1 goto error

echo === Restoring packages ===
dotnet restore
if errorlevel 1 goto error

echo === Building Debug configuration ===
dotnet build -c Debug
if errorlevel 1 goto error

echo === Building Release configuration ===
dotnet build -c Release
if errorlevel 1 goto error

echo.
echo === Build Complete! ===
echo.
echo Debug build: %~dp0bin\Debug\net6.0-windows\NotesAndTasks.exe
echo Release build: %~dp0bin\Release\net6.0-windows\NotesAndTasks.exe
echo.
goto end

:error
echo.
echo Build failed! See error message above.
pause
exit /b 1

:end
echo Press any key to exit...
pause >nul
</file>

<file path="src/MacroForm.resx">
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="notifyIcon.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="trayContextMenu.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>125, 17</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>45</value>
  </metadata>
</root>
</file>

<file path="src/SettingsManager.cs">
using System;
using System.IO;
using Newtonsoft.Json;

namespace NotesAndTasks
{
    public static class SettingsManager
    {
        private static readonly string _configPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "macro_config.json");
        public static Settings CurrentSettings { get; private set; }

        static SettingsManager()
        {
            try
            {
                LoadOrCreateSettings();
            }
            catch (Exception)
            {
                CurrentSettings = new Settings();
                try
                {
                    SaveSettings();
                }
                catch
                {
                    // If we can't save settings, at least we have defaults in memory
                }
            }
        }

        private static void LoadOrCreateSettings()
        {
            if (File.Exists(_configPath))
            {
                string jsonContent = File.ReadAllText(_configPath);
                CurrentSettings = JsonConvert.DeserializeObject<Settings>(jsonContent) ?? new Settings();
            }
            else
            {
                CurrentSettings = new Settings();
                SaveSettings();
            }
        }

        public static void SaveSettings()
        {
            try
            {
                string jsonContent = JsonConvert.SerializeObject(CurrentSettings, Formatting.Indented);
                File.WriteAllText(_configPath, jsonContent);
            }
            catch (Exception)
            {
                // Consider adding logging here if needed
            }
        }
    }
}
</file>

<file path="src/Settings.cs">
using System;

namespace NotesAndTasks
{
    public class Settings
    {
        // Jitter settings
        public int JitterStrength { get; set; } = 3;
        public bool JitterEnabled { get; set; } = false;  
        public bool AlwaysJitterMode { get; set; } = false;

        // Recoil reduction settings
        public int RecoilReductionStrength { get; set; } = 1;
        public bool RecoilReductionEnabled { get; set; } = false;
        public bool AlwaysRecoilReductionMode { get; set; } = false;

        // Key bindings
        public string MacroToggleKey { get; set; } = "Capital";
        public string ModeSwitchKey { get; set; } = "Q";
        
        // UI preferences
        public bool MinimizeToTray { get; set; } = false;
        public bool StartMinimized { get; set; } = false;
    }
}
</file>

<file path="src/Program.cs">
using System;
using System.Threading;
using System.Windows.Forms;
using System.Diagnostics;
using System.Security.Principal;

namespace NotesAndTasks
{
    internal static class Program
    {
        private static Mutex mutex = new Mutex(true, "NotesTasksGlobalMutex");

        [STAThread]
        static void Main()
        {
            try
            {
                // Check for administrative privileges
                WindowsIdentity identity = WindowsIdentity.GetCurrent();
                WindowsPrincipal principal = new WindowsPrincipal(identity);
                bool isAdmin = principal.IsInRole(WindowsBuiltInRole.Administrator);

                if (!isAdmin)
                {
                    // Restart the application with admin rights
                    ProcessStartInfo startInfo = new ProcessStartInfo();
                    startInfo.UseShellExecute = true;
                    startInfo.WorkingDirectory = Environment.CurrentDirectory;
                    startInfo.FileName = Application.ExecutablePath;
                    startInfo.Verb = "runas";

                    try
                    {
                        Process.Start(startInfo);
                        return;
                    }
                    catch (Exception)
                    {
                        MessageBox.Show("This application requires administrative privileges to run.", "Notes&Tasks",
                            MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }
                }

                // Try to get mutex ownership
                if (!mutex.WaitOne(TimeSpan.Zero, true))
                {
                    MessageBox.Show("Another instance of Notes&Tasks is already running.", "Notes&Tasks", 
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // Optimize process settings for background operation alongside games
                using (Process currentProcess = Process.GetCurrentProcess())
                {
                    // Set process priority to BelowNormal to avoid competing with games
                    currentProcess.PriorityClass = ProcessPriorityClass.BelowNormal;

                    // Set CPU affinity to use last core
                    // This keeps the macro off the primary cores that games typically use
                    if (Environment.ProcessorCount > 1)
                    {
                        int lastCore = Environment.ProcessorCount - 1;
                        currentProcess.ProcessorAffinity = (IntPtr)(1 << lastCore);
                    }

                    // Enable Windows 11 Efficiency Mode
                    // This helps reduce resource competition with games
                    try
                    {
                        if (Environment.OSVersion.Version.Build >= 22621) // Windows 11 22H2 build
                        {
                            currentProcess.ProcessorAffinity = currentProcess.ProcessorAffinity;
                        }
                    }
                    catch (Exception) { /* Ignore if not supported */ }
                }

                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);

                try
                {
                    Application.Run(new MacroForm());
                }
                finally
                {
                    // Release mutex when application exits
                    mutex.ReleaseMutex();
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"An error occurred: {ex.Message}", "Notes&Tasks Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                mutex.Dispose();
            }
        }
    }
}
</file>

<file path="MouseMacro.csproj">
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net6.0-windows</TargetFramework>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
    <UacUIApproved>true</UacUIApproved>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <AssemblyName>Notes&amp;Tasks</AssemblyName>
    <RootNamespace>Notes&amp;Tasks</RootNamespace>
    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>
    <ApplicationIcon>assets\logo.ico</ApplicationIcon>
    <Title>Notes &amp; Tasks</Title>
    <Authors>HaikalllP</Authors>
    <Description>Task Management and Note Taking Application</Description>
    <SignAssembly>true</SignAssembly>
    <EnableUnsafeBinaryFormatterSerialization>true</EnableUnsafeBinaryFormatterSerialization>
    <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
    <Version>1.0.0.1</Version> <!-- Incrementing the version for the next release -->
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DebugType>embedded</DebugType>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
    <DebugType>none</DebugType>
    <Optimize>true</Optimize>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="src\**\*.cs" />
  </ItemGroup>

  <ItemGroup>
    <Compile Include="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
</Project>
</file>

<file path=".gitignore">
# Build output directories
bin/*
obj/*

# Visual Studio files
.vs/
*.user
*.suo

# Temporary files
*.tmp
*.bak

# Log files
*.log

# User-specific configuration
*.userprefs

# Nuget packages (if using NuGet)
*.nupkg
obj/Debug/net6.0-windows/MouseMacro.assets.cache
obj/Debug/net6.0-windows/MouseMacro.GeneratedMSBuildEditorConfig.editorconfig

# RepoMix
.cursor/*
.git/*
.idea/*
.vs/*
.vscode/*
.repomix/*
bin/*
obj/*
</file>

<file path="docs/architecture.md">
# Mouse Macro Application Architecture

## Introduction
This document provides an overview of the Mouse Macro Application architecture. The application is designed to create and manage mouse macros, featuring a modern dark-themed UI for keybind configuration and settings management.IMPORTANT For professional system integration the application presents itself as "Notes&Tasks" and "NotesAndTasks" 😊.

## System Overview

### Identity & Integration
- **Process Name**: NotesTasks.exe
- **Display Name**: Notes&Tasks
- **Window Title**: Notes&Tasks - [Status]
- **System Tray**: Notes&Tasks with corresponding icon
- **Design Rationale**:
  - Professional appearance in enterprise environments
  - Discrete system integration
  - Consistent branding across interfaces

### System Requirements
1. **Hardware**
   - Windows 10/11 compatible PC
   - DirectX compatible display
   - Mouse with standard buttons
   - Keyboard for hotkey support
   - Optional: Multi-button mouse, high refresh rate display, SSD

2. **Software**
   - Windows 10/11 (64-bit)
   - .NET 6.0 Runtime
   - Administrator privileges
   - DirectX 9.0c or later

## Project Structure

### Directory Organization
```
MouseMacro/
├── assets/                  # Application resources
│   ├── logo.ico            # Application icon
├── bin/                    # Compiled binaries
│   ├── Debug/             # Debug build output
│   └── Release/           # Release build output
├── docs/                   # Documentation
├── obj/                    # Intermediate build files
│   ├── Debug/             # Debug build intermediates
│   │   └── net6.0-windows/
│   │       ├── ref/       # Assembly reference files
│   │       ├── refint/    # Reference interface files
│   │       └── *.cache    # Build cache files
│   └── Release/           # Release build intermediates
├── src/                    # Source code
│   ├── MacroForm.cs       # Main form implementation
│   ├── MacroForm.Designer.cs # Form designer code
│   ├── ModernButton.cs    # Custom button control
│   ├── ModernTrackBar.cs  # Custom trackbar control
│   └── Program.cs         # Application entry point
├── MouseMacro.csproj      # Project configuration
├── README.md              # Project documentation and setup guide
└── app.manifest           # Application manifest
```

## Core Components

### 1. Input System
- **Low-Level Hooks**
  - Keyboard Hook (WH_KEYBOARD_LL)
  - Mouse Hook (WH_MOUSE_LL)
  - Global event capture
  
- **Input Simulation**
  - SendInput API implementation
  - Physical mouse movement simulation
  - Game compatibility optimizations

- **Toggle System**
  - Keyboard key support
  - Mouse button support (Mouse3-5)
  - State tracking via GetAsyncKeyState

### 2. Macro Engine
- **Recoil Reduction System**
  - Vertical compensation
  - Three-tier strength distribution:
    - Tier 1 (1-6): Linear scaling
    - Tier 2 (7-16): Enhanced scaling
    - Tier 3 (17-20): Maximum impact
  - Dynamic strength adjustment
  - Default strength: 1
  
- **Jitter System**
  - Complex movement patterns
  - Strength control (1-20)
  - Optional activation
  - Default strength: 3
  
- **Mode Switching**
  - Toggle between Jitter and Recoil Reduction modes
  - Default switch key: Q
  - Always mode options (locks to either Jitter or Recoil Reduction mode at all times)
  - Independent mode states

- **Timer Management**
  - Dual timer implementation
  - Independent operation
  - Performance optimized

### 3. User Interface
- **Main Window**
  - Modern dark theme with consistent color scheme
  - Responsive layout with fluid transitions
  - DPI scaling support
  - Professional visual design
  
- **Custom Controls**
  - ModernButton
    - Customizable hover and click effects
    - Smooth color transitions
    - Consistent styling with theme
    - Professional rounded corners
  - ModernTrackBar
    - Custom slider design
    - Visual value feedback
    - Smooth drag operations
    - Theme-consistent appearance
  
- **Standard Controls**
  - Macro Toggle key display/configuration (Default: Capital)
  - Macro Switch key configuration (Default: Q)
  - Strength sliders (1-20)
  - Mode toggles and indicators
  - Always mode checkboxes
  - Debug panel (collapsible)
  
- **System Tray**
  - Minimize to tray support
  - Context menu
  - Status indication

### 4. Process Management
- **Instance Control**
  - Global mutex implementation
  - Single instance enforcement
  - Clean termination handling
  
- **Security**
  - UAC integration
  - Privilege management
  - Secure API access

### 5. Settings Configuration System
- **Configuration Manager (`ConfigurationManager.cs`)**
  - Singleton pattern implementation
  - Thread-safe operations using `ReaderWriterLockSlim`
  - JSON-based configuration storage
  - Automatic configuration backup
  - Event-driven configuration changes
  - Validation system

#### 5.1 Configuration Components
```csharp
// Root configuration
public class AppConfiguration : ICloneable
{
    public JitterConfiguration JitterSettings { get; set; }
    public RecoilConfiguration RecoilSettings { get; set; }
    public HotkeyConfiguration HotkeySettings { get; set; }
    public UIConfiguration UISettings { get; set; }
    public BackupConfiguration BackupSettings { get; set; }
}

// Feature-specific configurations
public class JitterConfiguration : ICloneable
public class RecoilConfiguration : ICloneable
public class HotkeyConfiguration : ICloneable
public class UIConfiguration : ICloneable
public class BackupConfiguration : ICloneable
```

#### 5.2 Configuration Events
```csharp
// Event Arguments
public class ConfigurationChangedEventArgs : EventArgs
public class ConfigurationValidationEventArgs : EventArgs
public class ConfigurationBackupEventArgs : EventArgs

// Event Handlers
public delegate void ConfigurationChangedEventHandler(object sender, ConfigurationChangedEventArgs e);
public delegate void ConfigurationValidationEventHandler(object sender, ConfigurationValidationEventArgs e);
public delegate void ConfigurationBackupEventHandler(object sender, ConfigurationBackupEventArgs e);
```

#### 5.3 Configuration Validation
```csharp
public static class Validation
{
    // Core validation methods
    public static void ValidateStrength(int strength, int minValue, int maxValue, string paramName)
    public static void ValidateStringNotNullOrEmpty(string value, string paramName)
    public static void ValidateNotNull<T>(T value, string paramName)
    public static void ValidateHandle(IntPtr handle, string paramName)
    public static bool ValidateHookCode(int nCode)
}

public static class SettingsValidation
{
    // Settings-specific validation
    public static bool ValidateSettings(Settings settings, int minStrength, int maxStrength)
    public static bool IsValidHotkey(Keys key)
    public static bool ValidateStrengthValue(int strength, int min, int max)
    public static bool ValidateModeStates(bool jitterEnabled, bool recoilEnabled)
}
```

#### Validation Features
1. **Input Validation**
   - Parameter validation
   - Range checking
   - Null checks
   - Empty string prevention
   
2. **Settings Validation**
   - Configuration integrity
   - Hotkey validation
   - Mode state validation
   - Strength range validation
   
3. **Handle Validation**
   - Windows handle validation
   - Hook code validation
   - Resource validation

4. **Recovery Mechanisms**
   - Default value fallback
   - State preservation
   - Error reporting
   - Automatic recovery

### 5.4 Error Handling

#### 1. Validation Errors
```csharp
try
{
    Validation.ValidateStrength(strength, min, max, paramName);
}
catch (ArgumentOutOfRangeException ex)
{
    // Reset to default value
    strength = defaultValue;
    UpdateDebugInfo($"Reset to default strength: {ex.Message}");
}
```

#### 2. Runtime Errors
```csharp
try
{
    // Critical operation
}
catch (Exception ex)
{
    UpdateDebugInfo($"Error: {ex.Message}");
    // Cleanup and recovery
    CleanupResources();
    RestoreState();
}
```

#### 3. Resource Management
```csharp
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        // Cleanup resources
        jitterTimer?.Dispose();
        keyboardHookID = IntPtr.Zero;
        mouseHookID = IntPtr.Zero;
    }
    base.Dispose(disposing);
}
```

#### 4. Debug System
```csharp
private void UpdateDebugInfo(string message)
{
    if (debugLabel.InvokeRequired)
    {
        debugLabel.Invoke(new Action(() => UpdateDebugInfo(message)));
        return;
    }

    string timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
    string newLine = $"[{timestamp}] {message}";
    
    // Keep last 100 lines
    var lines = debugLabel.Lines.ToList();
    lines.Add(newLine);
    if (lines.Count > 100)
        lines.RemoveAt(0);
        
    debugLabel.Lines = lines.ToArray();
    debugLabel.SelectionStart = debugLabel.TextLength;
    debugLabel.ScrollToCaret();
}
```

### 6. Event Handler System

#### 6.1 Event Handler Manager
```csharp
public class EventHandlerManager : IDisposable
{
    private readonly Dictionary<string, List<Delegate>> eventHandlers;
    private readonly ConfigurationManager configManager;
    
    // Event registration methods
    public void RegisterControlEvents(Control control)
    public void UnregisterControlEvents(Control control)
    private void RegisterEventHandler(string eventName, Delegate handler)
    
    // Configuration event handlers
    private void OnConfigurationChanged(object sender, ConfigurationChangedEventArgs e)
    private void OnConfigurationValidating(object sender, ConfigurationValidationEventArgs e)
    private void OnConfigurationBackupCompleted(object sender, ConfigurationBackupEventArgs e)
}
```

#### 6.2 Event Handler Extensions
```csharp
public static class EventHandlerExtensions
{
    // Generic registration
    public static T RegisterEvents<T>(this T control, EventHandlerManager manager)
    public static T UnregisterEvents<T>(this T control, EventHandlerManager manager)
    
    // Control-specific registration
    public static TrackBar RegisterTrackBarEvents(...)
    public static CheckBox RegisterCheckBoxEvents(...)
    public static Button RegisterButtonEvents(...)
    public static TextBox RegisterTextBoxEvents(...)
}
```

#### 6.3 Event Categories
1. **Configuration Events**
   - Configuration changes
   - Validation events
   - Backup events

2. **Control Events**
   - TrackBar events (ValueChanged, Scroll)
   - CheckBox events (CheckedChanged)
   - Button events (Click, MouseDown, MouseUp)
   - TextBox events (TextChanged, KeyDown)

3. **System Events**
   - Window events
   - Application lifecycle events
   - Error events

#### 6.4 Event Handler Features
- Centralized event management
- Automatic cleanup on disposal
- Type-safe event registration
- Fluent API support
- Event tracking and logging
- Error handling and recovery

### 7. Project Structure Update
```
MouseMacro/
├── src/
│   ├── Configuration/           # Configuration system
│   │   ├── ConfigurationManager.cs
│   │   ├── AppConfiguration.cs
│   │   ├── ConfigurationEvents.cs
│   │   ├── EventHandlerManager.cs
│   │   └── EventHandlerExtensions.cs
│   ├── Controls/               # UI Controls
│   │   ├── ModernButton.cs
│   │   └── ModernTrackBar.cs
│   ├── MacroForm.cs           # Main form
│   ├── MacroForm.Designer.cs  # Form designer
│   └── Program.cs             # Entry point
```

## Macro Implementation Details

### 1. Core Macro Logic
- **Language**: C#
- **Primary Components**:
  - Recoil reduction system
  - Jitter pattern generation
  - State management
  - Timer-based execution

#### 1.1 Recoil Reduction System
- **Implementation**:
  ```csharp
  private void OnRecoilReductionTimer(object state)
  {
      if (IsRecoilReductionActive)
      {
          int strength = recoilReductionStrength.Value;
          int scaledStrength = CalculateScaledStrength(strength);
          SendInput.MoveMouse(0, scaledStrength);
      }
  }

  private int CalculateScaledStrength(int strength)
  {
      if (strength <= 6) // Tier 1
          return strength;
      else if (strength <= 13) // Tier 2
          return 6 + (strength - 6) * 2;
      else // Tier 3
          return 20 + (strength - 13) * 3;
  }
  ```
- **Features**:
  - Vertical movement compensation
  - Three-tier strength scaling system
  - Dynamic strength calculation
  - Optimized performance
  - Smooth movement patterns

#### 1.2 Jitter System
- **Pattern Definition**:
  ```csharp
  private readonly (int dx, int dy)[] jitterPattern = {
      (0, 6), (7, 7), (-7, -7), (7, -7), (-7, 7),
      (0, -6), (-6, 0), (6, 0), (5, 5), (-5, -5)
  };
  ```
- **Implementation**:
  ```csharp
  private void OnJitterTimer(object state)
  {
      if (IsJitterActive && currentPattern < jitterPattern.Length)
      {
          var (dx, dy) = jitterPattern[currentPattern];
          SendInput.MoveMouse(
              dx * jitterStrength.Value / 10,
              dy * jitterStrength.Value / 10
          );
          currentPattern = (currentPattern + 1) % jitterPattern.Length;
      }
  }
  ```
- **Features**:
  - Complex movement patterns
  - Pattern cycling
  - Strength scaling
  - Independent activation

### 2. State Management

#### 2.1 Activation States
```csharp
private bool IsRecoilReductionActive => 
    MacroEnabled && 
    (GetAsyncKeyState(VK_LBUTTON) < 0) && 
    (GetAsyncKeyState(VK_RBUTTON) < 0);

private bool IsJitterActive =>
    MacroEnabled && 
    (JitterEnabled || alwaysJitterMode) && 
    !alwaysRecoilReductionMode && 
    IsRecoilReductionActive;
```

#### 2.2 Mode Management
```csharp
private void ToggleMacroMode()
{
    // If either always mode is on, we can't switch modes
    if (alwaysJitterMode || alwaysRecoilReductionMode)
        return;

    // Toggle between jitter and recoil reduction modes
    jitterEnabled = !jitterEnabled;
    UpdateModeLabels();
}

private void UpdateModeLabels()
{
    lblJitterActive.Text = jitterEnabled || alwaysJitterMode ? "[Active]" : "";
    lblRecoilReductionActive.Text = !jitterEnabled || alwaysRecoilReductionMode ? "[Active]" : "";
}
```

#### 2.3 Toggle System
- **Keyboard Implementation**:
  ```csharp
  private IntPtr KeyboardProc(int nCode, IntPtr wParam, IntPtr lParam)
  {
      if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
      {
          var kb = (KBDLLHOOKSTRUCT)Marshal.PtrToStructure(lParam, typeof(KBDLLHOOKSTRUCT));
          if (kb.vkCode == ToggleKey)
          {
              MacroEnabled = !MacroEnabled;
              UpdateWindowTitle();
          }
      }
      return CallNextHookEx(KeyboardHook, nCode, wParam, lParam);
  }
  ```

- **Mouse Implementation**:
  ```csharp
  private IntPtr MouseProc(int nCode, IntPtr wParam, IntPtr lParam)
  {
      if (nCode >= 0)
      {
          var mouseData = (MSLLHOOKSTRUCT)Marshal.PtrToStructure(lParam, typeof(MSLLHOOKSTRUCT));
          if (wParam == (IntPtr)WM_XBUTTONDOWN)
          {
              int button = mouseData.mouseData >> 16;
              if (button == ToggleButton)
              {
                  MacroEnabled = !MacroEnabled;
                  UpdateWindowTitle();
              }
          }
      }
      return CallNextHookEx(MouseHook, nCode, wParam, lParam);
  }
  ```

### 3. Timer System

#### 3.1 Timer Configuration
```csharp
private readonly System.Windows.Forms.Timer recoilReductionTimer;
private readonly System.Windows.Forms.Timer jitterTimer;

private void InitializeTimers()
{
    recoilReductionTimer = new System.Windows.Forms.Timer
    {
        Interval = 16,  // ~60Hz
        Enabled = true
    };
    recoilReductionTimer.Tick += OnRecoilReductionTimer;

    jitterTimer = new System.Windows.Forms.Timer
    {
        Interval = 25,  // 40Hz
        Enabled = true
    };
    jitterTimer.Tick += OnJitterTimer;
}
```

#### 3.2 Performance Optimization
- **Timer Intervals**:
  - Recoil Reduction: 16ms (60Hz) for smooth movement
  - Jitter: 25ms (40Hz) for pattern execution
  - Balanced for performance and responsiveness

- **Resource Management**:
  ```csharp
  protected override void Dispose(bool disposing)
  {
      if (disposing)
      {
          recoilReductionTimer?.Dispose();
          jitterTimer?.Dispose();
      }
      base.Dispose(disposing);
  }
  ```

### 4. Input Simulation

#### 4.1 SendInput Implementation
```csharp
public static class SendInput
{
    [DllImport("user32.dll")]
    private static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

    public static void MoveMouse(int dx, int dy)
    {
        var input = new INPUT
        {
            type = INPUT_MOUSE,
            u = new InputUnion
            {
                mi = new MOUSEINPUT
                {
                    dx = dx,
                    dy = dy,
                    mouseData = 0,
                    dwFlags = MOUSEEVENTF_MOVE,
                    time = 0,
                    dwExtraInfo = IntPtr.Zero
                }
            }
        };

        SendInput(1, new[] { input }, Marshal.SizeOf(typeof(INPUT)));
    }
}
```

#### 4.2 Low-Level Hooks
```csharp
private const int WH_KEYBOARD_LL = 13;
private const int WH_MOUSE_LL = 14;

private IntPtr SetWindowsHookEx(int idHook, HookProc lpfn)
{
    using var curProcess = Process.GetCurrentProcess();
    using var curModule = curProcess.MainModule;
    return SetWindowsHookEx(idHook, lpfn, 
        GetModuleHandle(curModule.ModuleName), 0);
}
```

### 5. Debug System

#### 5.1 State Monitoring
```csharp
private void UpdateDebugInfo()
{
    if (debugTextBox.Visible)
    {
        var info = $"[{DateTime.Now:HH:mm:ss.fff}] " +
                   $"Macro: {(MacroEnabled ? "ON" : "OFF")} | " +
                   $"Recoil Reduction: {(IsRecoilReductionActive ? "Active" : "Inactive")} | " +
                   $"Jitter: {(IsJitterActive ? "Active" : "Inactive")} | " +
                   $"LMB: {(GetAsyncKeyState(VK_LBUTTON) < 0)} | " +
                   $"RMB: {(GetAsyncKeyState(VK_RBUTTON) < 0)}";
        
        debugTextBox.AppendText(info + Environment.NewLine);
    }
}
```

#### 5.2 Performance Monitoring
```csharp
private readonly Stopwatch perfTimer = new();
private void MeasurePerformance(Action action, string operation)
{
    if (debugTextBox.Visible)
    {
        perfTimer.Restart();
        action();
        perfTimer.Stop();
        
        UpdateDebugInfo($"{operation}: {perfTimer.ElapsedMilliseconds}ms");
    }
    else
    {
        action();
    }
}
```

## Build System

### Configurations
1. **Debug Build**
   - Location: `bin/Debug/net6.0-windows/`
   - Debug symbols and logging
   - Development features enabled
   
2. **Release Build**
   - Location: `bin/Release/net6.0-windows/`
   - Optimized performance
   - Production ready

### Build Process
- **Automated Script**: `build.bat`
  - Admin privilege elevation
  - Environment preparation
  - Dual configuration builds
  - Error handling

## Usage Guide

### Application Lifecycle
1. **Startup**
   - Admin rights elevation
   - Single instance check
   - System tray initialization

2. **Runtime**
   - Background operation
   - Resource optimization
   - State management
   
3. **Shutdown**
   - Clean termination
   - Resource cleanup
   - Settings preservation

### Troubleshooting
1. **Common Issues**
   - Instance conflicts
   - Admin privileges
   - Performance optimization
   - Resource management

2. **Debug Mode**
   - Real-time monitoring
   - Event logging
   - Performance metrics
   - Error tracking

## Performance Optimization
1. **Resource Management**
   - Efficient hook handling
   - Minimal GC impact
   - Handle management
   
2. **CPU Usage**
   - Timer optimization
   - Event throttling
   - Efficient state checks

## Security Considerations
1. **Process Protection**
   - Mutex implementation
   - Process name obfuscation
   
2. **Privilege Management**
   - Manifest-based elevation
   - Runtime privilege checks
   - Secure API access

## Maintenance
1. **Regular Updates**
   - Runtime compatibility
   - Security patches
   - Feature updates
   
2. **Code Maintenance**
   - Performance optimization
   - Security audits
   - Documentation updates
</file>

<file path="README.md">
# Notes & Tasks (Mouse Macro)

A professional Windows Forms application for advanced mouse input management, featuring recoil compensation and jitter pattern generation. IMPORTANT For professional system integration the application presents itself as "Notes&Tasks" and "NotesAndTasks" 😊.

## Features

- **Recoil Reduction System**
  - Advanced vertical compensation with three-tier scaling:
    - Tier 1 (1-6): Linear scaling with logarithmic base
    - Tier 2 (7-16): Enhanced scaling with 1.2x multiplier
    - Tier 3 (17-20): Exponential scaling with dynamic boost
  - Real-time strength adjustment (1-20)
  - Default strength: 1
  - Optimized movement patterns

- **Jitter System**
  - Complex 24-point movement pattern
  - Dynamic strength scaling (1-20)
  - Default strength: 3
  - Pattern cycling with smooth transitions
  - Optimized for performance

- **Mode Switching**
  - Intelligent mode toggling
  - Support for keyboard and mouse buttons (Mouse3-5)
  - Always mode options with validation
  - Real-time mode state tracking
  - Visual state indicators

- **Professional Integration**
  - Clean system tray integration
  - Modern dark theme UI
  - DPI-aware scaling
  - Single instance enforcement
  - Professional window management

- **Configuration Management System**
  - Thread-safe configuration handling
  - JSON-based settings storage
  - Automatic configuration backup
  - Comprehensive validation system:
    - Pre-save validation
    - Type validation
    - Range validation
    - Cross-property validation
  - Event-driven updates
  - Configuration sections:
    - Jitter settings
    - Recoil reduction settings
    - Hotkey bindings
    - UI preferences
    - Backup settings

- **Event Handler System**
  - Centralized event management
  - Automatic resource cleanup
  - Type-safe event registration
  - Fluent API for control events
  - Comprehensive error handling:
    - Exception tracking
    - State recovery
    - Debug logging
  - Event categories:
    - Configuration events
    - Control events
    - System events

- **Debug System**
  - Real-time state monitoring
  - Performance tracking
  - Event logging
  - Error tracking
  - Thread-safe logging

- **Settings Saved with JSON**
  - Settings saved automatically into a JSON file
  - JSON file located at the executable directory
  - Settings automatically saved while running the Application
  - Settings automatically loaded upon starting the Application

## Requirements

### Hardware
- Windows 10/11 compatible PC
- DirectX compatible display
- Mouse with standard buttons
- Keyboard for hotkey support

### Software
- Windows 10/11 (64-bit)
- .NET 6.0 Runtime
- Administrator privileges
- DirectX 9.0c or later

### Optional
- Multi-button mouse for extended features
- High refresh rate display (recommended)
- SSD for faster startup (recommended)

## Installation

1. **Download**
   - Get the latest release from the releases page
   - Choose between Debug and Release builds

2. **Setup**
   - Extract the files to your preferred location
   - No installation required (portable application)
   - Run `NotesAndTasks.exe` with administrator privileges

## Building from Source

### Method 1: Using Build Script
1. Clone the repository
2. Double-click `build.bat`
   - Script automatically requests admin rights
   - Builds both Debug and Release configurations

### Method 2: Manual Build
1. Open command prompt
2. Navigate to project directory
3. Run commands:
   ```cmd
   # Debug build
   dotnet build -c Debug

   # Release build
   dotnet build -c Release
   ```

### Output Locations
- Debug: `bin/Debug/net6.0-windows/NotesAndTasks.exe`
- Release: `bin/Release/net6.0-windows/NotesAndTasks.exe`

## Usage Guide

### Basic Controls
1. **Macro Toggle Key (Macro ON/OFF)**
   - Click "Set Toggle Key" button
   - Press any key to set as macro toggle
   - Default: 'Capital' key
   - Supports keyboard and mouse buttons (Mouse3-5)
   - LMB/RMB reserved for activation

2. **Mode Switch Key**
   - Click "Set Switch Key" button
   - Press any key to set as switch toggle
   - Default: 'Q' key
   - Supports keyboard and mouse buttons (Mouse3-5)
   - LMB/RMB reserved for activation

3. **Strength Adjustment**
   - Use slider to set strength (1-20)
   - Changes apply immediately
   - Recoil Reduction default: 1
   - Jitter default: 3

4. **Always Mode Options**
   - Always Jitter Mode: Locks to jitter
   - Always Recoil Reduction Mode: Locks to recoil reduction
   - Prevents mode switching while active

5. **System Tray**
   - Optional minimize to tray
   - Double-click tray icon to restore
   - Right-click for context menu
   - Clean exit via tray menu

### Usage Scenarios

#### 1. Dynamic Mode Switching
```
1. Press Toggle Key → Macro ON
2. Press Q to switch between modes
3. Hold LMB + RMB → Current mode activates
4. Release buttons → Effect stops
5. Press Q again → Switch to other mode
```

#### 2. Always Jitter Mode
```
1. Enable "Always Jitter Mode" checkbox
2. Press Toggle Key → Macro ON
3. Hold LMB + RMB → Jitter pattern active
4. Release buttons → Jitter stops
5. Q key has no effect (locked to jitter)
```

#### 3. Always Recoil Reduction Mode
```
1. Enable "Always Recoil Reduction Mode"
2. Press Toggle Key → Macro ON
3. Hold LMB + RMB → Recoil reduction active
4. Release buttons → Effect stops
5. Q key has no effect (locked to recoil reduction)
```

#### 4. Strength Optimization
```
1. Start with default strengths:
   - Recoil Reduction: 1
   - Jitter: 3
2. Test each mode
3. Adjust strength per mode as needed
4. Settings persist between mode switches
```

### Important Notes
- Effects ONLY activate when BOTH buttons are held
- Mode switch key (Q) works in real-time
- Always mode prevents accidental switching
- Each mode maintains its own strength setting
- Visual indicators show current active mode
- Window title reflects current state

### Settings Configuration
- **Configuration Manager**
  - Thread-safe operations with ReaderWriterLockSlim
  - Automatic backups with versioning
  - Real-time validation with error recovery
  - Event notifications with detailed state
  
- **Validation System**
  - Comprehensive input validation
  - Type safety checks
  - Range validation
  - Cross-property validation
  - Error reporting with context
  - Recovery mechanisms

- **Event System**
  - Configuration change tracking
  - Validation event handling
  - Backup completion notifications
  - Error event propagation
  - State change notifications

### Error Handling
- **Validation Errors**
  - Automatic recovery
  - Default value fallback
  - User notification
  - State preservation

- **Runtime Errors**
  - Exception handling
  - Resource cleanup
  - State recovery
  - Debug logging
  - User feedback

## Troubleshooting

### Common Issues

1. **"Another instance is running"**
   - Check Task Manager
   - End existing process if necessary
   - Restart application

2. **Admin Rights Required**
   - Run as administrator
   - Use build.bat for automatic elevation
   - Check app.manifest settings

3. **Performance Issues**
   - Switch to Release build
   - Check system resources
   - Adjust timer intervals
   - Monitor debug panel

## Development

### Environment Setup
1. Install Visual Studio 2022 or later
2. Install .NET 6.0 SDK
3. Clone repository
4. Open solution file

### Project Structure
```
MouseMacro/
├── assets/                  # Application resources
│   ├── logo.ico            # Application icon
├── bin/                    # Compiled binaries
│   ├── Debug/             # Debug build output
│   └── Release/           # Release build output
├── docs/                   # Documentation
│   ├── architecture.md    # Detailed architecture documentation
├── src/                   # Source code
│   ├── Configuration/     # Configuration system
│   │   ├── ConfigurationManager.cs
│   │   ├── AppConfiguration.cs
│   │   ├── ConfigurationEvents.cs
│   │   ├── EventHandlerManager.cs
│   │   ├── EventHandlerExtensions.cs
│   │   ├── SettingsValidation.cs
│   │   └── Validation.cs
│   ├── Controls/         # UI Controls
│   │   ├── ModernButton.cs
│   │   └── ModernTrackBar.cs
│   ├── MacroForm.cs      # Main form implementation
│   ├── MacroForm.Designer.cs
│   ├── NativeMethods.cs  # Windows API interop
│   ├── WinMessages.cs    # Windows message constants
│   └── Program.cs        # Application entry point
├── MouseMacro.csproj     # Project configuration
├── README.md             # Project documentation
└── app.manifest         # Application manifest
```

## Contributing
1. Fork the repository
2. Create feature branch
3. Commit changes
4. Submit pull request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- Windows Forms (.NET 6.0)
- Windows API (user32.dll)
- .NET Community
</file>

<file path="src/MacroForm.Designer.cs">
namespace NotesAndTasks
{
    partial class MacroForm
    {
        /// <summary>
        ///  Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        ///  Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (components != null)
                {
                    components.Dispose();
                }

                if (jitterTimer != null)
                {
                    jitterTimer.Change(Timeout.Infinite, Timeout.Infinite);
                    jitterTimer.Dispose();
                }

                if (keyboardHookID != IntPtr.Zero)
                {
                    NativeMethods.UnhookWindowsHookEx(keyboardHookID);
                    keyboardHookID = IntPtr.Zero;
                }

                if (mouseHookID != IntPtr.Zero)
                {
                    NativeMethods.UnhookWindowsHookEx(mouseHookID);
                    mouseHookID = IntPtr.Zero;
                }

                if (notifyIcon != null)
                {
                    notifyIcon.Visible = false;
                    notifyIcon.Dispose();
                }

                if (toolTip != null)
                {
                    toolTip.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        ///  Required method for Designer support - do not modify
        ///  the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
            mainPanel = new Panel();
            debugPanel = new Panel();
            debugLabel = new TextBox();
            btnToggleDebug = new ModernButton();
            strengthPanel1 = new Panel();
            lblRecoilReductionStrengthValue = new Label();
            lblRecoilReductionStrengthPrefix = new Label();
            trackBarRecoilReduction = new ModernTrackBar();
            lblRecoilReductionActive = new Label();
            strengthPanel2 = new Panel();
            lblJitterStrengthValue = new Label();
            lblJitterStrengthPrefix = new Label();
            trackBarJitter = new ModernTrackBar();
            lblJitterActive = new Label();
            settingsPanel = new Panel();
            lblCurrentKeyValue = new Label();
            lblCurrentKeyPrefix = new Label();
            btnSetKey = new ModernButton();
            chkMinimizeToTray = new CheckBox();
            lblMacroSwitchKeyValue = new Label();
            btnSetMacroSwitch = new ModernButton();
            lblMacroSwitchKeyPrefix = new Label();
            chkAlwaysJitter = new CheckBox();
            chkAlwaysRecoilReduction = new CheckBox();
            notifyIcon = new NotifyIcon(components);
            trayContextMenu = new ContextMenuStrip(components);
            showWindowMenuItem = new ToolStripMenuItem();
            exitMenuItem = new ToolStripMenuItem();
            mainPanel.SuspendLayout();
            debugPanel.SuspendLayout();
            strengthPanel1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarRecoilReduction).BeginInit();
            strengthPanel2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarJitter).BeginInit();
            settingsPanel.SuspendLayout();
            trayContextMenu.SuspendLayout();
            SuspendLayout();
            // 
            // mainPanel
            // 
            mainPanel.Dock = DockStyle.Fill;
            mainPanel.BackColor = Color.FromArgb(16, 2, 31);
            mainPanel.Controls.Add(debugPanel);
            mainPanel.Controls.Add(btnToggleDebug);
            mainPanel.Controls.Add(strengthPanel1);
            mainPanel.Controls.Add(strengthPanel2);
            mainPanel.Controls.Add(settingsPanel);
            mainPanel.Controls.Add(chkAlwaysJitter);
            mainPanel.Controls.Add(chkAlwaysRecoilReduction);
            mainPanel.Location = new Point(0, 0);
            mainPanel.Margin = new Padding(3, 2, 3, 2);
            mainPanel.Name = "mainPanel";
            mainPanel.Padding = new Padding(14, 12, 14, 12);
            mainPanel.Size = new Size(477, 676);
            mainPanel.TabIndex = 0;
            // 
            // debugPanel
            // 
            debugPanel.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            debugPanel.AutoScroll = true;
            debugPanel.BackColor = Color.FromArgb(214, 37, 106);
            debugPanel.BorderStyle = BorderStyle.FixedSingle;
            debugPanel.Controls.Add(debugLabel);
            debugPanel.Location = new Point(20, 541);
            debugPanel.Margin = new Padding(3, 2, 3, 2);
            debugPanel.Name = "debugPanel";
            debugPanel.Padding = new Padding(7, 6, 7, 6);
            debugPanel.Size = new Size(438, 124);
            debugPanel.TabIndex = 7;
            debugPanel.Visible = false;
            // 
            // debugLabel
            // 
            debugLabel.BackColor = Color.FromArgb(16, 2, 31);
            debugLabel.BorderStyle = BorderStyle.None;
            debugLabel.Dock = DockStyle.Fill;
            debugLabel.Font = new Font("JetBrains Mono", 9.75F, FontStyle.Regular, GraphicsUnit.Point);
            debugLabel.ForeColor = Color.White;
            debugLabel.Location = new Point(7, 6);
            debugLabel.Margin = new Padding(3, 2, 3, 2);
            debugLabel.Multiline = true;
            debugLabel.Name = "debugLabel";
            debugLabel.ReadOnly = true;
            debugLabel.ScrollBars = ScrollBars.Vertical;
            debugLabel.Size = new Size(422, 110);
            debugLabel.TabIndex = 0;
            // 
            // btnToggleDebug
            // 
            btnToggleDebug.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            btnToggleDebug.BackColor = Color.FromArgb(30, 1, 62);
            btnToggleDebug.BorderColor = Color.FromArgb(250, 91, 101);
            btnToggleDebug.BorderRadius = 10;
            btnToggleDebug.FlatStyle = FlatStyle.Flat;
            btnToggleDebug.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            btnToggleDebug.ForeColor = Color.White;
            btnToggleDebug.HoverBackColor = Color.FromArgb(214, 37, 106);
            btnToggleDebug.Location = new Point(21, 495);
            btnToggleDebug.Margin = new Padding(0, 0, 0, 12);
            btnToggleDebug.Name = "btnToggleDebug";
            btnToggleDebug.Size = new Size(437, 35);
            btnToggleDebug.TabIndex = 5;
            btnToggleDebug.Text = "Show Debug Info";
            btnToggleDebug.UseVisualStyleBackColor = false;
            // 
            // strengthPanel1
            // 
            strengthPanel1.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            strengthPanel1.Controls.Add(lblRecoilReductionStrengthValue);
            strengthPanel1.Controls.Add(lblRecoilReductionStrengthPrefix);
            strengthPanel1.Controls.Add(trackBarRecoilReduction);
            strengthPanel1.Controls.Add(lblRecoilReductionActive);
            strengthPanel1.Location = new Point(20, 225);
            strengthPanel1.Margin = new Padding(0, 0, 0, 12);
            strengthPanel1.Name = "strengthPanel1";
            strengthPanel1.Size = new Size(438, 84);
            strengthPanel1.TabIndex = 9;
            // 
            // lblRecoilReductionStrengthValue
            // 
            lblRecoilReductionStrengthValue.AutoSize = true;
            lblRecoilReductionStrengthValue.Font = new Font("JetBrains Mono", 10F, FontStyle.Bold, GraphicsUnit.Point);
            lblRecoilReductionStrengthValue.ForeColor = Color.White;
            lblRecoilReductionStrengthValue.Location = new Point(212, 6);
            lblRecoilReductionStrengthValue.Margin = new Padding(0);
            lblRecoilReductionStrengthValue.Name = "lblRecoilReductionStrengthValue";
            lblRecoilReductionStrengthValue.Size = new Size(16, 18);
            lblRecoilReductionStrengthValue.TabIndex = 1;
            lblRecoilReductionStrengthValue.Text = "1";
            // 
            // lblRecoilReductionStrengthPrefix
            // 
            lblRecoilReductionStrengthPrefix.AutoSize = true;
            lblRecoilReductionStrengthPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblRecoilReductionStrengthPrefix.ForeColor = Color.White;
            lblRecoilReductionStrengthPrefix.Location = new Point(0, 6);
            lblRecoilReductionStrengthPrefix.Margin = new Padding(0);
            lblRecoilReductionStrengthPrefix.Name = "lblRecoilReductionStrengthPrefix";
            lblRecoilReductionStrengthPrefix.Size = new Size(216, 18);
            lblRecoilReductionStrengthPrefix.TabIndex = 0;
            lblRecoilReductionStrengthPrefix.Text = "Recoil Reduction Strength:";
            // 
            // trackBarRecoilReduction
            // 
            trackBarRecoilReduction.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            trackBarRecoilReduction.Location = new Point(0, 37);
            trackBarRecoilReduction.Margin = new Padding(0);
            trackBarRecoilReduction.Maximum = 20;
            trackBarRecoilReduction.Minimum = 1;
            trackBarRecoilReduction.Name = "trackBarRecoilReduction";
            trackBarRecoilReduction.Size = new Size(438, 45);
            trackBarRecoilReduction.TabIndex = 8;
            trackBarRecoilReduction.ThumbColor = Color.FromArgb(255, 255, 255);
            trackBarRecoilReduction.TickColor = Color.FromArgb(250, 91, 101);
            trackBarRecoilReduction.TrackColor = Color.FromArgb(214, 37, 106);
            trackBarRecoilReduction.Value = 1;
            // 
            // lblRecoilReductionActive (RecoilReduction Active Label)
            // 
            lblRecoilReductionActive.AutoSize = true;
            lblRecoilReductionActive.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblRecoilReductionActive.ForeColor = Color.FromArgb(250, 91, 101);
            lblRecoilReductionActive.Location = new Point(350, 5);
            lblRecoilReductionActive.Name = "lblRecoilReductionActive";
            lblRecoilReductionActive.Size = new Size(0, 20);
            lblRecoilReductionActive.TabIndex = 1;
            lblRecoilReductionActive.TextAlign = ContentAlignment.MiddleRight;
            // 
            // strengthPanel2
            // 
            strengthPanel2.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            strengthPanel2.Controls.Add(lblJitterStrengthValue);
            strengthPanel2.Controls.Add(lblJitterStrengthPrefix);
            strengthPanel2.Controls.Add(trackBarJitter);
            strengthPanel2.Controls.Add(lblJitterActive);
            strengthPanel2.Location = new Point(20, 331);
            strengthPanel2.Margin = new Padding(0, 0, 0, 12);
            strengthPanel2.Name = "strengthPanel2";
            strengthPanel2.Size = new Size(438, 81);
            strengthPanel2.TabIndex = 10;
            // 
            // lblJitterStrengthValue
            // 
            lblJitterStrengthValue.AutoSize = true;
            lblJitterStrengthValue.Font = new Font("JetBrains Mono", 10F, FontStyle.Bold, GraphicsUnit.Point);
            lblJitterStrengthValue.ForeColor = Color.White;
            lblJitterStrengthValue.Location = new Point(132, 6);
            lblJitterStrengthValue.Margin = new Padding(0);
            lblJitterStrengthValue.Name = "lblJitterStrengthValue";
            lblJitterStrengthValue.Size = new Size(16, 18);
            lblJitterStrengthValue.TabIndex = 1;
            lblJitterStrengthValue.Text = "3";
            // 
            // lblJitterStrengthPrefix
            // 
            lblJitterStrengthPrefix.AutoSize = true;
            lblJitterStrengthPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblJitterStrengthPrefix.ForeColor = Color.White;
            lblJitterStrengthPrefix.Location = new Point(0, 6);
            lblJitterStrengthPrefix.Margin = new Padding(0);
            lblJitterStrengthPrefix.Name = "lblJitterStrengthPrefix";
            lblJitterStrengthPrefix.Size = new Size(144, 18);
            lblJitterStrengthPrefix.TabIndex = 0;
            lblJitterStrengthPrefix.Text = "Jitter Strength: ";
            // 
            // trackBarJitter
            // 
            trackBarJitter.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            trackBarJitter.Location = new Point(0, 34);
            trackBarJitter.Margin = new Padding(0);
            trackBarJitter.Maximum = 20;
            trackBarJitter.Minimum = 1;
            trackBarJitter.Name = "trackBarJitter";
            trackBarJitter.Size = new Size(438, 45);
            trackBarJitter.TabIndex = 3;
            trackBarJitter.ThumbColor = Color.FromArgb(255, 255, 255);
            trackBarJitter.TickColor = Color.FromArgb(250, 91, 101);
            trackBarJitter.TrackColor = Color.FromArgb(214, 37, 106);
            trackBarJitter.Value = 3;
            // 
            // lblJitterActive (Jitter Active Label)
            // 
            lblJitterActive.AutoSize = true;
            lblJitterActive.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblJitterActive.ForeColor = Color.FromArgb(250, 91, 101);
            lblJitterActive.Location = new Point(350, 5);
            lblJitterActive.Name = "lblJitterActive";
            lblJitterActive.Size = new Size(0, 20);
            lblJitterActive.TabIndex = 0;
            lblJitterActive.TextAlign = ContentAlignment.MiddleRight;
            lblJitterActive.Click += lblJitterActive_Click;
            // 
            // settingsPanel
            // 
            settingsPanel.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            settingsPanel.Controls.Add(lblCurrentKeyValue);
            settingsPanel.Controls.Add(lblCurrentKeyPrefix);
            settingsPanel.Controls.Add(btnSetKey);
            settingsPanel.Controls.Add(chkMinimizeToTray);
            settingsPanel.Controls.Add(lblMacroSwitchKeyValue);
            settingsPanel.Controls.Add(btnSetMacroSwitch);
            settingsPanel.Controls.Add(lblMacroSwitchKeyPrefix);
            settingsPanel.Location = new Point(20, 25);
            settingsPanel.Margin = new Padding(0, 0, 0, 12);
            settingsPanel.Name = "settingsPanel";
            settingsPanel.Size = new Size(438, 179);
            settingsPanel.TabIndex = 11;
            // 
            // lblCurrentKeyValue
            // 
            lblCurrentKeyValue.AutoSize = true;
            lblCurrentKeyValue.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Bold, GraphicsUnit.Point);
            lblCurrentKeyValue.ForeColor = Color.White;
            lblCurrentKeyValue.Location = new Point(141, 22);
            lblCurrentKeyValue.Margin = new Padding(0);
            lblCurrentKeyValue.Name = "lblCurrentKeyValue";
            lblCurrentKeyValue.Size = new Size(64, 18);
            lblCurrentKeyValue.TabIndex = 1;
            lblCurrentKeyValue.Text = "Capital";
            // 
            // lblCurrentKeyPrefix
            // 
            lblCurrentKeyPrefix.AutoSize = true;
            lblCurrentKeyPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblCurrentKeyPrefix.ForeColor = Color.White;
            lblCurrentKeyPrefix.Location = new Point(0, 21);
            lblCurrentKeyPrefix.Margin = new Padding(0);
            lblCurrentKeyPrefix.Name = "lblCurrentKeyPrefix";
            lblCurrentKeyPrefix.Size = new Size(144, 18);
            lblCurrentKeyPrefix.TabIndex = 0;
            lblCurrentKeyPrefix.Text = "Macro Toggle Key:";
            lblCurrentKeyPrefix.Click += lblCurrentKeyPrefix_Click;
            // 
            // btnSetKey
            // 
            btnSetKey.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            btnSetKey.BackColor = Color.FromArgb(30, 1, 62);
            btnSetKey.BorderColor = Color.FromArgb(250, 91, 101);
            btnSetKey.BorderRadius = 10;
            btnSetKey.FlatStyle = FlatStyle.Flat;
            btnSetKey.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            btnSetKey.ForeColor = Color.White;
            btnSetKey.HoverBackColor = Color.FromArgb(214, 37, 106);
            btnSetKey.Location = new Point(1, 49);
            btnSetKey.Margin = new Padding(0, 0, 0, 12);
            btnSetKey.Name = "btnSetKey";
            btnSetKey.Size = new Size(437, 35);
            btnSetKey.TabIndex = 1;
            btnSetKey.Text = "Set Toggle Key";
            btnSetKey.UseVisualStyleBackColor = false;
            // 
            // chkMinimizeToTray
            // 
            chkMinimizeToTray.Anchor = AnchorStyles.Top | AnchorStyles.Right;
            chkMinimizeToTray.AutoSize = true;
            chkMinimizeToTray.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            chkMinimizeToTray.ForeColor = Color.White;
            chkMinimizeToTray.Location = new Point(280, 3);
            chkMinimizeToTray.Margin = new Padding(3, 2, 3, 2);
            chkMinimizeToTray.Name = "chkMinimizeToTray";
            chkMinimizeToTray.Size = new Size(155, 22);
            chkMinimizeToTray.TabIndex = 6;
            chkMinimizeToTray.Text = "Minimize to Tray";
            chkMinimizeToTray.CheckedChanged += chkMinimizeToTray_CheckedChanged;
            // 
            // lblMacroSwitchKeyValue
            // 
            lblMacroSwitchKeyValue.AutoSize = true;
            lblMacroSwitchKeyValue.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Bold, GraphicsUnit.Point);
            lblMacroSwitchKeyValue.ForeColor = Color.White;
            lblMacroSwitchKeyValue.Location = new Point(148, 105);
            lblMacroSwitchKeyValue.Name = "lblMacroSwitchKeyValue";
            lblMacroSwitchKeyValue.Size = new Size(20, 19);
            lblMacroSwitchKeyValue.TabIndex = 5;
            lblMacroSwitchKeyValue.Text = "Q";
            // 
            // btnSetMacroSwitch
            // 
            btnSetMacroSwitch.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            btnSetMacroSwitch.BackColor = Color.FromArgb(30, 1, 62);
            btnSetMacroSwitch.BorderColor = Color.FromArgb(250, 91, 101);
            btnSetMacroSwitch.BorderRadius = 10;
            btnSetMacroSwitch.FlatStyle = FlatStyle.Flat;
            btnSetMacroSwitch.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            btnSetMacroSwitch.ForeColor = Color.White;
            btnSetMacroSwitch.HoverBackColor = Color.FromArgb(214, 37, 106);
            btnSetMacroSwitch.Location = new Point(1, 133);
            btnSetMacroSwitch.Margin = new Padding(0, 0, 0, 12);
            btnSetMacroSwitch.Name = "btnSetMacroSwitch";
            btnSetMacroSwitch.Size = new Size(437, 35);
            btnSetMacroSwitch.TabIndex = 4;
            btnSetMacroSwitch.Text = "Set Switch Key";
            btnSetMacroSwitch.UseVisualStyleBackColor = false;
            // 
            // lblMacroSwitchKeyPrefix
            // 
            lblMacroSwitchKeyPrefix.AutoSize = true;
            lblMacroSwitchKeyPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblMacroSwitchKeyPrefix.ForeColor = Color.White;
            lblMacroSwitchKeyPrefix.Location = new Point(0, 106);
            lblMacroSwitchKeyPrefix.Name = "lblMacroSwitchKeyPrefix";
            lblMacroSwitchKeyPrefix.Size = new Size(152, 18);
            lblMacroSwitchKeyPrefix.TabIndex = 6;
            lblMacroSwitchKeyPrefix.Text = "Switch Macro Mode:";
            // 
            // chkAlwaysJitter
            // 
            chkAlwaysJitter.AutoSize = true;
            chkAlwaysJitter.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            chkAlwaysJitter.ForeColor = Color.White;
            chkAlwaysJitter.Location = new Point(24, 459);
            chkAlwaysJitter.Margin = new Padding(3, 2, 3, 2);
            chkAlwaysJitter.Name = "chkAlwaysJitter";
            chkAlwaysJitter.Size = new Size(171, 22);
            chkAlwaysJitter.TabIndex = 3;
            chkAlwaysJitter.Text = "Always Jitter Mode";
            // 
            // chkAlwaysRecoilReduction
            // 
            chkAlwaysRecoilReduction.AutoSize = true;
            chkAlwaysRecoilReduction.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            chkAlwaysRecoilReduction.ForeColor = Color.White;
            chkAlwaysRecoilReduction.Location = new Point(24, 429);
            chkAlwaysRecoilReduction.Margin = new Padding(3, 2, 3, 2);
            chkAlwaysRecoilReduction.Name = "chkAlwaysRecoilReduction";
            chkAlwaysRecoilReduction.Size = new Size(251, 22);
            chkAlwaysRecoilReduction.TabIndex = 2;
            chkAlwaysRecoilReduction.Text = "Always Recoil Reduction Mode";
            // 
            // notifyIcon
            // 
            notifyIcon.ContextMenuStrip = trayContextMenu;
            notifyIcon.Text = "NotesAndTasks";
            notifyIcon.Visible = true;
            // 
            // trayContextMenu
            // 
            trayContextMenu.Items.AddRange(new ToolStripItem[] { showWindowMenuItem, exitMenuItem });
            trayContextMenu.Name = "trayContextMenu";
            trayContextMenu.Size = new Size(151, 48);
            // 
            // showWindowMenuItem
            // 
            showWindowMenuItem.Name = "showWindowMenuItem";
            showWindowMenuItem.Size = new Size(150, 22);
            showWindowMenuItem.Text = "Show Window";
            // 
            // exitMenuItem
            // 
            exitMenuItem.Name = "exitMenuItem";
            exitMenuItem.Size = new Size(150, 22);
            exitMenuItem.Text = "Exit";
            // 
            // MacroForm
            // 
            AutoScaleDimensions = new SizeF(7F, 15F);
            AutoScaleMode = AutoScaleMode.Font;
            BackColor = Color.FromArgb(30, 30, 30);
            ClientSize = new Size(477, 676);
            Controls.Add(mainPanel);
            Margin = new Padding(3, 2, 3, 2);
            MinimumSize = new Size(493, 422);
            Name = "MacroForm";
            Text = "NotesAndTasks";
            mainPanel.ResumeLayout(false);
            mainPanel.PerformLayout();
            debugPanel.ResumeLayout(false);
            debugPanel.PerformLayout();
            strengthPanel1.ResumeLayout(false);
            strengthPanel1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarRecoilReduction).EndInit();
            strengthPanel2.ResumeLayout(false);
            strengthPanel2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarJitter).EndInit();
            settingsPanel.ResumeLayout(false);
            settingsPanel.PerformLayout();
            trayContextMenu.ResumeLayout(false);
            ResumeLayout(false);
        }

        #endregion
        private System.Windows.Forms.Panel mainPanel;
        private ModernButton btnSetKey;
        private System.Windows.Forms.Label lblCurrentKeyPrefix;
        private System.Windows.Forms.Label lblCurrentKeyValue;
        private ModernTrackBar trackBarJitter;
        private System.Windows.Forms.Label lblJitterStrengthPrefix;
        private System.Windows.Forms.Label lblJitterStrengthValue;
        private ModernTrackBar trackBarRecoilReduction;
        private System.Windows.Forms.Label lblRecoilReductionStrengthPrefix;
        private System.Windows.Forms.Label lblRecoilReductionStrengthValue;
        private ModernButton btnToggleDebug;
        private System.Windows.Forms.Panel debugPanel;
        private System.Windows.Forms.TextBox debugLabel;
        private System.Windows.Forms.NotifyIcon notifyIcon;
        private System.Windows.Forms.ContextMenuStrip trayContextMenu;
        private System.Windows.Forms.ToolStripMenuItem showWindowMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exitMenuItem;
        private System.Windows.Forms.Panel settingsPanel;
        private System.Windows.Forms.Panel strengthPanel1;
        private System.Windows.Forms.Panel strengthPanel2;
        private System.Windows.Forms.CheckBox chkMinimizeToTray;
        private ModernButton btnSetMacroSwitch;
        private System.Windows.Forms.Label lblMacroSwitchKeyPrefix;
        private System.Windows.Forms.Label lblMacroSwitchKeyValue;
        private System.Windows.Forms.CheckBox chkAlwaysJitter;
        private System.Windows.Forms.CheckBox chkAlwaysRecoilReduction;
        private System.Windows.Forms.Label lblRecoilReductionActive;
        private System.Windows.Forms.Label lblJitterActive;
    }
}
</file>

<file path="src/MacroForm.cs">
using System;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.ComponentModel;
using NotesAndTasks.Configuration;
using NotesAndTasks;

namespace NotesAndTasks
{
    /// <summary>
    /// Main form for the Notes&Tasks application that provides mouse input management functionality.
    /// This form handles both jitter and recoil reduction features with configurable hotkeys and settings.
    /// </summary>
    /// <remarks>
    /// The form implements two main features:
    /// 1. Jitter - Applies a complex movement pattern to the mouse cursor
    /// 2. Recoil Reduction - Provides vertical compensation with configurable strength
    /// 
    /// Both features are activated when left and right mouse buttons are held simultaneously.
    /// The application can be minimized to the system tray and supports various hotkeys for control.
    /// </remarks>
    public partial class MacroForm : Form
    {
        #region Fields
        private IntPtr keyboardHookID = IntPtr.Zero;
        private IntPtr mouseHookID = IntPtr.Zero;
        private readonly NativeMethods.LowLevelHookProc keyboardProc;
        private readonly NativeMethods.LowLevelHookProc mouseProc;
        private System.Threading.Timer jitterTimer;
        private readonly ToolTip toolTip;

        private bool isMacroOn = false;
        /// <summary>
        /// Defines the types of input that can be used to toggle the macro functionality.
        /// </summary>
        private enum ToggleType
        {
            /// <summary>Keyboard key input</summary>
            Keyboard,
            /// <summary>Middle mouse button input</summary>
            MouseMiddle,
            /// <summary>Mouse button 4 (XButton1) input</summary>
            MouseX1,
            /// <summary>Mouse button 5 (XButton2) input</summary>
            MouseX2
        }

        // Surpress warnings as first time build might not know about these
#pragma warning disable CS0414
        private ToggleType currentToggleType = ToggleType.Keyboard;
        private Keys toggleKey = Keys.Capital;  // Default to Capital
        private Keys macroSwitchKey = Keys.Q;  // Default to Q
#pragma warning restore CS0414

        private int jitterStrength = 3;  // Default to 3
        private int recoilReductionStrength = 1;  // Default to 1
        private bool isSettingKey = false;
        private bool isSettingMacroSwitchKey = false;
        private bool isJittering = false;
        private int currentStep = 0;
        private readonly object lockObject = new object();
        private bool leftButtonDown = false;
        private bool rightButtonDown = false;
        private bool isExiting = false;
        private bool jitterEnabled = false;
        private bool alwaysJitterMode = false;
        private bool alwaysRecoilReductionMode = false;
        private bool recoilReductionEnabled = false;
        private Keys currentMacroKey = Keys.Capital;  // Default to Caps Lock
        private Keys currentSwitchKey = Keys.Q;      // Default to Q

        private readonly (int dx, int dy)[] jitterPattern = new[]
        {
            (7, 7), (-7, -7), (0, 7), (7, 7), (-7, -7),
            (0, 6), (7, 7), (-7, -7), (0, 7), (7, 7),
            (-7, -7), (0, 6), (7, 7), (-7, -7), (0, 6),
            (7, 7), (-7, -7), (0, 7), (7, 7), (-7, -7),
            (0, 6), (7, 7), (-7, -7), (0, 6)
        };

        private const double BASE_RECOIL_STRENGTH = 0.75;
        private const double BASE_RECOIL_STRENGTH_2 = 2.0;
        private const double LOW_LEVEL_1_SPEED = 0.25;
        private const double LOW_LEVEL_2_SPEED = 0.5;
        private const double LOW_LEVEL_3_SPEED = 0.75;

        #endregion

        /// <summary>
        /// Initializes a new instance of the MacroForm class.
        /// Sets up all necessary components, hooks, and event handlers.
        /// </summary>
        public MacroForm()
        {
            toolTip = new ToolTip();
            keyboardProc = KeyboardHookCallback;
            mouseProc = MouseHookCallback;

            try
            {
                InitializeComponent();
                InitializeCustomComponents();

                // Initialize tray icon behavior
                notifyIcon.DoubleClick += (s, e) => ShowWindow();
                showWindowMenuItem.Click += (s, e) => ShowWindow();
                exitMenuItem.Click += (s, e) => CleanupAndExit();

                this.FormClosing += OnFormClosingHandler;
                this.Resize += OnResizeHandler;
                this.Load += OnLoadHandler;

                // Handle application exit
                Application.ApplicationExit += (s, e) =>
                {
                    if (!isExiting)
                    {
                        CleanupAndExit();
                    }
                };
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing form: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        /// <summary>
        /// Handles the form closing event. If minimize to tray is enabled,
        /// the form will be hidden instead of closed when the user clicks the close button.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Event data containing the close reason and cancellation option.</param>
        private void OnFormClosingHandler(object sender, FormClosingEventArgs e)
        {
            if (!isExiting && chkMinimizeToTray.Checked && e.CloseReason == CloseReason.UserClosing)
            {
                e.Cancel = true;
                this.Hide();
                notifyIcon.Visible = true;
                UpdateDebugInfo("Application minimized to system tray");
            }
            else if (isExiting || !chkMinimizeToTray.Checked)
            {
                // Cleanup when actually closing
                CleanupAndExit();
            }
        }

        /// <summary>
        /// Handles form resize events by ensuring proper layout of controls.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Event data.</param>
        private void OnResizeHandler(object sender, EventArgs e)
        {
            // Let the anchor properties handle control resizing
            mainPanel.PerformLayout();
            this.PerformLayout();
        }

        /// <summary>
        /// Handles the form load event by initializing hooks and timers.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Event data.</param>
        private void OnLoadHandler(object sender, EventArgs e)
        {
            try
            {
                InitializeHooks();
                jitterTimer = new System.Threading.Timer(OnJitterTimer, null, Timeout.Infinite, 10);
                UpdateTitle();
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error initializing hooks: {ex.Message}");
            }
        }

        /// <summary>
        /// Initializes custom components including icons, hotkeys, tooltips, and loads saved settings.
        /// </summary>
        private void InitializeCustomComponents()
        {
            InitializeIcon();
            InitializeHotkeys();
            InitializeTooltips();
            LoadSettings();

            // Set initial text with bold formatting
            if (currentMacroKey != Keys.None)
                UpdateCurrentKey(currentMacroKey.ToString());
            if (currentSwitchKey != Keys.None)
                UpdateSwitchKey(currentSwitchKey.ToString());

            // Initialize event handlers
            InitializeEventHandlers();
        }

        /// <summary>
        /// Initializes all event handlers for form controls.
        /// Sets up click events, value change events, and checkbox state change events.
        /// </summary>
        private void InitializeEventHandlers()
        {
            btnToggleDebug.Click += (sender, e) =>
            {
                debugPanel.Visible = !debugPanel.Visible;
                btnToggleDebug.Text = debugPanel.Visible ? "Hide Debug Info" : "Show Debug Info";
                UpdateDebugInfo("Debug panel visibility toggled");
            };

            btnSetKey.Click += (sender, e) =>
            {
                isSettingKey = true;
                btnSetKey.Text = "Press any key...";
                btnSetKey.Enabled = false;
                UpdateDebugInfo("Waiting for new toggle key...");
            };

            trackBarJitter.ValueChanged += (sender, e) =>
            {
                try
                {
                    Validation.ValidateStrength(trackBarJitter.Value, trackBarJitter.Minimum, trackBarJitter.Maximum, nameof(trackBarJitter.Value));
                    jitterStrength = trackBarJitter.Value;
                    SettingsManager.CurrentSettings.JitterStrength = jitterStrength;
                    SettingsManager.SaveSettings();
                    UpdateJitterStrength(jitterStrength);
                    UpdateDebugInfo($"Jitter strength set to {jitterStrength}");
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    UpdateDebugInfo($"Error setting jitter strength: {ex.Message}");
                    trackBarJitter.Value = Math.Max(trackBarJitter.Minimum, Math.Min(trackBarJitter.Maximum, jitterStrength));
                }
            };

            trackBarRecoilReduction.ValueChanged += (sender, e) =>
            {
                try
                {
                    Validation.ValidateStrength(trackBarRecoilReduction.Value, trackBarRecoilReduction.Minimum, trackBarRecoilReduction.Maximum, nameof(trackBarRecoilReduction.Value));
                    recoilReductionStrength = trackBarRecoilReduction.Value;
                    SettingsManager.CurrentSettings.RecoilReductionStrength = recoilReductionStrength;
                    SettingsManager.SaveSettings();
                    UpdateRecoilReductionStrength(recoilReductionStrength);
                    UpdateDebugInfo($"Recoil reduction strength set to {recoilReductionStrength}");
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    UpdateDebugInfo($"Error setting recoil reduction strength: {ex.Message}");
                    trackBarRecoilReduction.Value = Math.Max(trackBarRecoilReduction.Minimum, Math.Min(trackBarRecoilReduction.Maximum, recoilReductionStrength));
                }
            };

            chkAlwaysJitter.CheckedChanged += (sender, e) =>
            {
                alwaysJitterMode = chkAlwaysJitter.Checked;
                if (alwaysJitterMode)
                {
                    jitterEnabled = true;
                    recoilReductionEnabled = false;
                    chkAlwaysRecoilReduction.Checked = false;
                    btnSetMacroSwitch.Enabled = false;
                }
                else
                {
                    btnSetMacroSwitch.Enabled = true;
                }
                SettingsManager.CurrentSettings.AlwaysJitterMode = alwaysJitterMode;
                SettingsManager.CurrentSettings.JitterEnabled = jitterEnabled;
                SettingsManager.CurrentSettings.RecoilReductionEnabled = recoilReductionEnabled;
                SettingsManager.SaveSettings();
                UpdateTitle();
                UpdateModeLabels();
            };

            chkAlwaysRecoilReduction.CheckedChanged += (sender, e) =>
            {
                alwaysRecoilReductionMode = chkAlwaysRecoilReduction.Checked;
                if (alwaysRecoilReductionMode)
                {
                    recoilReductionEnabled = true;
                    jitterEnabled = false;
                    chkAlwaysJitter.Checked = false;
                    btnSetMacroSwitch.Enabled = false;
                }
                else
                {
                    btnSetMacroSwitch.Enabled = true;
                }
                SettingsManager.CurrentSettings.AlwaysRecoilReductionMode = alwaysRecoilReductionMode;
                SettingsManager.CurrentSettings.RecoilReductionEnabled = recoilReductionEnabled;
                SettingsManager.CurrentSettings.JitterEnabled = jitterEnabled;
                SettingsManager.SaveSettings();
                UpdateTitle();
                UpdateModeLabels();
            };

            chkMinimizeToTray.CheckedChanged += (sender, e) =>
            {
                SettingsManager.CurrentSettings.MinimizeToTray = chkMinimizeToTray.Checked;
                SettingsManager.SaveSettings();
            };

            btnSetMacroSwitch.Click += (sender, e) =>
            {
                isSettingMacroSwitchKey = true;
                btnSetMacroSwitch.Text = "Press any key...";
                btnSetMacroSwitch.Enabled = false;
                UpdateDebugInfo("Waiting for new switch key...");
            };
        }

        /// <summary>
        /// Loads saved settings from the settings manager and applies them to the form.
        /// Validates all settings before applying them and falls back to defaults if validation fails.
        /// </summary>
        private void LoadSettings()
        {
            try
            {
                var settings = SettingsManager.CurrentSettings;
                Validation.ValidateNotNull(settings, nameof(settings));

                // Validate all settings before applying them
                if (!SettingsValidation.ValidateSettings(settings, 
                    Math.Min(trackBarJitter.Minimum, trackBarRecoilReduction.Minimum),
                    Math.Max(trackBarJitter.Maximum, trackBarRecoilReduction.Maximum)))
                {
                    UpdateDebugInfo("Invalid settings detected, resetting to defaults");
                    ResetToDefaultSettings();
                    return;
                }

                // Apply validated settings
                trackBarJitter.Value = settings.JitterStrength;
                jitterStrength = settings.JitterStrength;
                jitterEnabled = settings.JitterEnabled;
                alwaysJitterMode = settings.AlwaysJitterMode;
                chkAlwaysJitter.Checked = settings.AlwaysJitterMode;

                trackBarRecoilReduction.Value = settings.RecoilReductionStrength;
                recoilReductionStrength = settings.RecoilReductionStrength;
                recoilReductionEnabled = settings.RecoilReductionEnabled;
                alwaysRecoilReductionMode = settings.AlwaysRecoilReductionMode;
                chkAlwaysRecoilReduction.Checked = settings.AlwaysRecoilReductionMode;

                chkMinimizeToTray.Checked = settings.MinimizeToTray;

                // Load and validate hotkeys
                if (!string.IsNullOrEmpty(settings.MacroToggleKey))
                {
                    currentMacroKey = (Keys)Enum.Parse(typeof(Keys), settings.MacroToggleKey);
                    if (!SettingsValidation.IsValidHotkey(currentMacroKey))
                    {
                        UpdateDebugInfo("Invalid macro toggle key detected, resetting to default");
                        currentMacroKey = Keys.Capital;
                    }
                }

                if (!string.IsNullOrEmpty(settings.ModeSwitchKey))
                {
                    currentSwitchKey = (Keys)Enum.Parse(typeof(Keys), settings.ModeSwitchKey);
                    if (!SettingsValidation.IsValidHotkey(currentSwitchKey))
                    {
                        UpdateDebugInfo("Invalid mode switch key detected, resetting to default");
                        currentSwitchKey = Keys.Q;
                    }
                }

                // Update UI
                UpdateJitterStrength(jitterStrength);
                UpdateRecoilReductionStrength(recoilReductionStrength);
                UpdateTitle();
                UpdateModeLabels();
                UpdateDebugInfo("Settings loaded successfully");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error loading settings: {ex.Message}");
                ResetToDefaultSettings();
            }
        }

        /// <summary>
        /// Saves current settings to persistent storage through the settings manager.
        /// Validates settings before saving to ensure data integrity.
        /// </summary>
        private void SaveCurrentSettings()
        {
            try
            {
                var settings = SettingsManager.CurrentSettings;

                // Update settings object with current values
                settings.JitterStrength = jitterStrength;
                settings.JitterEnabled = jitterEnabled;
                settings.AlwaysJitterMode = alwaysJitterMode;
                settings.RecoilReductionStrength = recoilReductionStrength;
                settings.RecoilReductionEnabled = recoilReductionEnabled;
                settings.AlwaysRecoilReductionMode = alwaysRecoilReductionMode;
                settings.MinimizeToTray = chkMinimizeToTray.Checked;
                settings.MacroToggleKey = currentMacroKey.ToString();
                settings.ModeSwitchKey = currentSwitchKey.ToString();

                // Validate settings before saving
                if (!SettingsValidation.ValidateSettings(settings,
                    Math.Min(trackBarJitter.Minimum, trackBarRecoilReduction.Minimum),
                    Math.Max(trackBarJitter.Maximum, trackBarRecoilReduction.Maximum)))
                {
                    UpdateDebugInfo("Invalid settings detected, aborting save");
                    throw new InvalidOperationException("Settings validation failed");
                }

                // Save validated settings
                SettingsManager.SaveSettings();
                UpdateDebugInfo("Settings saved successfully");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error saving settings: {ex.Message}");
                // Consider showing a message box to the user here
                MessageBox.Show(
                    "Failed to save settings. Your changes may not persist after closing the application.",
                    "Settings Save Error",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Warning
                );
            }
        }

        /// <summary>
        /// Resets all settings to their default values.
        /// Called when settings loading fails or when invalid settings are detected.
        /// </summary>
        private void ResetToDefaultSettings()
        {
            try
            {
                // Reset strength values
                trackBarJitter.Value = 3;
                jitterStrength = 3;
                trackBarRecoilReduction.Value = 1;
                recoilReductionStrength = 1;

                // Reset mode states
                chkAlwaysJitter.Checked = false;
                alwaysJitterMode = false;
                jitterEnabled = false;
                chkAlwaysRecoilReduction.Checked = false;
                alwaysRecoilReductionMode = false;
                recoilReductionEnabled = true;

                // Reset UI preferences
                chkMinimizeToTray.Checked = false;

                // Reset hotkeys
                currentMacroKey = Keys.Capital;
                currentSwitchKey = Keys.Q;

                // Update UI
                UpdateCurrentKey(currentMacroKey.ToString());
                UpdateSwitchKey(currentSwitchKey.ToString());
                UpdateTitle();
                UpdateModeLabels();
                UpdateDebugInfo("Settings reset to defaults");

                // Save default settings
                SaveCurrentSettings();
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error resetting settings to defaults: {ex.Message}");
            }
        }

        /// <summary>
        /// Initializes low-level keyboard and mouse hooks for input monitoring.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown when hook initialization fails.</exception>
        private void InitializeHooks()
        {
            try
            {
                using var curProcess = Process.GetCurrentProcess();
                using var curModule = curProcess.MainModule;

                Validation.ValidateNotNull(curModule, nameof(curModule));
                string moduleName = curModule.ModuleName;
                Validation.ValidateStringNotNullOrEmpty(moduleName, nameof(moduleName));

                IntPtr moduleHandle = NativeMethods.GetModuleHandle(moduleName);
                Validation.ValidateHandle(moduleHandle, nameof(moduleHandle));

                keyboardHookID = NativeMethods.SetWindowsHookEx(WinMessages.WH_KEYBOARD_LL, keyboardProc,
                    moduleHandle, 0);
                Validation.ValidateHandle(keyboardHookID, "keyboardHookID");

                mouseHookID = NativeMethods.SetWindowsHookEx(WinMessages.WH_MOUSE_LL, mouseProc,
                    moduleHandle, 0);
                Validation.ValidateHandle(mouseHookID, "mouseHookID");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error in InitializeHooks: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Callback function for the low-level mouse hook.
        /// Handles mouse button events and manages macro activation states.
        /// </summary>
        /// <param name="nCode">Hook code; if less than zero, the hook procedure must pass the message to CallNextHookEx.</param>
        /// <param name="wParam">Message identifier.</param>
        /// <param name="lParam">Pointer to a MSLLHOOKSTRUCT structure.</param>
        /// <returns>If nCode is less than zero, the hook procedure must return the value returned by CallNextHookEx.</returns>
        private IntPtr MouseHookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (Validation.ValidateHookCode(nCode))
            {
                try
                {
                    if (lParam == IntPtr.Zero)
                    {
                        UpdateDebugInfo("Error: Invalid mouse hook parameter");
                        return NativeMethods.CallNextHookEx(mouseHookID, nCode, wParam, lParam);
                    }

                    var hookStruct = Marshal.PtrToStructure<NativeMethods.MSLLHOOKSTRUCT>(lParam);

                    switch ((int)wParam)
                    {
                        case WinMessages.WM_LBUTTONDOWN:
                            leftButtonDown = true;
                            break;

                        case WinMessages.WM_LBUTTONUP:
                            leftButtonDown = false;
                            break;

                        case WinMessages.WM_RBUTTONDOWN:
                            rightButtonDown = true;
                            break;

                        case WinMessages.WM_RBUTTONUP:
                            rightButtonDown = false;
                            break;
                    }

                    if (wParam == (IntPtr)WinMessages.WM_XBUTTONDOWN)
                    {
                        bool isXButton1 = (hookStruct.mouseData >> 16) == WinMessages.XBUTTON1;
                        bool isXButton2 = (hookStruct.mouseData >> 16) == WinMessages.XBUTTON2;

                        if (isSettingKey)
                        {
                            isSettingKey = false;
                            btnSetKey.Enabled = true;
                            btnSetKey.Text = "Set Toggle Key";
                            string buttonName = isXButton1 ? "XButton1" : "XButton2";
                            currentMacroKey = isXButton1 ? Keys.XButton1 : Keys.XButton2;
                            currentToggleType = isXButton1 ? ToggleType.MouseX1 : ToggleType.MouseX2;
                            UpdateCurrentKey(buttonName);
                            SaveCurrentSettings();
                            UpdateDebugInfo($"Set toggle key to {buttonName}");
                        }
                        else if (isSettingMacroSwitchKey)
                        {
                            isSettingMacroSwitchKey = false;
                            btnSetMacroSwitch.Enabled = true;
                            btnSetMacroSwitch.Text = "Set Switch Key";
                            string buttonName = isXButton1 ? "XButton1" : "XButton2";
                            currentSwitchKey = isXButton1 ? Keys.XButton1 : Keys.XButton2;
                            UpdateMacroSwitchKey(buttonName);
                            SaveCurrentSettings();
                            UpdateDebugInfo($"Set macro switch key to {buttonName}");
                        }
                        else if ((isXButton1 && currentMacroKey == Keys.XButton1) ||
                                (isXButton2 && currentMacroKey == Keys.XButton2))
                        {
                            ToggleMacro();
                        }
                        else if ((isXButton1 && currentSwitchKey == Keys.XButton1) ||
                                (isXButton2 && currentSwitchKey == Keys.XButton2))
                        {
                            HandleModeSwitch();
                        }
                    }
                    else if (wParam == (IntPtr)WinMessages.WM_MBUTTONDOWN)
                    {
                        if (isSettingKey)
                        {
                            isSettingKey = false;
                            btnSetKey.Enabled = true;
                            btnSetKey.Text = "Set Toggle Key";
                            currentMacroKey = Keys.MButton;
                            currentToggleType = ToggleType.MouseMiddle;
                            UpdateCurrentKey("MButton");
                            SaveCurrentSettings();
                            UpdateDebugInfo("Set toggle key to MButton");
                        }
                        else if (isSettingMacroSwitchKey)
                        {
                            isSettingMacroSwitchKey = false;
                            btnSetMacroSwitch.Enabled = true;
                            btnSetMacroSwitch.Text = "Set Switch Key";
                            currentSwitchKey = Keys.MButton;
                            UpdateMacroSwitchKey("MButton");
                            SaveCurrentSettings();
                            UpdateDebugInfo("Set macro switch key to MButton");
                        }
                        else if (currentMacroKey == Keys.MButton)
                        {
                            ToggleMacro();
                        }
                        else if (currentSwitchKey == Keys.MButton)
                        {
                            HandleModeSwitch();
                        }
                    }

                    CheckJitterState();
                }
                catch (Exception ex)
                {
                    UpdateDebugInfo($"Error in MouseHookCallback: {ex.Message}");
                }
            }
            return NativeMethods.CallNextHookEx(mouseHookID, nCode, wParam, lParam);
        }

        /// <summary>
        /// Callback function for the low-level keyboard hook.
        /// Handles keyboard events for macro toggling and mode switching.
        /// </summary>
        /// <param name="nCode">Hook code; if less than zero, the hook procedure must pass the message to CallNextHookEx.</param>
        /// <param name="wParam">Message identifier.</param>
        /// <param name="lParam">Pointer to a KBDLLHOOKSTRUCT structure.</param>
        /// <returns>If nCode is less than zero, the hook procedure must return the value returned by CallNextHookEx.</returns>
        private IntPtr KeyboardHookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (Validation.ValidateHookCode(nCode))
            {
                try
                {
                    if (wParam == (IntPtr)WinMessages.WM_KEYDOWN)
                    {
                        var vkCode = Marshal.ReadInt32(lParam);

                        if (isSettingKey)
                        {
                            isSettingKey = false;
                            btnSetKey.Enabled = true;
                            btnSetKey.Text = "Set Toggle Key";
                            currentMacroKey = (Keys)vkCode;
                            currentToggleType = ToggleType.Keyboard;
                            UpdateCurrentKey(currentMacroKey.ToString());
                            SaveCurrentSettings();
                            UpdateDebugInfo($"Set toggle key to {currentMacroKey}");
                        }
                        else if (isSettingMacroSwitchKey)
                        {
                            isSettingMacroSwitchKey = false;
                            btnSetMacroSwitch.Enabled = true;
                            btnSetMacroSwitch.Text = "Set Switch Key";
                            currentSwitchKey = (Keys)vkCode;
                            UpdateMacroSwitchKey(currentSwitchKey.ToString());
                            SaveCurrentSettings();
                            UpdateDebugInfo($"Set macro switch key to {currentSwitchKey}");
                        }
                        else if ((Keys)vkCode == currentMacroKey && currentToggleType == ToggleType.Keyboard)
                        {
                            ToggleMacro();
                        }
                        else if ((Keys)vkCode == currentSwitchKey)
                        {
                            HandleModeSwitch();
                        }
                    }
                }
                catch (Exception ex)
                {
                    UpdateDebugInfo($"Error in KeyboardHookCallback: {ex.Message}");
                }
            }
            return NativeMethods.CallNextHookEx(keyboardHookID, nCode, wParam, lParam);
        }

        /// <summary>
        /// Checks and updates the jitter/recoil reduction state based on mouse button states.
        /// Activates or deactivates the jitter timer based on current conditions.
        /// </summary>
        private void CheckJitterState()
        {
            // Always require both mouse buttons
            bool shouldActivate = isMacroOn && leftButtonDown && rightButtonDown;

            if (shouldActivate && !isJittering)
            {
                isJittering = true;
                jitterTimer.Change(0, 10);

                // Use alwaysJitterMode/alwaysRecoilReductionMode to determine which macro to run
                bool useJitter = alwaysJitterMode || (!alwaysRecoilReductionMode && jitterEnabled);

                if (useJitter)
                {
                    UpdateDebugInfo($"Jitter started - Mouse Buttons: LMB={leftButtonDown}, RMB={rightButtonDown}, Always Jitter={alwaysJitterMode}");
                }
                else
                {
                    UpdateDebugInfo($"Recoil reduction started - Mouse Buttons: LMB={leftButtonDown}, RMB={rightButtonDown}, Always Recoil Reduction={alwaysRecoilReductionMode}");
                }
            }
            else if (!shouldActivate && isJittering)
            {
                isJittering = false;
                jitterTimer.Change(Timeout.Infinite, 10);

                bool useJitter = alwaysJitterMode || (!alwaysRecoilReductionMode && jitterEnabled);

                if (useJitter)
                {
                    UpdateDebugInfo($"Jitter stopped - Mouse Buttons: LMB={leftButtonDown}, RMB={rightButtonDown}, Always Jitter={alwaysJitterMode}");
                }
                else
                {
                    UpdateDebugInfo($"Recoil reduction stopped - Mouse Buttons: LMB={leftButtonDown}, RMB={rightButtonDown}, Always Recoil Reduction={alwaysRecoilReductionMode}");
                }
            }
            UpdateModeLabels();
        }

        /// <summary>
        /// Timer callback that handles mouse movement for both jitter and recoil reduction modes.
        /// Includes comprehensive validation of movement parameters and state.
        /// </summary>
        /// <param name="state">State object (not used).</param>
        private void OnJitterTimer(object state)
        {
            if (!isJittering) return;

            try
            {
                lock (lockObject)
                {
                    // Validate current state
                    if (!isMacroOn)
                    {
                        jitterTimer.Change(Timeout.Infinite, 10);
                        isJittering = false;
                        UpdateDebugInfo("Timer stopped: Macro is off");
                        return;
                    }

                    // Validate mouse button state
                    if (!(leftButtonDown && rightButtonDown))
                    {
                        jitterTimer.Change(Timeout.Infinite, 10);
                        isJittering = false;
                        UpdateDebugInfo("Timer stopped: Mouse buttons released");
                        return;
                    }

                    var input = new NativeMethods.INPUT
                    {
                        type = WinMessages.INPUT_MOUSE,
                        mi = new NativeMethods.MOUSEINPUT
                        {
                            mouseData = 0,
                            time = 0,
                            dwExtraInfo = IntPtr.Zero
                        }
                    };

                    bool useJitter = alwaysJitterMode || (!alwaysRecoilReductionMode && jitterEnabled);

                    if (useJitter)
                    {
                        // Validate jitter pattern index
                        if (currentStep < 0 || currentStep >= jitterPattern.Length)
                        {
                            currentStep = 0;
                            UpdateDebugInfo("Reset jitter pattern index due to invalid value");
                        }

                        var pattern = jitterPattern[currentStep];
                        
                        // Validate and apply jitter strength
                        try
                        {
                            Validation.ValidateStrength(jitterStrength, 1, 20, nameof(jitterStrength));
                            input.mi.dx = (int)(pattern.dx * jitterStrength / 7);
                            input.mi.dy = (int)(pattern.dy * jitterStrength / 7);
                        }
                        catch (ArgumentOutOfRangeException)
                        {
                            // Use default strength if current value is invalid
                            jitterStrength = 3;
                            input.mi.dx = (int)(pattern.dx * jitterStrength / 7);
                            input.mi.dy = (int)(pattern.dy * jitterStrength / 7);
                            UpdateDebugInfo("Reset to default jitter strength due to invalid value");
                        }

                        currentStep = (currentStep + 1) % jitterPattern.Length;
                    }
                    else
                    {
                        // Validate recoil reduction strength
                        try
                        {
                            Validation.ValidateStrength(recoilReductionStrength, 1, 20, nameof(recoilReductionStrength));
                            
                            input.mi.dx = 0;
                            if (recoilReductionStrength <= 6)
                            {
                                if (recoilReductionStrength == 1)
                                {
                                    input.mi.dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * 0.3));
                                }
                                else
                                {
                                    double logBase = 1.5;
                                    input.mi.dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * Math.Log(recoilReductionStrength + 1, logBase)));
                                }
                            }
                            else if (recoilReductionStrength <= 16)
                            {
                                input.mi.dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * recoilReductionStrength * 1.2));
                            }
                            else
                            {
                                double baseValue = BASE_RECOIL_STRENGTH * 20.0;
                                double scalingFactor = 1.3;
                                double exponentialBoost = 1.2;
                                input.mi.dy = Math.Max(1, (int)Math.Round(
                                    baseValue *
                                    Math.Pow(scalingFactor, recoilReductionStrength - 13) *
                                    Math.Pow(exponentialBoost, (recoilReductionStrength - 13) / 2)
                                ));
                            }
                        }
                        catch (ArgumentOutOfRangeException)
                        {
                            // Use default strength if current value is invalid
                            recoilReductionStrength = 1;
                            input.mi.dx = 0;
                            input.mi.dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * 0.3));
                            UpdateDebugInfo("Reset to default recoil reduction strength due to invalid value");
                        }
                    }

                    // Validate final movement values
                    if (Math.Abs(input.mi.dx) > 100 || Math.Abs(input.mi.dy) > 100)
                    {
                        UpdateDebugInfo("Movement values exceeded safe limits, skipping movement");
                        return;
                    }

                    input.mi.dwFlags = WinMessages.MOUSEEVENTF_MOVE;
                    NativeMethods.SendInput(1, ref input, Marshal.SizeOf(input));
                }
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Movement error: {ex.Message}");
                // Stop the timer on critical errors
                try
                {
                    jitterTimer.Change(Timeout.Infinite, 10);
                    isJittering = false;
                }
                catch { /* Ignore cleanup errors */ }
            }
        }

        /// <summary>
        /// Updates the form title to reflect current macro state and mode.
        /// </summary>
        private void UpdateTitle()
        {
            string jitterMode;
            string recoilMode;
            if (alwaysJitterMode)
                jitterMode = "Always Jitter";
            else
                jitterMode = jitterEnabled ? "Jitter" : "Jitter (OFF)";

            if (alwaysRecoilReductionMode)
                recoilMode = "Always Recoil Reduction";
            else
                recoilMode = jitterEnabled ? "Recoil Reduction (OFF)" : "Recoil Reduction";

            this.Text = $"Notes&Tasks [{(isMacroOn ? "ON" : "OFF")}] - {jitterMode} / {recoilMode} Mode";
            UpdateModeLabels();
        }

        /// <summary>
        /// Updates the displayed current key binding for macro toggle.
        /// </summary>
        /// <param name="key">The key name to display.</param>
        private void UpdateCurrentKey(string key)
        {
            if (lblCurrentKeyValue != null)
            {
                lblCurrentKeyValue.Text = key;
            }
        }

        /// <summary>
        /// Updates the displayed key binding for mode switching.
        /// </summary>
        /// <param name="key">The key name to display.</param>
        private void UpdateSwitchKey(string key)
        {
            if (lblMacroSwitchKeyValue != null)
            {
                lblMacroSwitchKeyValue.Text = key;
            }
        }

        /// <summary>
        /// Updates the displayed jitter strength value.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="strength">The strength value to display (1-20).</param>
        private void UpdateJitterStrength(int strength)
        {
            try
            {
                Validation.ValidateStrength(strength, trackBarJitter.Minimum, trackBarJitter.Maximum, nameof(strength));

                if (InvokeRequired)
                {
                    Invoke(new Action<int>(UpdateJitterStrength), strength);
                    return;
                }

                lblJitterStrengthValue.Text = strength.ToString();
                UpdateDebugInfo($"Jitter strength updated to: {strength}");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error updating jitter strength: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates the displayed recoil reduction strength value.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="strength">The strength value to display (1-20).</param>
        private void UpdateRecoilReductionStrength(int strength)
        {
            try
            {
                Validation.ValidateStrength(strength, trackBarRecoilReduction.Minimum, trackBarRecoilReduction.Maximum, nameof(strength));

                if (InvokeRequired)
                {
                    Invoke(new Action<int>(UpdateRecoilReductionStrength), strength);
                    return;
                }

                lblRecoilReductionStrengthValue.Text = strength.ToString();
                UpdateDebugInfo($"Recoil reduction strength updated to: {strength}");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error updating recoil reduction strength: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates the displayed macro switch key value.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="key">The key name to display.</param>
        private void UpdateMacroSwitchKey(string key)
        {
            if (InvokeRequired)
            {
                Invoke(new Action<string>(UpdateMacroSwitchKey), key);
                return;
            }
            lblMacroSwitchKeyValue.Text = key;
            UpdateDebugInfo($"Macro switch key updated to: {key}");
        }

        /// <summary>
        /// Adds a debug message to the debug panel with timestamp.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="message">The debug message to display.</param>
        private void UpdateDebugInfo(string message)
        {
            if (debugLabel.InvokeRequired)
            {
                debugLabel.Invoke(new Action(() => UpdateDebugInfo(message)));
                return;
            }

            string timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
            string newLine = $"[{timestamp}] {message}";

            // Keep last 100 lines of debug info
            var lines = debugLabel.Lines.ToList();
            lines.Add(newLine);
            if (lines.Count > 100)
            {
                lines.RemoveAt(0);
            }
            debugLabel.Lines = lines.ToArray();

            // Auto-scroll to bottom
            debugLabel.SelectionStart = debugLabel.TextLength;
            debugLabel.ScrollToCaret();
        }

        /// <summary>
        /// Shows and activates the main window when restored from system tray.
        /// </summary>
        private void ShowWindow()
        {
            this.Show();
            this.WindowState = FormWindowState.Normal;
            this.Activate();
            notifyIcon.Visible = false;
            UpdateDebugInfo("Application restored from system tray");
        }

        /// <summary>
        /// Performs cleanup and exits the application.
        /// Ensures all resources are properly disposed and hooks are unregistered.
        /// </summary>
        private void CleanupAndExit()
        {
            if (isExiting) return;
            isExiting = true;

            try
            {
                // Use Dispose pattern for cleanup
                this.Dispose();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error during cleanup: {ex.Message}");
            }

            // Force process to exit
            try
            {
                using (var process = Process.GetCurrentProcess())
                {
                    process.Kill();
                }
            }
            catch
            {
                Environment.Exit(0);
            }
        }

        /// <summary>
        /// Toggles the macro on/off state and updates the UI accordingly.
        /// </summary>
        private void ToggleMacro()
        {
            isMacroOn = !isMacroOn;
            UpdateTitle();
            string mode = jitterEnabled ? "Jitter" : "Recoil Reduction";
            string alwaysMode = alwaysJitterMode ? "Always Jitter" : (alwaysRecoilReductionMode ? "Always Recoil Reduction" : "Normal");
            UpdateDebugInfo($"Macro {(isMacroOn ? "Enabled" : "Disabled")} - Mode: {mode}, Always Mode: {alwaysMode}, Key: **{toggleKey}**");
            UpdateModeLabels();
        }

        /// <summary>
        /// Handles switching between jitter and recoil reduction modes.
        /// Only works when neither "Always" mode is enabled.
        /// Validates mode state before switching.
        /// </summary>
        private void HandleModeSwitch()
        {
            try
            {
                // Validate current state
                if (isSettingKey || isSettingMacroSwitchKey)
                {
                    UpdateDebugInfo("Cannot switch modes while setting keys");
                    return;
                }

                // Don't switch if either "Always" mode is enabled
                if (alwaysJitterMode || alwaysRecoilReductionMode)
                {
                    UpdateDebugInfo("Cannot switch modes when 'Always' mode is enabled");
                    return;
                }

                // Toggle between jitter and recoil reduction with validation
                bool previousJitterState = jitterEnabled;
                bool previousRecoilState = recoilReductionEnabled;

                jitterEnabled = !jitterEnabled;
                recoilReductionEnabled = !jitterEnabled;

                // Validate the new state
                if (jitterEnabled == recoilReductionEnabled)
                {
                    // Invalid state detected, revert changes
                    jitterEnabled = previousJitterState;
                    recoilReductionEnabled = previousRecoilState;
                    UpdateDebugInfo("Error: Invalid mode state detected");
                    return;
                }

                // Save the new state
                try
                {
                    SettingsManager.CurrentSettings.JitterEnabled = jitterEnabled;
                    SettingsManager.CurrentSettings.RecoilReductionEnabled = recoilReductionEnabled;
                    SettingsManager.SaveSettings();
                }
                catch (Exception ex)
                {
                    // Revert changes if settings save fails
                    jitterEnabled = previousJitterState;
                    recoilReductionEnabled = previousRecoilState;
                    UpdateDebugInfo($"Error saving mode settings: {ex.Message}");
                    return;
                }

                UpdateTitle();
                UpdateModeLabels();
                UpdateDebugInfo($"Switched to {(jitterEnabled ? "Jitter" : "Recoil Reduction")} mode");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error in HandleModeSwitch: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates the active mode labels in the UI.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        private void UpdateModeLabels()
        {
            if (InvokeRequired)
            {
                Invoke(new Action(UpdateModeLabels));
                return;
            }

            lblRecoilReductionActive.Text = (!jitterEnabled && isMacroOn) ? "[Active]" : "";
            lblJitterActive.Text = (jitterEnabled && isMacroOn) ? "[Active]" : "";
        }

        private void lblJitterActive_Click(object sender, EventArgs e)
        {

        }

        private void lblCurrentKeyPrefix_Click(object sender, EventArgs e)
        {

        }

        private void strengthPanel2_Paint(object sender, PaintEventArgs e)
        {
            // This is an empty Paint event handler for strengthPanel2
        }

        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            SaveCurrentSettings();
            base.OnFormClosing(e);
        }

        /// <summary>
        /// Initializes the application icon for both the main window and system tray.
        /// </summary>
        private void InitializeIcon()
        {
            try
            {
                using var icon = Icon.ExtractAssociatedIcon(Application.ExecutablePath);
                if (icon != null)
                {
                    this.Icon = (Icon)icon.Clone();
                    notifyIcon.Icon = (Icon)icon.Clone();
                }
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error loading icon: {ex.Message}");
            }
        }

        /// <summary>
        /// Initializes default hotkey bindings and updates the UI to reflect them.
        /// </summary>
        private void InitializeHotkeys()
        {
            // Initialize default hotkeys
            UpdateCurrentKey(currentMacroKey.ToString());
            UpdateSwitchKey(currentSwitchKey.ToString());
        }

        /// <summary>
        /// Initializes tooltips for various UI controls to provide user guidance.
        /// </summary>
        private void InitializeTooltips()
        {
            // Initialize tooltips for controls using the managed ToolTip instance
            toolTip.SetToolTip(chkAlwaysJitter, "Always keep Jitter enabled");
            toolTip.SetToolTip(trackBarJitter, "Adjust Jitter strength");
            toolTip.SetToolTip(chkAlwaysRecoilReduction, "Always keep Recoil Reduction enabled");
            toolTip.SetToolTip(trackBarRecoilReduction, "Adjust Recoil Reduction strength");
            toolTip.SetToolTip(chkMinimizeToTray, "Minimize to system tray when closing");
        }

        private void chkMinimizeToTray_CheckedChanged(object sender, EventArgs e)
        {
            SaveCurrentSettings();
        }
    }
}
</file>

</files>
