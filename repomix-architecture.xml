This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
app.manifest
build.bat
buildCommand.md
docs/architecture.md
docs/implementation_plan.md
docs/implementation_profile.md
docs/improvement.md
MouseMacro.csproj
MouseMacro.sln
newDirectoryStructure.md
README.md
src/Configuration/AppConfiguration.cs
src/Configuration/ConfigurationEvents.cs
src/Configuration/ConfigurationManager.cs
src/Configuration/EventHandlerExtensions.cs
src/Configuration/EventHandlerManager.cs
src/Configuration/Settings.cs
src/Configuration/SettingsManager.cs
src/Configuration/SettingsValidation.cs
src/Configuration/Validation.cs
src/Hooks/KeyboardHook.cs
src/Hooks/MouseHook.cs
src/Hooks/NativeMethods.cs
src/Hooks/WinMessages.cs
src/Program.cs
src/UI/Controls/ModernButton.cs
src/UI/Controls/ModernTrackBar.cs
src/UI/MacroForm.cs
src/UI/MacroForm.Designer.cs
src/UI/MacroForm.resx
src/UI/Resources.Designer.cs
src/UI/Resources.resx
src/UI/UIManager.cs
src/Utilities/HotkeyManager.cs
src/Utilities/InputSimulator.cs
src/Utilities/JitterManager.cs
src/Utilities/MacroManager.cs
src/Utilities/RecoilReductionManager.cs
src/Utilities/ToggleType.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app.manifest">
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="Notes&amp;Tasks"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="requireAdministrator" uiAccess="true" />
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
</file>

<file path="buildCommand.md">
# Batch (CMD)
dotnet clean && rmdir /s /q bin obj && dotnet restore && dotnet build -c Debug && dotnet build -c Release

# PowerShell
dotnet clean; Remove-Item -Recurse -Force bin,obj; dotnet restore; dotnet build -c Debug; dotnet build -c Release
</file>

<file path="docs/implementation_profile.md">
# Profile System Implementation Plan

This document outlines the detailed plan for implementing the Profile System feature in the "MouseMacro" (Notes & Tasks) application. The feature will allow users to save, load, update, and manage multiple configuration profiles, with a default profile that cannot be deleted or updated. Profiles will be stored as JSON files in a dedicated directory alongside the executable, and the UI will include a dropdown menu for profile management, adhering to the application's modern theme.

## Table of Contents

- [Profile System Implementation Plan](#profile-system-implementation-plan)
  - [Table of Contents](#table-of-contents)
  - [Update Configuration Storage](#update-configuration-storage)
  - [Modify the UI](#modify-the-ui)
  - [Implement Profile Management Logic](#implement-profile-management-logic)
  - [Update Existing Code](#update-existing-code)
  - [Testing](#testing)

---

## Update Configuration Storage

The current application saves its state settings to a single JSON file in the executable folder via the `ConfigurationManager`. This section details how to extend this to support multiple profiles stored in a dedicated "Profiles" directory.

- **Create Profiles Directory:**
  - In the `ConfigurationManager` constructor, check if a "Profiles" directory exists in the executable folder. If not, create it using `Directory.CreateDirectory`.

- **Save Profile:**
  - Add a `SaveProfile(string profileName)` method to `ConfigurationManager`.
  - Validate the profile name to ensure it’s not null or empty.
  - Check if a profile with the same name exists. If it does (and isn’t the default profile), prompt the user to confirm overwriting.
  - Serialize the current configuration to JSON and save it as `${profileName}.json` in the "Profiles" directory.

- **Load Profile:**
  - Add a `LoadProfile(string profileName)` method to `ConfigurationManager`.
  - Validate the profile name.
  - Check if `${profileName}.json` exists in the "Profiles" directory. If not, display an error message.
  - Deserialize the JSON file into an `AppConfiguration` object and update the current configuration.

- **Update Profile:**
  - Add an `UpdateProfile(string profileName)` method to `ConfigurationManager`.
  - Validate the profile name.
  - Check if the profile is the default profile. If so, prevent the update and show a message (e.g., "The default profile cannot be updated").
  - Serialize the current configuration to JSON and overwrite the existing `${profileName}.json` file.

- **Rename Profile:**
  - Add a `RenameProfile(string oldName, string newName)` method to `ConfigurationManager`.
  - Validate both old and new names.
  - Check if the old profile is the default profile or if the new name already exists. If either condition is true, prevent the rename and show a message.
  - Rename the file from `${oldName}.json` to `${newName}.json` in the "Profiles" directory.

- **Get Profile Names:**
  - Add a `GetProfileNames()` method to `ConfigurationManager`.
  - Scan the "Profiles" directory for `.json` files and return a list of profile names (without the `.json` extension).

- **Default Profile:**
  - Define a constant `DEFAULT_PROFILE_NAME = "Default"`.
  - In the `ConfigurationManager` initialization, check if `Default.json` exists in the "Profiles" directory. If not, create it with default settings.
  - Ensure methods that modify profiles (update, rename) block operations on the default profile.

---

## Modify the UI

The UI will be updated to include a dropdown menu and buttons for profile management, following the application’s modern theme (e.g., consistent fonts, colors, and styles).

- **Add Profile Selection Dropdown:**
  - Add a `ComboBox` named `cmbProfiles` to the `settingsPanel`.
  - Style it to match the modern theme (e.g., use `JetBrains Mono` font, current color scheme).
  - Populate it with available profiles using `configManager.GetProfileNames()` when the form loads or after profile operations.

- **Add Profile Management Buttons:**
  - Add `ModernButton`s for the following actions:
    - "Save New Profile" (`btnSaveProfile`)
    - "Load Profile" (`btnLoadProfile`)
    - "Update Profile" (`btnUpdateProfile`)
    - "Rename Profile" (`btnRenameProfile`)
  - Arrange these buttons logically within the `settingsPanel`, ensuring alignment with existing controls.

- **Display Current Profile:**
  - Add a label (e.g., `lblCurrentProfile`) to show the current profile name, formatted as "Current Profile: [profileName]".
  - If the current profile is the default, append "(Default)" or adjust button states (e.g., disable update/rename).

- **UI Theme:**
  - Use the existing modern theme for all new controls:
    - Font: `JetBrains Mono`
    - Colors: Match the current scheme (e.g., dark background, light text)
    - Styles: Use `ModernButton` for buttons and apply consistent padding/margins.

---

## Implement Profile Management Logic

This section covers the logic behind profile operations, triggered by UI interactions.

- **Save New Profile:**
  - On `btnSaveProfile.Click`:
    - Prompt the user for a profile name via a dialog or text input.
    - Call `configManager.SaveProfile(profileName)`.
    - If successful, refresh `cmbProfiles` and select the new profile.

- **Load Profile:**
  - On `btnLoadProfile.Click`:
    - Get the selected profile from `cmbProfiles`.
    - Call `configManager.LoadProfile(selectedProfile)`.
    - If successful, update the UI and application state with the loaded settings.

- **Update Profile:**
  - On `btnUpdateProfile.Click`:
    - Check if the current profile is not the default.
    - If allowed, call `configManager.UpdateProfile(currentProfile)`.
    - If the default profile is selected, show a message (e.g., "Cannot update the default profile").

- **Rename Profile:**
  - On `btnRenameProfile.Click`:
    - Prompt the user for a new name.
    - Call `configManager.RenameProfile(currentProfile, newName)`.
    - If successful, refresh `cmbProfiles` and select the renamed profile.
    - If the default profile is selected, show a message (e.g., "Cannot rename the default profile").

- **Handle Default Profile:**
  - When `Default` is selected in `cmbProfiles`:
    - Disable `btnUpdateProfile` and `btnRenameProfile`.
    - Show a message if the user attempts to modify it.

---

## Update Existing Code

Integrate the Profile System with the existing codebase to ensure seamless operation.

- **Load Last Used Profile:**
  - Add a `LastUsedProfile` property to `AppConfiguration`.
  - On application startup:
    - Load the last used profile from the main configuration file.
    - If none exists or it’s invalid, load the default profile.

- **Update Current Profile:**
  - When settings are modified (e.g., via sliders or checkboxes):
    - If the current profile isn’t the default, call `configManager.UpdateProfile(currentProfile)` automatically.
    - If it’s the default, prompt the user to save a new profile or discard changes.

- **Switch Profiles:**
  - On `cmbProfiles.SelectedIndexChanged`:
    - Call `configManager.LoadProfile(selectedProfile)`.
    - Apply the loaded settings to the application and update `lblCurrentProfile`.

---

## Testing

Thorough testing ensures the feature meets all requirements and handles edge cases.

- **Test Cases:**
  - **Save Profile:** Create a new profile and verify a `${profileName}.json` file appears in the "Profiles" directory.
  - **Load Profile:** Load different profiles and confirm settings (e.g., jitter strength, hotkeys) apply correctly.
  - **Update Profile:** Modify settings, update a profile, and check that the JSON file reflects the changes.
  - **Rename Profile:** Rename a profile and verify the file name changes in the "Profiles" directory.
  - **Default Profile Protection:** Attempt to update or rename the default profile and ensure it’s blocked with a message.
  - **UI Updates:** Confirm `cmbProfiles` and `lblCurrentProfile` refresh correctly after each operation.

- **Edge Cases:**
  - Save a profile with an existing name and verify overwrite confirmation.
  - Attempt to load a non-existent profile and check for error handling.
  - Switch between multiple profiles and ensure settings apply consistently.
  - Delete `Default.json` manually, restart the app, and confirm it’s recreated.

---

This plan ensures the Profile System meets all specified requirements:
- Saving and loading named profiles as JSON files in a "Profiles" directory.
- Updating and renaming profiles, with a protected default profile.
- A modern-themed UI with a dropdown menu for profile management.
- Integration with the existing configuration system.
</file>

<file path="docs/improvement.md">
# Improvement Plan for MouseMacro Project

## Overview
This plan outlines a structured approach to enhance the "MouseMacro" project by improving its modularization, professionalism, and code quality. The focus is on aligning the project with best practices for C# .NET development (using .NET 6.0), organizing the directory structure for clarity, and refining the codebase while preserving all existing functionality and integrity.

## Goals
- **Modularization**: Break the code into smaller, well-defined modules with single responsibilities.
- **Directory Structure**: Organize files into logical folders for a neat and maintainable structure.
- **Code Quality**: Apply best practices like SOLID principles, clean code, and robust error handling.
- **Configuration Management**: Enhance the handling of configuration settings for efficiency and security.
- **UI and Business Logic Separation**: Decouple UI code from business logic for better testability and maintainability.
- **Documentation**: Add comprehensive documentation to improve understanding and future maintenance.
- **Testing**: Introduce unit tests to ensure functionality and prevent regressions.

## Step-by-Step Plan

### 1. Backup the Current Project
- **Action**: Create a full backup of the project directory.
- **Purpose**: Preserve the original code to avoid accidental loss during refactoring.
- **How**: Copy the entire project folder to a safe location (e.g., external drive or version control system like Git).

### 2. Organize Directory Structure
- **Action**: Restructure the project files into logical folders.
- **New Structure**:
  - `src/`: Contains all source code files.
    - `UI/`: For Windows Forms and custom controls (e.g., `MacroForm.cs`).
    - `Configuration/`: For settings management (e.g., `SettingsManager.cs`).
    - `Hooks/`: For low-level input handling (e.g., `NativeMethods.cs`).
    - `Utilities/`: For helper and manager classes.
    - `Models/`: For data models (if any).
  - `tests/`: For unit test projects.
  - `docs/`: For documentation files.
- **Steps**:
  1. Create the above folders in the project directory.
  2. Move existing files to their respective folders (e.g., `MacroForm.cs` to `src/UI/`).
  3. Update the project file (`MouseMacro.csproj`) to reflect the new file paths.
- **Outcome**: A cleaner, more organized project layout.

### 3. Extract Hook Logic
- **Action**: Move hook-related functionality into dedicated classes.
- **Steps**:
  1. Create `KeyboardHook.cs` and `MouseHook.cs` in `src/Hooks/`.
  2. Move hook initialization, callback methods, and disposal logic from `MacroForm.cs` to these classes.
  3. Expose public methods (e.g., `Start()`, `Stop()`) for controlling the hooks.
- **Outcome**: Hook logic is encapsulated, adhering to the Single Responsibility Principle (SRP).

### 4. Create Manager Classes
- **Action**: Extract business logic into manager classes.
- **Steps**:
  1. Create `JitterManager.cs` and `RecoilReductionManager.cs` in `src/Utilities/` for jitter and recoil reduction logic.
  2. Move relevant methods (e.g., `OnJitterTimer`) into these classes.
  3. Create `MacroManager.cs` in `src/Utilities/` to coordinate macro state and interactions between managers.
  4. Update `MacroForm.cs` to delegate tasks to these managers.
- **Outcome**: Business logic is modularized, reducing the complexity of `MacroForm.cs`.

### 5. Refactor MacroForm.cs
- **Action**: Simplify the form class by removing business logic.
- **Steps**:
  1. Use dependency injection to inject `MacroManager`, `JitterManager`, and `RecoilReductionManager` into `MacroForm.cs`.
  2. Refactor event handlers to call methods on the manager classes.
  3. Keep `MacroForm.cs` focused on UI updates and event wiring.
- **Outcome**: A cleaner separation between UI and logic, improving maintainability.

### 6. Improve Configuration Management
- **Action**: Enhance the `SettingsManager.cs` class.
- **Steps**:
  1. Integrate `Microsoft.Extensions.Configuration` for robust configuration handling.
  2. Store the JSON configuration file in a standard location (e.g., `%AppData%/MouseMacro/`).
  3. Add validation to ensure configuration values are valid (e.g., ranges for jitter settings).
  4. Handle file I/O exceptions gracefully.
- **Outcome**: Configuration management is more professional and secure.

### 7. Separate UI and Business Logic
- **Action**: Implement a design pattern to decouple UI and logic.
- **Steps**:
  1. Choose the Model-View-Presenter (MVP) pattern for simplicity.
  2. Create a `MacroPresenter.cs` class in `src/UI/Presenters/` to handle business logic.
  3. Move logic from `MacroForm.cs` to `MacroPresenter.cs`.
  4. Update `MacroForm.cs` to interact with the presenter via an interface (e.g., `IMacroView`).
- **Outcome**: UI and business logic are fully separated, enhancing testability.

### 8. Enhance Code Quality
- **Action**: Apply best practices throughout the codebase.
- **Steps**:
  1. Rename variables and methods for clarity (e.g., `btnToggle` to `toggleButton`).
  2. Remove unused code and variables identified during refactoring.
  3. Use consistent formatting (e.g., indentation, brace style).
  4. Apply DRY (Don't Repeat Yourself) by consolidating duplicated code.
  5. Use `readonly` for immutable fields and `const` for constants.
  6. Add exception handling with meaningful error messages.
  7. Integrate a logging framework (e.g., Serilog) for debugging.
- **Outcome**: Code is cleaner, more readable, and adheres to C# best practices.

### 9. Add Documentation
- **Action**: Document the codebase for future maintainers.
- **Steps**:
  1. Add XML comments to all public classes, methods, and properties (e.g., `/// <summary>`).
  2. Create a `README.md` file in the root directory with:
     - Project overview
     - Setup instructions
     - Usage guidelines
  3. Place additional documentation (e.g., architecture overview) in `docs/`.
- **Outcome**: Code is well-documented, easing onboarding and maintenance.

### 10. Implement Unit Tests
- **Action**: Add tests to verify functionality.
- **Steps**:
  1. Create a test project under `tests/` using a framework like xUnit.
  2. Write tests for:
     - Hook initialization and callbacks
     - Jitter and recoil reduction logic
     - Configuration loading/saving
     - Macro state management
  3. Mock dependencies (e.g., hooks) using a library like Moq.
  4. Run tests to ensure 100% coverage of critical components.
- **Outcome**: Functionality is validated, and regressions are prevented.

### 11. Test the Application
- **Action**: Manually verify the refactored application.
- **Steps**:
  1. Run the application and test all features (e.g., macro toggling, settings changes).
  2. Verify UI updates (e.g., button states, labels).
  3. Ensure hooks work correctly (e.g., mouse/keyboard input capture).
  4. Confirm configuration persists across sessions.
- **Outcome**: Assurance that functionality and integrity are intact.

### 12. Review and Iterate
- **Action**: Finalize the improvements.
- **Steps**:
  1. Review the refactored code for adherence to goals.
  2. Address any issues found during testing.
  3. Commit changes to version control (if not already using Git).
- **Outcome**: A polished, professional codebase ready for future development.

## Conclusion
This plan transforms the "MouseMacro" project into a modular, professional, and maintainable application. By following these steps, you’ll achieve a tidy directory structure, improved code quality, and adherence to C# .NET 6.0 best practices—all while preserving the program’s original functionality and integrity. Each step builds incrementally, allowing for validation at every stage to ensure a smooth transition.
</file>

<file path="MouseMacro.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35818.85 d17.13
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MouseMacro", "MouseMacro.csproj", "{1FFAD009-1089-42F1-C326-6CC678F746BF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1FFAD009-1089-42F1-C326-6CC678F746BF}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E2EE0FEB-3FDA-4BFB-A0AF-B207C69E2C25}
	EndGlobalSection
EndGlobal
</file>

<file path="src/Configuration/AppConfiguration.cs">
using System;
using System.Drawing;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Root configuration class that contains all application settings.
    /// </summary>
    public class AppConfiguration : ICloneable
    {
        public JitterConfiguration JitterSettings { get; set; }
        public RecoilConfiguration RecoilSettings { get; set; }
        public HotkeyConfiguration HotkeySettings { get; set; }
        public UIConfiguration UISettings { get; set; }
        public BackupConfiguration BackupSettings { get; set; }

        public object Clone()
        {
            return new AppConfiguration
            {
                JitterSettings = (JitterConfiguration)JitterSettings?.Clone(),
                RecoilSettings = (RecoilConfiguration)RecoilSettings?.Clone(),
                HotkeySettings = (HotkeyConfiguration)HotkeySettings?.Clone(),
                UISettings = (UIConfiguration)UISettings?.Clone(),
                BackupSettings = (BackupConfiguration)BackupSettings?.Clone()
            };
        }
    }

    /// <summary>
    /// Configuration settings for the jitter functionality.
    /// </summary>
    public class JitterConfiguration : ICloneable
    {
        public int Strength { get; set; }
        public bool IsEnabled { get; set; }
        public bool AlwaysEnabled { get; set; }

        public object Clone()
        {
            return new JitterConfiguration
            {
                Strength = Strength,
                IsEnabled = IsEnabled,
                AlwaysEnabled = AlwaysEnabled
            };
        }
    }

    /// <summary>
    /// Configuration settings for the recoil reduction functionality.
    /// </summary>
    public class RecoilConfiguration : ICloneable
    {
        public int Strength { get; set; }
        public bool IsEnabled { get; set; }
        public bool AlwaysEnabled { get; set; }

        public object Clone()
        {
            return new RecoilConfiguration
            {
                Strength = Strength,
                IsEnabled = IsEnabled,
                AlwaysEnabled = AlwaysEnabled
            };
        }
    }

    /// <summary>
    /// Configuration settings for hotkeys.
    /// </summary>
    public class HotkeyConfiguration : ICloneable
    {
        public string MacroToggleKey { get; set; }
        public string ModeSwitchKey { get; set; }

        public object Clone()
        {
            return new HotkeyConfiguration
            {
                MacroToggleKey = MacroToggleKey,
                ModeSwitchKey = ModeSwitchKey
            };
        }
    }

    /// <summary>
    /// Configuration settings for the user interface.
    /// </summary>
    public class UIConfiguration : ICloneable
    {
        public bool MinimizeToTray { get; set; }
        public bool ShowDebugPanel { get; set; }
        public Point WindowPosition { get; set; }
        public Size WindowSize { get; set; }

        public object Clone()
        {
            return new UIConfiguration
            {
                MinimizeToTray = MinimizeToTray,
                ShowDebugPanel = ShowDebugPanel,
                WindowPosition = new Point(WindowPosition.X, WindowPosition.Y),
                WindowSize = new Size(WindowSize.Width, WindowSize.Height)
            };
        }
    }

    /// <summary>
    /// Configuration settings for backup functionality.
    /// </summary>
    public class BackupConfiguration : ICloneable
    {
        public bool AutoBackupEnabled { get; set; }
        public int BackupIntervalHours { get; set; }
        public int MaxBackupCount { get; set; }
        public string BackupDirectory { get; set; }

        public object Clone()
        {
            return new BackupConfiguration
            {
                AutoBackupEnabled = AutoBackupEnabled,
                BackupIntervalHours = BackupIntervalHours,
                MaxBackupCount = MaxBackupCount,
                BackupDirectory = BackupDirectory
            };
        }
    }
}
</file>

<file path="src/Configuration/ConfigurationEvents.cs">
using System;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Event arguments for configuration change events.
    /// </summary>
    public class ConfigurationChangedEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the configuration section that was changed.
        /// </summary>
        public string Section { get; }

        /// <summary>
        /// Gets the previous configuration state.
        /// </summary>
        public AppConfiguration PreviousConfig { get; }

        /// <summary>
        /// Gets the new configuration state.
        /// </summary>
        public AppConfiguration NewConfig { get; }

        public ConfigurationChangedEventArgs(string section, AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            Section = section;
            PreviousConfig = previousConfig;
            NewConfig = newConfig;
        }
    }

    /// <summary>
    /// Event arguments for configuration validation events.
    /// </summary>
    public class ConfigurationValidationEventArgs : EventArgs
    {
        /// <summary>
        /// Gets or sets whether the configuration is valid.
        /// </summary>
        public bool IsValid { get; set; }

        /// <summary>
        /// Gets or sets the validation message.
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// Gets the configuration being validated.
        /// </summary>
        public AppConfiguration Configuration { get; }

        public ConfigurationValidationEventArgs(AppConfiguration configuration)
        {
            Configuration = configuration;
            IsValid = true;
        }
    }

    /// <summary>
    /// Event arguments for configuration backup events.
    /// </summary>
    public class ConfigurationBackupEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the backup file path.
        /// </summary>
        public string BackupPath { get; }

        /// <summary>
        /// Gets whether the backup was successful.
        /// </summary>
        public bool Success { get; }

        /// <summary>
        /// Gets any error message if the backup failed.
        /// </summary>
        public string ErrorMessage { get; }

        public ConfigurationBackupEventArgs(string backupPath, bool success, string errorMessage = null)
        {
            BackupPath = backupPath;
            Success = success;
            ErrorMessage = errorMessage;
        }
    }

    /// <summary>
    /// Delegate for configuration change events.
    /// </summary>
    public delegate void ConfigurationChangedEventHandler(object sender, ConfigurationChangedEventArgs e);

    /// <summary>
    /// Delegate for configuration validation events.
    /// </summary>
    public delegate void ConfigurationValidationEventHandler(object sender, ConfigurationValidationEventArgs e);

    /// <summary>
    /// Delegate for configuration backup events.
    /// </summary>
    public delegate void ConfigurationBackupEventHandler(object sender, ConfigurationBackupEventArgs e);
}
</file>

<file path="src/Configuration/EventHandlerExtensions.cs">
using System;
using System.Windows.Forms;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Provides extension methods for event handler registration.
    /// </summary>
    public static class EventHandlerExtensions
    {
        /// <summary>
        /// Registers all event handlers for a control with the event handler manager.
        /// </summary>
        /// <param name="control">The control to register events for.</param>
        /// <param name="manager">The event handler manager.</param>
        /// <returns>The control for method chaining.</returns>
        public static T RegisterEvents<T>(this T control, EventHandlerManager manager) where T : Control
        {
            manager.RegisterControlEvents(control);
            return control;
        }

        /// <summary>
        /// Unregisters all event handlers for a control from the event handler manager.
        /// </summary>
        /// <param name="control">The control to unregister events for.</param>
        /// <param name="manager">The event handler manager.</param>
        /// <returns>The control for method chaining.</returns>
        public static T UnregisterEvents<T>(this T control, EventHandlerManager manager) where T : Control
        {
            manager.UnregisterControlEvents(control);
            return control;
        }

        /// <summary>
        /// Registers a specific event handler with tracking.
        /// </summary>
        /// <param name="control">The control to register the event for.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The event handler delegate.</param>
        /// <param name="manager">The event handler manager.</param>
        /// <returns>The control for method chaining.</returns>
        public static T RegisterEventHandler<T>(this T control, string eventName, Delegate handler, EventHandlerManager manager) where T : Control
        {
            if (string.IsNullOrEmpty(eventName))
                throw new ArgumentNullException(nameof(eventName));

            if (handler == null)
                throw new ArgumentNullException(nameof(handler));

            // Add the event handler to the manager's tracking
            typeof(EventHandlerManager)
                .GetMethod("RegisterEventHandler", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
                ?.Invoke(manager, new object[] { $"{control.Name}_{eventName}", handler });

            return control;
        }

        /// <summary>
        /// Registers common event handlers for a TrackBar control.
        /// </summary>
        public static TrackBar RegisterTrackBarEvents(this TrackBar trackBar, EventHandlerManager manager, Action<int> onValueChanged = null)
        {
            if (onValueChanged != null)
            {
                EventHandler valueChangedHandler = (s, e) => onValueChanged(trackBar.Value);
                trackBar.RegisterEventHandler("ValueChanged", valueChangedHandler, manager);
                trackBar.ValueChanged += valueChangedHandler;
            }
            return trackBar;
        }

        /// <summary>
        /// Registers common event handlers for a CheckBox control.
        /// </summary>
        public static CheckBox RegisterCheckBoxEvents(this CheckBox checkBox, EventHandlerManager manager, Action<bool> onCheckedChanged = null)
        {
            if (onCheckedChanged != null)
            {
                EventHandler checkedChangedHandler = (s, e) => onCheckedChanged(checkBox.Checked);
                checkBox.RegisterEventHandler("CheckedChanged", checkedChangedHandler, manager);
                checkBox.CheckedChanged += checkedChangedHandler;
            }
            return checkBox;
        }

        /// <summary>
        /// Registers common event handlers for a Button control.
        /// </summary>
        public static Button RegisterButtonEvents(this Button button, EventHandlerManager manager, Action onClick = null)
        {
            if (onClick != null)
            {
                EventHandler clickHandler = (s, e) => onClick();
                button.RegisterEventHandler("Click", clickHandler, manager);
                button.Click += clickHandler;
            }
            return button;
        }

        /// <summary>
        /// Registers common event handlers for a TextBox control.
        /// </summary>
        public static TextBox RegisterTextBoxEvents(this TextBox textBox, EventHandlerManager manager, 
            Action<string> onTextChanged = null,
            Action<KeyEventArgs> onKeyDown = null)
        {
            if (onTextChanged != null)
            {
                EventHandler textChangedHandler = (s, e) => onTextChanged(textBox.Text);
                textBox.RegisterEventHandler("TextChanged", textChangedHandler, manager);
                textBox.TextChanged += textChangedHandler;
            }

            if (onKeyDown != null)
            {
                KeyEventHandler keyDownHandler = (s, e) => onKeyDown(e);
                textBox.RegisterEventHandler("KeyDown", keyDownHandler, manager);
                textBox.KeyDown += keyDownHandler;
            }

            return textBox;
        }
    }
}
</file>

<file path="src/Configuration/SettingsManager.cs">
using System;
using System.IO;
using Newtonsoft.Json;

namespace NotesAndTasks
{
    public static class SettingsManager
    {
        private static readonly string _configPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "macro_config.json");
        public static Settings CurrentSettings { get; private set; }

        static SettingsManager()
        {
            try
            {
                LoadOrCreateSettings();
            }
            catch (Exception)
            {
                CurrentSettings = new Settings();
                try
                {
                    SaveSettings();
                }
                catch
                {
                    // If we can't save settings, at least we have defaults in memory
                }
            }
        }

        private static void LoadOrCreateSettings()
        {
            if (File.Exists(_configPath))
            {
                string jsonContent = File.ReadAllText(_configPath);
                CurrentSettings = JsonConvert.DeserializeObject<Settings>(jsonContent) ?? new Settings();
            }
            else
            {
                CurrentSettings = new Settings();
                SaveSettings();
            }
        }

        public static void SaveSettings()
        {
            try
            {
                string jsonContent = JsonConvert.SerializeObject(CurrentSettings, Formatting.Indented);
                File.WriteAllText(_configPath, jsonContent);
            }
            catch (Exception)
            {
                // Consider adding logging here if needed
            }
        }
    }
}
</file>

<file path="src/Configuration/Validation.cs">
using System;

namespace NotesAndTasks
{
    /// <summary>
    /// Provides validation methods for input values throughout the application.
    /// </summary>
    internal static class Validation
    {
        /// <summary>
        /// Validates a strength value for jitter or recoil reduction.
        /// </summary>
        /// <param name="strength">The strength value to validate.</param>
        /// <param name="minValue">The minimum allowed value (inclusive).</param>
        /// <param name="maxValue">The maximum allowed value (inclusive).</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the strength value is outside the valid range.</exception>
        public static void ValidateStrength(int strength, int minValue, int maxValue, string paramName)
        {
            if (strength < minValue || strength > maxValue)
            {
                throw new ArgumentOutOfRangeException(
                    paramName,
                    strength,
                    $"Strength value must be between {minValue} and {maxValue}."
                );
            }
        }

        /// <summary>
        /// Validates that a string parameter is not null or empty.
        /// </summary>
        /// <param name="value">The string value to validate.</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentNullException">Thrown when the value is null.</exception>
        /// <exception cref="ArgumentException">Thrown when the value is empty.</exception>
        public static void ValidateStringNotNullOrEmpty(string value, string paramName)
        {
            if (value == null)
            {
                throw new ArgumentNullException(paramName);
            }
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Value cannot be empty or whitespace.", paramName);
            }
        }

        /// <summary>
        /// Validates that a reference parameter is not null.
        /// </summary>
        /// <typeparam name="T">The type of the parameter.</typeparam>
        /// <param name="value">The value to validate.</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentNullException">Thrown when the value is null.</exception>
        public static void ValidateNotNull<T>(T value, string paramName) where T : class
        {
            if (value == null)
            {
                throw new ArgumentNullException(paramName);
            }
        }

        /// <summary>
        /// Validates that a handle is not IntPtr.Zero.
        /// </summary>
        /// <param name="handle">The handle to validate.</param>
        /// <param name="paramName">The name of the parameter being validated.</param>
        /// <exception cref="ArgumentException">Thrown when the handle is IntPtr.Zero.</exception>
        public static void ValidateHandle(IntPtr handle, string paramName)
        {
            if (handle == IntPtr.Zero)
            {
                throw new ArgumentException("Handle cannot be zero.", paramName);
            }
        }

        /// <summary>
        /// Validates that a hook code is valid for processing.
        /// </summary>
        /// <param name="nCode">The hook code to validate.</param>
        /// <returns>True if the hook code should be processed, false if it should be passed to the next hook.</returns>
        public static bool ValidateHookCode(int nCode)
        {
            return nCode >= 0;
        }
    }
}
</file>

<file path="src/UI/Controls/ModernButton.cs">
using System.Drawing.Drawing2D;
using System.ComponentModel;

namespace NotesAndTasks
{
    public class ModernButton : Button
    {
        private int borderRadius = 10;
        private Color borderColor = Color.FromArgb(250, 91, 101);
        private Color hoverBackColor = Color.FromArgb(214, 37, 106);
        private bool isHovered = false;

        [Category("Modern Button")]
        public int BorderRadius
        {
            get => borderRadius;
            set
            {
                borderRadius = value;
                Invalidate();
            }
        }

        [Category("Modern Button")]
        public Color BorderColor
        {
            get => borderColor;
            set
            {
                borderColor = value;
                Invalidate();
            }
        }

        [Category("Modern Button")]
        public Color HoverBackColor
        {
            get => hoverBackColor;
            set
            {
                hoverBackColor = value;
                Invalidate();
            }
        }

        public ModernButton()
        {
            FlatStyle = FlatStyle.Flat;
            FlatAppearance.BorderSize = 0;
            BackColor = Color.FromArgb(30, 1, 62);
            ForeColor = Color.White;
            Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            Size = new Size(150, 40);
            Cursor = Cursors.Hand;

            MouseEnter += (s, e) =>
            {
                isHovered = true;
                Invalidate();
            };

            MouseLeave += (s, e) =>
            {
                isHovered = false;
                Invalidate();
            };
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            var graphicsPath = new GraphicsPath();
            var rect = new Rectangle(0, 0, Width - 1, Height - 1);
            int radius = borderRadius;

            // Create rounded rectangle path
            graphicsPath.AddArc(rect.X, rect.Y, radius * 2, radius * 2, 180, 90);
            graphicsPath.AddArc(rect.Right - radius * 2, rect.Y, radius * 2, radius * 2, 270, 90);
            graphicsPath.AddArc(rect.Right - radius * 2, rect.Bottom - radius * 2, radius * 2, radius * 2, 0, 90);
            graphicsPath.AddArc(rect.X, rect.Bottom - radius * 2, radius * 2, radius * 2, 90, 90);
            graphicsPath.CloseFigure();

            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;

            // Fill background
            using (var brush = new SolidBrush(isHovered ? hoverBackColor : BackColor))
            {
                e.Graphics.FillPath(brush, graphicsPath);
            }

            // Draw border
            using (var pen = new Pen(borderColor, 1))
            {
                e.Graphics.DrawPath(pen, graphicsPath);
            }

            // Draw text
            var textRect = new Rectangle(0, 0, Width, Height);
            TextRenderer.DrawText(e.Graphics, Text, Font, textRect, ForeColor,
                TextFormatFlags.HorizontalCenter | TextFormatFlags.VerticalCenter);

            graphicsPath.Dispose();
        }
    }
}
</file>

<file path="src/UI/Controls/ModernTrackBar.cs">
using System.Drawing.Drawing2D;
using System.ComponentModel;

namespace NotesAndTasks
{
    public class ModernTrackBar : TrackBar
    {
        private Color tickColor = Color.FromArgb(250, 91, 101);
        private Color trackColor = Color.FromArgb(214, 37, 106);
        private Color thumbColor = Color.FromArgb(255,255,255);
        private bool isDragging = false;

        [Category("Modern TrackBar")]
        public Color TickColor
        {
            get => tickColor;
            set
            {
                tickColor = value;
                Invalidate();
            }
        }

        [Category("Modern TrackBar")]
        public Color TrackColor
        {
            get => trackColor;
            set
            {
                trackColor = value;
                Invalidate();
            }
        }

        [Category("Modern TrackBar")]
        public Color ThumbColor
        {
            get => thumbColor;
            set
            {
                thumbColor = value;
                Invalidate();
            }
        }

        public ModernTrackBar()
        {
            SetStyle(ControlStyles.UserPaint | 
                    ControlStyles.AllPaintingInWmPaint | 
                    ControlStyles.OptimizedDoubleBuffer, true);

            ValueChanged += (s, e) => Invalidate();
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                isDragging = true;
                UpdateValue(e.X);
            }
            base.OnMouseDown(e);
        }

        protected override void OnMouseMove(MouseEventArgs e)
        {
            if (isDragging)
            {
                UpdateValue(e.X);
            }
            base.OnMouseMove(e);
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                isDragging = false;
            }
            base.OnMouseUp(e);
        }

        private void UpdateValue(int mouseX)
        {
            if (mouseX < 10) mouseX = 10;
            if (mouseX > Width - 10) mouseX = Width - 10;

            float valueRange = Maximum - Minimum;
            float pixelRange = Width - 20;
            float valuePerPixel = valueRange / pixelRange;

            int newValue = (int)((mouseX - 10) * valuePerPixel) + Minimum;
            if (newValue < Minimum) newValue = Minimum;
            if (newValue > Maximum) newValue = Maximum;

            Value = newValue;
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
            e.Graphics.Clear(BackColor);

            var trackRect = new Rectangle(0, Height / 2 - 2, Width - 1, 4);
            using (var trackBrush = new SolidBrush(trackColor))
            {
                e.Graphics.FillRectangle(trackBrush, trackRect);
            }

            // Draw ticks
            if (TickStyle != TickStyle.None)
            {
                using (var tickPen = new Pen(tickColor, 1))
                {
                    int tickCount = Maximum - Minimum;
                    float tickSpacing = (Width - 20) / (float)tickCount;
                    for (int i = 0; i <= tickCount; i++)
                    {
                        int x = 10 + (int)(i * tickSpacing);
                        e.Graphics.DrawLine(tickPen, x, Height / 2 + 5, x, Height / 2 + 10);
                    }
                }
            }

            // Draw thumb
            float thumbPosition = (Value - Minimum) * (Width - 20) / (float)(Maximum - Minimum) + 10;
            var thumbRect = new Rectangle((int)thumbPosition - 6, Height / 2 - 6, 12, 12);
            using (var thumbBrush = new SolidBrush(thumbColor))
            {
                e.Graphics.FillEllipse(thumbBrush, thumbRect);
            }
        }
    }
}
</file>

<file path="src/UI/MacroForm.resx">
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="notifyIcon.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="trayContextMenu.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>125, 17</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>45</value>
  </metadata>
</root>
</file>

<file path="src/UI/Resources.Designer.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NotesTasks.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("NotesTasks.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
</file>

<file path="src/UI/Resources.resx">
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
</file>

<file path="src/UI/UIManager.cs">
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using NotesAndTasks.Configuration;
using NotesAndTasks.Utilities;

namespace NotesAndTasks.UI
{
    /// <summary>
    /// Manages UI-specific operations and state updates.
    /// </summary>
    public class UIManager : IDisposable
    {
        #region Fields
        private readonly Form form;
        private readonly MacroManager macroManager;
        private readonly HotkeyManager hotkeyManager;
        private readonly TextBox debugLabel;
        private readonly Label lblJitterActive;
        private readonly Label lblRecoilReductionActive;
        private readonly Label lblCurrentKeyValue;
        private readonly Label lblMacroSwitchKeyValue;
        private readonly Label lblJitterStrengthValue;
        private readonly Label lblRecoilReductionStrengthValue;
        private readonly NotifyIcon notifyIcon;
        private readonly ToolTip toolTip;
        private bool disposed = false;
        #endregion

        #region Constructor
        public UIManager(
            Form form,
            MacroManager macroManager,
            HotkeyManager hotkeyManager,
            TextBox debugLabel,
            Label lblJitterActive,
            Label lblRecoilReductionActive,
            Label lblCurrentKeyValue,
            Label lblMacroSwitchKeyValue,
            Label lblJitterStrengthValue,
            Label lblRecoilReductionStrengthValue,
            NotifyIcon notifyIcon,
            ToolTip toolTip)
        {
            this.form = form ?? throw new ArgumentNullException(nameof(form));
            this.macroManager = macroManager ?? throw new ArgumentNullException(nameof(macroManager));
            this.hotkeyManager = hotkeyManager ?? throw new ArgumentNullException(nameof(hotkeyManager));
            this.debugLabel = debugLabel ?? throw new ArgumentNullException(nameof(debugLabel));
            this.lblJitterActive = lblJitterActive ?? throw new ArgumentNullException(nameof(lblJitterActive));
            this.lblRecoilReductionActive = lblRecoilReductionActive ?? throw new ArgumentNullException(nameof(lblRecoilReductionActive));
            this.lblCurrentKeyValue = lblCurrentKeyValue ?? throw new ArgumentNullException(nameof(lblCurrentKeyValue));
            this.lblMacroSwitchKeyValue = lblMacroSwitchKeyValue ?? throw new ArgumentNullException(nameof(lblMacroSwitchKeyValue));
            this.lblJitterStrengthValue = lblJitterStrengthValue ?? throw new ArgumentNullException(nameof(lblJitterStrengthValue));
            this.lblRecoilReductionStrengthValue = lblRecoilReductionStrengthValue ?? throw new ArgumentNullException(nameof(lblRecoilReductionStrengthValue));
            this.notifyIcon = notifyIcon ?? throw new ArgumentNullException(nameof(notifyIcon));
            this.toolTip = toolTip ?? throw new ArgumentNullException(nameof(toolTip));

            InitializeTooltips();
            InitializeIcon();
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Updates the form title to reflect current macro state and mode.
        /// </summary>
        public void UpdateTitle()
        {
            string jitterMode = macroManager.IsAlwaysJitterMode ? "Always Jitter" :
                (macroManager.IsJitterEnabled ? "Jitter" : "Jitter (OFF)");

            string recoilMode = macroManager.IsAlwaysRecoilReductionMode ? "Always Recoil Reduction" :
                (macroManager.IsJitterEnabled ? "Recoil Reduction (OFF)" : "Recoil Reduction");

            form.Text = $"Notes&Tasks [{(macroManager.IsEnabled ? "ON" : "OFF")}] - {jitterMode} / {recoilMode} Mode";
            UpdateModeLabels();
        }

        /// <summary>
        /// Updates the displayed current key binding for macro toggle.
        /// </summary>
        /// <param name="key">The key name to display.</param>
        public void UpdateCurrentKey(string key)
        {
            if (lblCurrentKeyValue != null)
            {
                lblCurrentKeyValue.Text = key;
            }
        }

        /// <summary>
        /// Updates the displayed key binding for mode switching.
        /// </summary>
        /// <param name="key">The key name to display.</param>
        public void UpdateSwitchKey(string key)
        {
            if (lblMacroSwitchKeyValue != null)
            {
                lblMacroSwitchKeyValue.Text = key;
            }
        }

        /// <summary>
        /// Updates the displayed jitter strength value.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="strength">The strength value to display (1-20).</param>
        public void UpdateJitterStrength(int strength)
        {
            try
            {
                if (form.InvokeRequired)
                {
                    form.Invoke(new Action<int>(UpdateJitterStrength), strength);
                    return;
                }

                lblJitterStrengthValue.Text = strength.ToString();
                UpdateDebugInfo($"Jitter strength updated to: {strength}");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error updating jitter strength: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates the displayed recoil reduction strength value.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="strength">The strength value to display (1-20).</param>
        public void UpdateRecoilReductionStrength(int strength)
        {
            try
            {
                if (form.InvokeRequired)
                {
                    form.Invoke(new Action<int>(UpdateRecoilReductionStrength), strength);
                    return;
                }

                lblRecoilReductionStrengthValue.Text = strength.ToString();
                UpdateDebugInfo($"Recoil reduction strength updated to: {strength}");
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error updating recoil reduction strength: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates the displayed macro switch key value.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="key">The key name to display.</param>
        public void UpdateMacroSwitchKey(string key)
        {
            if (form.InvokeRequired)
            {
                form.Invoke(new Action<string>(UpdateMacroSwitchKey), key);
                return;
            }
            lblMacroSwitchKeyValue.Text = key;
            UpdateDebugInfo($"Macro switch key updated to: {key}");
        }

        /// <summary>
        /// Updates the active mode labels in the UI.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        public void UpdateModeLabels()
        {
            if (form.InvokeRequired)
            {
                form.Invoke(new Action(UpdateModeLabels));
                return;
            }

            lblRecoilReductionActive.Text = (!macroManager.IsJitterEnabled && macroManager.IsEnabled) ? "[Active]" : "";
            lblJitterActive.Text = (macroManager.IsJitterEnabled && macroManager.IsEnabled) ? "[Active]" : "";
        }

        /// <summary>
        /// Shows and activates the main window when restored from system tray.
        /// </summary>
        public void ShowWindow()
        {
            form.Show();
            form.WindowState = FormWindowState.Normal;
            form.Activate();
            notifyIcon.Visible = false;
            UpdateDebugInfo("Application restored from system tray");
        }

        /// <summary>
        /// Adds a debug message to the debug panel with timestamp.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        /// <param name="message">The debug message to display.</param>
        public void UpdateDebugInfo(string message)
        {
            if (debugLabel.InvokeRequired)
            {
                debugLabel.Invoke(new Action(() => UpdateDebugInfo(message)));
                return;
            }

            string timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
            string newLine = $"[{timestamp}] {message}";

            // Keep last 100 lines of debug info
            var lines = debugLabel.Lines.ToList();
            lines.Add(newLine);
            if (lines.Count > 100)
            {
                lines.RemoveAt(0);
            }
            debugLabel.Lines = lines.ToArray();

            // Auto-scroll to bottom
            debugLabel.SelectionStart = debugLabel.TextLength;
            debugLabel.ScrollToCaret();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Initializes tooltips for various UI controls to provide user guidance.
        /// </summary>
        private void InitializeTooltips()
        {
            toolTip.SetToolTip(form.Controls.Find("chkAlwaysJitter", true).FirstOrDefault(), "Always keep Jitter enabled");
            toolTip.SetToolTip(form.Controls.Find("trackBarJitter", true).FirstOrDefault(), "Adjust Jitter strength");
            toolTip.SetToolTip(form.Controls.Find("chkAlwaysRecoilReduction", true).FirstOrDefault(), "Always keep Recoil Reduction enabled");
            toolTip.SetToolTip(form.Controls.Find("trackBarRecoilReduction", true).FirstOrDefault(), "Adjust Recoil Reduction strength");
            toolTip.SetToolTip(form.Controls.Find("chkMinimizeToTray", true).FirstOrDefault(), "Minimize to system tray when closing");
        }

        /// <summary>
        /// Initializes the application icon for both the main window and system tray.
        /// </summary>
        private void InitializeIcon()
        {
            try
            {
                using var icon = Icon.ExtractAssociatedIcon(Application.ExecutablePath);
                if (icon != null)
                {
                    form.Icon = (Icon)icon.Clone();
                    notifyIcon.Icon = (Icon)icon.Clone();
                }
            }
            catch (Exception ex)
            {
                UpdateDebugInfo($"Error loading icon: {ex.Message}");
            }
        }
        #endregion

        #region IDisposable Implementation
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    notifyIcon?.Dispose();
                    toolTip?.Dispose();
                }
                disposed = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}
</file>

<file path="src/Utilities/HotkeyManager.cs">
using System;
using System.Windows.Forms;
using NotesAndTasks.Configuration;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Manages hotkeys and key bindings for the macro application.
    /// </summary>
    public class HotkeyManager
    {
        #region Events
        public event EventHandler<Keys> MacroKeyChanged;
        public event EventHandler<Keys> SwitchKeyChanged;
        #endregion

        #region Fields
        private Keys macroKey = Keys.Capital;  // Default to Caps Lock
        private Keys switchKey = Keys.Q;       // Default to Q
        private ToggleType toggleType = ToggleType.Keyboard;
        #endregion

        #region Properties
        /// <summary>
        /// Gets the current macro toggle key.
        /// </summary>
        public Keys MacroKey => macroKey;

        /// <summary>
        /// Gets the current mode switch key.
        /// </summary>
        public Keys SwitchKey => switchKey;

        /// <summary>
        /// Gets the current toggle type.
        /// </summary>
        public ToggleType ToggleType => toggleType;
        #endregion

        #region Public Methods
        /// <summary>
        /// Sets the macro toggle key.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="type">The type of toggle.</param>
        public void SetMacroKey(Keys key, ToggleType type)
        {
            macroKey = key;
            toggleType = type;
            MacroKeyChanged?.Invoke(this, key);
            SaveSettings();
        }

        /// <summary>
        /// Sets the mode switch key.
        /// </summary>
        /// <param name="key">The key to set.</param>
        public void SetSwitchKey(Keys key)
        {
            switchKey = key;
            SwitchKeyChanged?.Invoke(this, key);
            SaveSettings();
        }

        /// <summary>
        /// Loads hotkey settings from the settings manager.
        /// </summary>
        public void LoadSettings()
        {
            var settings = SettingsManager.CurrentSettings;
            if (settings != null)
            {
                macroKey = settings.MacroKey;
                switchKey = settings.SwitchKey;
                toggleType = settings.ToggleType;
            }
        }

        /// <summary>
        /// Saves current hotkey settings to the settings manager.
        /// </summary>
        private void SaveSettings()
        {
            var settings = SettingsManager.CurrentSettings;
            if (settings != null)
            {
                settings.MacroKey = macroKey;
                settings.SwitchKey = switchKey;
                settings.ToggleType = toggleType;
                SettingsManager.SaveSettings();
            }
        }

        /// <summary>
        /// Resets hotkeys to their default values.
        /// </summary>
        public void ResetToDefaults()
        {
            SetMacroKey(Keys.Capital, ToggleType.Keyboard);
            SetSwitchKey(Keys.Q);
        }
        #endregion
    }
}
</file>

<file path="src/Utilities/ToggleType.cs">
namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Defines the types of input that can be used to toggle the macro functionality.
    /// </summary>
    public enum ToggleType
    {
        /// <summary>Keyboard key input</summary>
        Keyboard,
        /// <summary>Middle mouse button input</summary>
        MouseMiddle,
        /// <summary>Mouse button 4 (XButton1) input</summary>
        MouseX1,
        /// <summary>Mouse button 5 (XButton2) input</summary>
        MouseX2
    }
}
</file>

<file path="newDirectoryStructure.md">
src/
├── UI/
│   ├── Controls/
│   │   ├── ModernButton.cs
│   │   └── ModernTrackBar.cs
│   ├── MacroForm.cs
│   ├── MacroForm.Designer.cs
│   ├── MacroForm.resx
│   ├── Resources.Designer.cs
│   └── Resources.resx
├── Configuration/
│   ├── AppConfiguration.cs
│   ├── ConfigurationEvents.cs
│   ├── ConfigurationManager.cs
│   ├── EventHandlerExtensions.cs
│   ├── EventHandlerManager.cs
│   ├── Settings.cs
│   ├── SettingsManager.cs
│   ├── SettingsValidation.cs
│   └── Validation.cs
├── Hooks/
│   ├── NativeMethods.cs
│   └── WinMessages.cs
├── Models/
├── Utilities/
└── Program.cs
|
├── tests/
├── docs/
</file>

<file path="src/Configuration/ConfigurationManager.cs">
using System;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Windows.Forms;
using System.Linq;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Manages application configuration, providing thread-safe access to settings
    /// and handling configuration persistence.
    /// </summary>
    public class ConfigurationManager
    {
        private static readonly Lazy<ConfigurationManager> instance = 
            new Lazy<ConfigurationManager>(() => new ConfigurationManager(), LazyThreadSafetyMode.ExecutionAndPublication);

        private readonly ReaderWriterLockSlim configLock = new ReaderWriterLockSlim();
        private readonly string configFilePath;
        private AppConfiguration currentConfig;
        private readonly JsonSerializerOptions jsonOptions;

        // Add these event declarations after the existing fields
        public event ConfigurationChangedEventHandler ConfigurationChanged;
        public event ConfigurationValidationEventHandler ConfigurationValidating;
        public event ConfigurationBackupEventHandler ConfigurationBackupCompleted;

        /// <summary>
        /// Gets the singleton instance of the ConfigurationManager.
        /// </summary>
        public static ConfigurationManager Instance => instance.Value;

        /// <summary>
        /// Gets the current configuration. Thread-safe access to configuration values.
        /// </summary>
        public AppConfiguration CurrentConfig
        {
            get
            {
                configLock.EnterReadLock();
                try
                {
                    return (AppConfiguration)currentConfig.Clone();
                }
                finally
                {
                    configLock.ExitReadLock();
                }
            }
        }

        private ConfigurationManager()
        {
            configFilePath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                "NotesAndTasks",
                "config.json"
            );

            jsonOptions = new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNameCaseInsensitive = true
            };

            InitializeConfiguration();
        }

        /// <summary>
        /// Initializes the configuration system, creating default config if none exists.
        /// </summary>
        private void InitializeConfiguration()
        {
            try
            {
                // Ensure directory exists
                Directory.CreateDirectory(Path.GetDirectoryName(configFilePath));

                if (File.Exists(configFilePath))
                {
                    LoadConfiguration();
                }
                else
                {
                    currentConfig = CreateDefaultConfiguration();
                    SaveConfiguration();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error initializing configuration: {ex.Message}");
                currentConfig = CreateDefaultConfiguration();
            }
        }

        /// <summary>
        /// Creates a default configuration with preset values.
        /// </summary>
        private AppConfiguration CreateDefaultConfiguration()
        {
            return new AppConfiguration
            {
                JitterSettings = new JitterConfiguration
                {
                    Strength = 3,
                    IsEnabled = false,
                    AlwaysEnabled = false
                },
                RecoilSettings = new RecoilConfiguration
                {
                    Strength = 1,
                    IsEnabled = true,
                    AlwaysEnabled = false
                },
                HotkeySettings = new HotkeyConfiguration
                {
                    MacroToggleKey = Keys.Capital.ToString(),
                    ModeSwitchKey = Keys.Q.ToString()
                },
                UISettings = new UIConfiguration
                {
                    MinimizeToTray = false,
                    ShowDebugPanel = false,
                    WindowPosition = new System.Drawing.Point(100, 100),
                    WindowSize = new System.Drawing.Size(800, 600)
                },
                BackupSettings = new BackupConfiguration
                {
                    AutoBackupEnabled = true,
                    BackupIntervalHours = 24,
                    MaxBackupCount = 5,
                    BackupDirectory = Path.Combine(
                        Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                        "NotesAndTasks",
                        "Backups"
                    )
                }
            };
        }

        /// <summary>
        /// Updates the configuration with new values and saves to disk.
        /// </summary>
        /// <param name="newConfig">The new configuration to apply.</param>
        /// <param name="section">The section being updated.</param>
        /// <returns>True if the update was successful, false otherwise.</returns>
        public bool UpdateConfiguration(AppConfiguration newConfig, string section = "General")
        {
            if (newConfig == null)
                throw new ArgumentNullException(nameof(newConfig));

            configLock.EnterWriteLock();
            try
            {
                // Raise validation event
                var validationArgs = new ConfigurationValidationEventArgs(newConfig);
                OnConfigurationValidating(validationArgs);

                if (!validationArgs.IsValid || !ValidateConfiguration(newConfig))
                {
                    System.Diagnostics.Debug.WriteLine($"Configuration validation failed: {validationArgs.Message}");
                    return false;
                }

                var previousConfig = currentConfig?.Clone() as AppConfiguration;
                currentConfig = newConfig.Clone() as AppConfiguration;
                SaveConfiguration();

                // Raise change event
                OnConfigurationChanged(new ConfigurationChangedEventArgs(section, previousConfig, currentConfig));
                return true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error updating configuration: {ex.Message}");
                return false;
            }
            finally
            {
                configLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Validates the configuration values.
        /// </summary>
        /// <param name="config">The configuration to validate.</param>
        /// <returns>True if the configuration is valid, false otherwise.</returns>
        private bool ValidateConfiguration(AppConfiguration config)
        {
            if (config == null) return false;

            try
            {
                // Validate Jitter settings
                if (config.JitterSettings.Strength < 1 || config.JitterSettings.Strength > 20)
                    return false;

                // Validate Recoil settings
                if (config.RecoilSettings.Strength < 1 || config.RecoilSettings.Strength > 20)
                    return false;

                // Validate hotkeys
                if (string.IsNullOrEmpty(config.HotkeySettings.MacroToggleKey) ||
                    string.IsNullOrEmpty(config.HotkeySettings.ModeSwitchKey))
                    return false;

                // Validate backup settings
                if (config.BackupSettings.AutoBackupEnabled)
                {
                    if (config.BackupSettings.BackupIntervalHours < 1 ||
                        config.BackupSettings.MaxBackupCount < 1 ||
                        string.IsNullOrEmpty(config.BackupSettings.BackupDirectory))
                        return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Configuration validation error: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Loads the configuration from disk.
        /// </summary>
        private void LoadConfiguration()
        {
            configLock.EnterWriteLock();
            try
            {
                string jsonContent = File.ReadAllText(configFilePath);
                var loadedConfig = JsonSerializer.Deserialize<AppConfiguration>(jsonContent, jsonOptions);

                if (ValidateConfiguration(loadedConfig))
                {
                    currentConfig = loadedConfig;
                }
                else
                {
                    currentConfig = CreateDefaultConfiguration();
                    SaveConfiguration();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error loading configuration: {ex.Message}");
                currentConfig = CreateDefaultConfiguration();
            }
            finally
            {
                configLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Saves the current configuration to disk.
        /// </summary>
        private void SaveConfiguration()
        {
            try
            {
                string jsonContent = JsonSerializer.Serialize(currentConfig, jsonOptions);
                File.WriteAllText(configFilePath, jsonContent);

                if (currentConfig.BackupSettings.AutoBackupEnabled)
                {
                    CreateConfigurationBackup();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error saving configuration: {ex.Message}");
            }
        }

        /// <summary>
        /// Creates a backup of the current configuration.
        /// </summary>
        private void CreateConfigurationBackup()
        {
            try
            {
                string backupDir = currentConfig.BackupSettings.BackupDirectory;
                Directory.CreateDirectory(backupDir);

                string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string backupPath = Path.Combine(backupDir, $"config_backup_{timestamp}.json");

                File.Copy(configFilePath, backupPath, true);

                // Cleanup old backups
                var backupFiles = Directory.GetFiles(backupDir, "config_backup_*.json")
                    .OrderByDescending(f => f)
                    .Skip(currentConfig.BackupSettings.MaxBackupCount);

                foreach (var file in backupFiles)
                {
                    try
                    {
                        File.Delete(file);
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine($"Error deleting old backup {file}: {ex.Message}");
                    }
                }

                // Raise backup completed event
                OnConfigurationBackupCompleted(new ConfigurationBackupEventArgs(backupPath, true));
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error creating configuration backup: {ex.Message}");
                OnConfigurationBackupCompleted(new ConfigurationBackupEventArgs(null, false, ex.Message));
            }
        }

        /// <summary>
        /// Restores configuration from a backup file.
        /// </summary>
        /// <param name="backupFilePath">Path to the backup file to restore from.</param>
        /// <returns>True if restore was successful, false otherwise.</returns>
        public bool RestoreFromBackup(string backupFilePath)
        {
            if (!File.Exists(backupFilePath))
                return false;

            configLock.EnterWriteLock();
            try
            {
                string jsonContent = File.ReadAllText(backupFilePath);
                var restoredConfig = JsonSerializer.Deserialize<AppConfiguration>(jsonContent, jsonOptions);

                if (ValidateConfiguration(restoredConfig))
                {
                    currentConfig = restoredConfig;
                    SaveConfiguration();
                    return true;
                }
                return false;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error restoring configuration: {ex.Message}");
                return false;
            }
            finally
            {
                configLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Gets a list of available configuration backups.
        /// </summary>
        /// <returns>Array of backup file paths.</returns>
        public string[] GetAvailableBackups()
        {
            try
            {
                string backupDir = currentConfig.BackupSettings.BackupDirectory;
                if (!Directory.Exists(backupDir))
                    return Array.Empty<string>();

                return Directory.GetFiles(backupDir, "config_backup_*.json")
                    .OrderByDescending(f => f)
                    .ToArray();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error getting available backups: {ex.Message}");
                return Array.Empty<string>();
            }
        }

        /// <summary>
        /// Raises the ConfigurationChanged event.
        /// </summary>
        protected virtual void OnConfigurationChanged(ConfigurationChangedEventArgs e)
        {
            ConfigurationChanged?.Invoke(this, e);
        }

        /// <summary>
        /// Raises the ConfigurationValidating event.
        /// </summary>
        protected virtual void OnConfigurationValidating(ConfigurationValidationEventArgs e)
        {
            ConfigurationValidating?.Invoke(this, e);
        }

        /// <summary>
        /// Raises the ConfigurationBackupCompleted event.
        /// </summary>
        protected virtual void OnConfigurationBackupCompleted(ConfigurationBackupEventArgs e)
        {
            ConfigurationBackupCompleted?.Invoke(this, e);
        }
    }
}
</file>

<file path="src/Configuration/EventHandlerManager.cs">
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Manages event handler registration and lifecycle for the application.
    /// Provides centralized control over event subscriptions and cleanup.
    /// </summary>
    public class EventHandlerManager : IDisposable
    {
        private readonly Dictionary<string, List<Delegate>> eventHandlers;
        private readonly ConfigurationManager configManager;
        private bool isDisposed;

        /// <summary>
        /// Initializes a new instance of the EventHandlerManager class.
        /// </summary>
        /// <param name="configManager">The configuration manager instance.</param>
        public EventHandlerManager(ConfigurationManager configManager)
        {
            this.configManager = configManager ?? throw new ArgumentNullException(nameof(configManager));
            this.eventHandlers = new Dictionary<string, List<Delegate>>();
            RegisterConfigurationEvents();
        }

        /// <summary>
        /// Registers configuration-related event handlers.
        /// </summary>
        private void RegisterConfigurationEvents()
        {
            // Configuration change handlers
            RegisterEventHandler("ConfigChanged", 
                new ConfigurationChangedEventHandler(OnConfigurationChanged));
            configManager.ConfigurationChanged += OnConfigurationChanged;

            // Configuration validation handlers
            RegisterEventHandler("ConfigValidating",
                new ConfigurationValidationEventHandler(OnConfigurationValidating));
            configManager.ConfigurationValidating += OnConfigurationValidating;

            // Configuration backup handlers
            RegisterEventHandler("ConfigBackup",
                new ConfigurationBackupEventHandler(OnConfigurationBackupCompleted));
            configManager.ConfigurationBackupCompleted += OnConfigurationBackupCompleted;
        }

        /// <summary>
        /// Registers a control's event handlers.
        /// </summary>
        /// <param name="control">The control to register events for.</param>
        public void RegisterControlEvents<T>(T control) where T : Control
        {
            if (control == null) return;

            // Store event handlers
            var handlers = new List<Delegate>();
            eventHandlers[control.Name] = handlers;

            // Common events
            EventHandler clickHandler = (s, e) => OnControlClick(control, e);
            control.Click += clickHandler;
            handlers.Add(clickHandler);

            // Mouse events
            MouseEventHandler mouseDownHandler = (s, e) => OnControlMouseDown(control, e);
            control.MouseDown += mouseDownHandler;
            handlers.Add(mouseDownHandler);

            MouseEventHandler mouseUpHandler = (s, e) => OnControlMouseUp(control, e);
            control.MouseUp += mouseUpHandler;
            handlers.Add(mouseUpHandler);

            // Type-specific events
            if (control is TrackBar trackBar)
            {
                EventHandler valueChangedHandler = (s, e) => OnTrackBarValueChanged(trackBar, e);
                trackBar.ValueChanged += valueChangedHandler;
                handlers.Add(valueChangedHandler);

                EventHandler scrollHandler = (s, e) => OnTrackBarScroll(trackBar, e);
                trackBar.Scroll += scrollHandler;
                handlers.Add(scrollHandler);
            }
            else if (control is CheckBox checkBox)
            {
                EventHandler checkedChangedHandler = (s, e) => OnCheckBoxCheckedChanged(checkBox, e);
                checkBox.CheckedChanged += checkedChangedHandler;
                handlers.Add(checkedChangedHandler);
            }
            else if (control is TextBox textBox)
            {
                EventHandler textChangedHandler = (s, e) => OnTextBoxTextChanged(textBox, e);
                textBox.TextChanged += textChangedHandler;
                handlers.Add(textChangedHandler);

                KeyEventHandler keyDownHandler = (s, e) => OnTextBoxKeyDown(textBox, e);
                textBox.KeyDown += keyDownHandler;
                handlers.Add(keyDownHandler);
            }
        }

        /// <summary>
        /// Registers an event handler with tracking.
        /// </summary>
        private void RegisterEventHandler(string eventName, Delegate handler)
        {
            if (!eventHandlers.ContainsKey(eventName))
            {
                eventHandlers[eventName] = new List<Delegate>();
            }
            eventHandlers[eventName].Add(handler);
        }

        /// <summary>
        /// Unregisters all event handlers for a control.
        /// </summary>
        public void UnregisterControlEvents(Control control)
        {
            if (control == null) return;

            var handlersToRemove = new List<string>();
            foreach (var kvp in eventHandlers)
            {
                if (kvp.Key.StartsWith($"{control.Name}_"))
                {
                    handlersToRemove.Add(kvp.Key);
                }
            }

            foreach (var handlerName in handlersToRemove)
            {
                eventHandlers.Remove(handlerName);
            }
        }

        /// <summary>
        /// Configuration changed event handler.
        /// </summary>
        private void OnConfigurationChanged(object sender, ConfigurationChangedEventArgs e)
        {
            try
            {
                // Handle configuration changes based on section
                switch (e.Section)
                {
                    case "JitterSettings":
                        HandleJitterSettingsChanged(e.PreviousConfig, e.NewConfig);
                        break;
                    case "RecoilSettings":
                        HandleRecoilSettingsChanged(e.PreviousConfig, e.NewConfig);
                        break;
                    case "HotkeySettings":
                        HandleHotkeySettingsChanged(e.PreviousConfig, e.NewConfig);
                        break;
                    case "UISettings":
                        HandleUISettingsChanged(e.PreviousConfig, e.NewConfig);
                        break;
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error handling configuration change: {ex.Message}");
            }
        }

        /// <summary>
        /// Configuration validating event handler.
        /// </summary>
        private void OnConfigurationValidating(object sender, ConfigurationValidationEventArgs e)
        {
            try
            {
                // Perform additional validation if needed
                if (e.Configuration != null)
                {
                    ValidateConfigurationConsistency(e);
                }
            }
            catch (Exception ex)
            {
                e.IsValid = false;
                e.Message = $"Validation error: {ex.Message}";
                System.Diagnostics.Debug.WriteLine($"Error during configuration validation: {ex.Message}");
            }
        }

        /// <summary>
        /// Configuration backup completed event handler.
        /// </summary>
        private void OnConfigurationBackupCompleted(object sender, ConfigurationBackupEventArgs e)
        {
            try
            {
                if (e.Success)
                {
                    System.Diagnostics.Debug.WriteLine($"Configuration backup created successfully at: {e.BackupPath}");
                }
                else
                {
                    System.Diagnostics.Debug.WriteLine($"Configuration backup failed: {e.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error handling backup completion: {ex.Message}");
            }
        }

        /// <summary>
        /// Validates configuration consistency.
        /// </summary>
        private void ValidateConfigurationConsistency(ConfigurationValidationEventArgs e)
        {
            var config = e.Configuration;

            // Validate mode consistency
            if (config.JitterSettings.AlwaysEnabled && config.RecoilSettings.AlwaysEnabled)
            {
                e.IsValid = false;
                e.Message = "Both jitter and recoil reduction cannot be in always-enabled mode";
                return;
            }

            // Validate hotkey conflicts
            if (config.HotkeySettings.MacroToggleKey == config.HotkeySettings.ModeSwitchKey)
            {
                e.IsValid = false;
                e.Message = "Macro toggle key and mode switch key cannot be the same";
                return;
            }

            // Validate backup settings
            if (config.BackupSettings.AutoBackupEnabled)
            {
                if (config.BackupSettings.BackupIntervalHours < 1)
                {
                    e.IsValid = false;
                    e.Message = "Backup interval must be at least 1 hour";
                    return;
                }
                if (config.BackupSettings.MaxBackupCount < 1)
                {
                    e.IsValid = false;
                    e.Message = "Maximum backup count must be at least 1";
                    return;
                }
            }
        }

        /// <summary>
        /// Handles changes to jitter settings.
        /// </summary>
        private void HandleJitterSettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            if (previousConfig?.JitterSettings.Strength != newConfig.JitterSettings.Strength)
            {
                System.Diagnostics.Debug.WriteLine($"Jitter strength changed from {previousConfig?.JitterSettings.Strength} to {newConfig.JitterSettings.Strength}");
            }
            if (previousConfig?.JitterSettings.IsEnabled != newConfig.JitterSettings.IsEnabled)
            {
                System.Diagnostics.Debug.WriteLine($"Jitter enabled state changed from {previousConfig?.JitterSettings.IsEnabled} to {newConfig.JitterSettings.IsEnabled}");
            }
        }

        /// <summary>
        /// Handles changes to recoil reduction settings.
        /// </summary>
        private void HandleRecoilSettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            if (previousConfig?.RecoilSettings.Strength != newConfig.RecoilSettings.Strength)
            {
                System.Diagnostics.Debug.WriteLine($"Recoil reduction strength changed from {previousConfig?.RecoilSettings.Strength} to {newConfig.RecoilSettings.Strength}");
            }
            if (previousConfig?.RecoilSettings.IsEnabled != newConfig.RecoilSettings.IsEnabled)
            {
                System.Diagnostics.Debug.WriteLine($"Recoil reduction enabled state changed from {previousConfig?.RecoilSettings.IsEnabled} to {newConfig.RecoilSettings.IsEnabled}");
            }
        }

        /// <summary>
        /// Handles changes to hotkey settings.
        /// </summary>
        private void HandleHotkeySettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            if (previousConfig?.HotkeySettings.MacroToggleKey != newConfig.HotkeySettings.MacroToggleKey)
            {
                System.Diagnostics.Debug.WriteLine($"Macro toggle key changed from {previousConfig?.HotkeySettings.MacroToggleKey} to {newConfig.HotkeySettings.MacroToggleKey}");
            }
            if (previousConfig?.HotkeySettings.ModeSwitchKey != newConfig.HotkeySettings.ModeSwitchKey)
            {
                System.Diagnostics.Debug.WriteLine($"Mode switch key changed from {previousConfig?.HotkeySettings.ModeSwitchKey} to {newConfig.HotkeySettings.ModeSwitchKey}");
            }
        }

        /// <summary>
        /// Handles changes to UI settings.
        /// </summary>
        private void HandleUISettingsChanged(AppConfiguration previousConfig, AppConfiguration newConfig)
        {
            if (previousConfig?.UISettings.MinimizeToTray != newConfig.UISettings.MinimizeToTray)
            {
                System.Diagnostics.Debug.WriteLine($"Minimize to tray setting changed from {previousConfig?.UISettings.MinimizeToTray} to {newConfig.UISettings.MinimizeToTray}");
            }
            if (previousConfig?.UISettings.ShowDebugPanel != newConfig.UISettings.ShowDebugPanel)
            {
                System.Diagnostics.Debug.WriteLine($"Debug panel visibility changed from {previousConfig?.UISettings.ShowDebugPanel} to {newConfig.UISettings.ShowDebugPanel}");
            }
        }

        // Event handler methods
        private void OnControlClick(Control control, EventArgs e)
        {
            // Handle click event
        }

        private void OnControlMouseDown(Control control, MouseEventArgs e)
        {
            // Handle mouse down
        }

        private void OnControlMouseUp(Control control, MouseEventArgs e)
        {
            // Handle mouse up
        }

        private void OnTrackBarValueChanged(TrackBar trackBar, EventArgs e)
        {
            // Handle value changed
        }

        private void OnTrackBarScroll(TrackBar trackBar, EventArgs e)
        {
            // Handle scroll
        }

        private void OnCheckBoxCheckedChanged(CheckBox checkBox, EventArgs e)
        {
            // Handle checked changed
        }

        private void OnTextBoxTextChanged(TextBox textBox, EventArgs e)
        {
            // Handle text changed
        }

        private void OnTextBoxKeyDown(TextBox textBox, KeyEventArgs e)
        {
            // Handle key down
        }

        /// <summary>
        /// Disposes of the event handler manager and unregisters all events.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Protected implementation of Dispose pattern.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (!isDisposed)
            {
                if (disposing)
                {
                    // Unregister all event handlers
                    configManager.ConfigurationChanged -= OnConfigurationChanged;
                    configManager.ConfigurationValidating -= OnConfigurationValidating;
                    configManager.ConfigurationBackupCompleted -= OnConfigurationBackupCompleted;

                    eventHandlers.Clear();
                }

                isDisposed = true;
            }
        }
    }
}
</file>

<file path="src/Configuration/SettingsValidation.cs">
using System;
using System.Windows.Forms;

namespace NotesAndTasks.Configuration
{
    public static class SettingsValidation
    {
        public static bool IsValidHotkey(Keys key)
        {
            // Validate that the key is a valid hotkey
            return key != Keys.None && 
                   key != Keys.LButton && 
                   key != Keys.RButton;
        }

        public static bool ValidateSettings(Settings settings, int minStrength, int maxStrength)
        {
            if (settings == null) return false;

            // Validate strength values
            if (settings.JitterStrength < minStrength || settings.JitterStrength > maxStrength ||
                settings.RecoilReductionStrength < minStrength || settings.RecoilReductionStrength > maxStrength)
                return false;

            // Validate hotkeys
            if (string.IsNullOrEmpty(settings.MacroToggleKey) || string.IsNullOrEmpty(settings.ModeSwitchKey))
                return false;

            try
            {
                var toggleKey = (Keys)Enum.Parse(typeof(Keys), settings.MacroToggleKey);
                var switchKey = (Keys)Enum.Parse(typeof(Keys), settings.ModeSwitchKey);

                if (!IsValidHotkey(toggleKey) || !IsValidHotkey(switchKey))
                    return false;

                if (toggleKey == switchKey)
                    return false;
            }
            catch
            {
                return false;
            }

            return true;
        }
    }
}
</file>

<file path="src/Hooks/KeyboardHook.cs">
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Windows.Forms;

namespace NotesAndTasks.Hooks
{
    /// <summary>
    /// Provides low-level keyboard hook functionality for capturing keyboard input events.
    /// </summary>
    public class KeyboardHook : IDisposable
    {
        private IntPtr hookID = IntPtr.Zero;
        private readonly NativeMethods.LowLevelHookProc hookCallback;
        private bool disposed;

        /// <summary>
        /// Gets the Windows hook identifier.
        /// </summary>
        public IntPtr HookID => hookID;

        /// <summary>
        /// Event raised when a key is pressed.
        /// </summary>
        public event EventHandler<KeyboardHookEventArgs> KeyDown;

        /// <summary>
        /// Event raised when a key is released.
        /// </summary>
        public event EventHandler<KeyboardHookEventArgs> KeyUp;

        /// <summary>
        /// Initializes a new instance of the KeyboardHook class.
        /// </summary>
        public KeyboardHook()
        {
            hookCallback = HookCallback;
        }

        /// <summary>
        /// Sets up the keyboard hook with the specified module handle.
        /// </summary>
        /// <param name="moduleHandle">The handle to the module containing the hook procedure.</param>
        public void SetHook(IntPtr moduleHandle)
        {
            if (hookID != IntPtr.Zero)
                throw new InvalidOperationException("Hook is already set");

            hookID = NativeMethods.SetWindowsHookEx(WinMessages.WH_KEYBOARD_LL, hookCallback, moduleHandle, 0);
            if (hookID == IntPtr.Zero)
                throw new InvalidOperationException("Failed to set keyboard hook");
        }

        /// <summary>
        /// Starts monitoring keyboard events.
        /// </summary>
        public void Start()
        {
            if (hookID == IntPtr.Zero)
            {
                using var curProcess = System.Diagnostics.Process.GetCurrentProcess();
                using var curModule = curProcess.MainModule;
                if (curModule == null)
                    throw new InvalidOperationException("Failed to get current module");

                SetHook(NativeMethods.GetModuleHandle(curModule.ModuleName));
            }
        }

        /// <summary>
        /// Stops monitoring keyboard events.
        /// </summary>
        public void Stop()
        {
            if (hookID != IntPtr.Zero)
            {
                NativeMethods.UnhookWindowsHookEx(hookID);
                hookID = IntPtr.Zero;
            }
        }

        private IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0)
            {
                var hookStruct = Marshal.PtrToStructure<NativeMethods.KBDLLHOOKSTRUCT>(lParam);

                if (wParam == (IntPtr)WinMessages.WM_KEYDOWN || wParam == (IntPtr)WinMessages.WM_SYSKEYDOWN)
                {
                    KeyDown?.Invoke(this, new KeyboardHookEventArgs((Keys)hookStruct.vkCode));
                }
                else if (wParam == (IntPtr)WinMessages.WM_KEYUP || wParam == (IntPtr)WinMessages.WM_SYSKEYUP)
                {
                    KeyUp?.Invoke(this, new KeyboardHookEventArgs((Keys)hookStruct.vkCode));
                }
            }

            return NativeMethods.CallNextHookEx(hookID, nCode, wParam, lParam);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the KeyboardHook.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the KeyboardHook and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    Stop();
                }
                disposed = true;
            }
        }

        /// <summary>
        /// Finalizes an instance of the KeyboardHook class.
        /// </summary>
        ~KeyboardHook()
        {
            Dispose(false);
        }
    }

    /// <summary>
    /// Event arguments for keyboard hook events.
    /// </summary>
    public class KeyboardHookEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the virtual key code of the key.
        /// </summary>
        public Keys VirtualKeyCode { get; }

        /// <summary>
        /// Initializes a new instance of the KeyboardHookEventArgs class.
        /// </summary>
        /// <param name="virtualKeyCode">The virtual key code.</param>
        public KeyboardHookEventArgs(Keys virtualKeyCode)
        {
            VirtualKeyCode = virtualKeyCode;
        }
    }
}
</file>

<file path="src/Hooks/MouseHook.cs">
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Windows.Forms;

namespace NotesAndTasks.Hooks
{
    /// <summary>
    /// Manages low-level mouse hook functionality.
    /// </summary>
    public class MouseHook : IDisposable
    {
        private IntPtr hookID = IntPtr.Zero;
        private readonly NativeMethods.LowLevelHookProc hookProc;
        private bool disposed;

        /// <summary>
        /// Gets the Windows hook identifier.
        /// </summary>
        public IntPtr HookID => hookID;

        /// <summary>
        /// Event raised when a mouse button is pressed.
        /// </summary>
        public event EventHandler<MouseHookEventArgs> MouseDown;

        /// <summary>
        /// Event raised when a mouse button is released.
        /// </summary>
        public event EventHandler<MouseHookEventArgs> MouseUp;

        /// <summary>
        /// Initializes a new instance of the MouseHook class.
        /// </summary>
        public MouseHook()
        {
            hookProc = HookCallback;
        }

        /// <summary>
        /// Sets up the mouse hook with the specified module handle.
        /// </summary>
        /// <param name="moduleHandle">The handle to the module containing the hook procedure.</param>
        public void SetHook(IntPtr moduleHandle)
        {
            if (hookID != IntPtr.Zero)
                throw new InvalidOperationException("Hook is already set");

            hookID = NativeMethods.SetWindowsHookEx(WinMessages.WH_MOUSE_LL, hookProc, moduleHandle, 0);
            if (hookID == IntPtr.Zero)
                throw new InvalidOperationException("Failed to set mouse hook");
        }

        /// <summary>
        /// Starts monitoring mouse events.
        /// </summary>
        public void Start()
        {
            if (hookID == IntPtr.Zero)
            {
                using var curProcess = Process.GetCurrentProcess();
                using var curModule = curProcess.MainModule;
                if (curModule == null)
                    throw new InvalidOperationException("Failed to get current module");

                SetHook(NativeMethods.GetModuleHandle(curModule.ModuleName));
            }
        }

        /// <summary>
        /// Stops monitoring mouse events.
        /// </summary>
        public void Stop()
        {
            if (hookID != IntPtr.Zero)
            {
                NativeMethods.UnhookWindowsHookEx(hookID);
                hookID = IntPtr.Zero;
            }
        }

        private IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0)
            {
                var mouseData = Marshal.PtrToStructure<NativeMethods.MSLLHOOKSTRUCT>(lParam);
                var button = MouseButtons.None;
                bool isDown = false;

                switch ((int)wParam)
                {
                    case WinMessages.WM_LBUTTONDOWN:
                        button = MouseButtons.Left;
                        isDown = true;
                        break;
                    case WinMessages.WM_LBUTTONUP:
                        button = MouseButtons.Left;
                        break;
                    case WinMessages.WM_RBUTTONDOWN:
                        button = MouseButtons.Right;
                        isDown = true;
                        break;
                    case WinMessages.WM_RBUTTONUP:
                        button = MouseButtons.Right;
                        break;
                    case WinMessages.WM_MBUTTONDOWN:
                        button = MouseButtons.Middle;
                        isDown = true;
                        break;
                    case WinMessages.WM_MBUTTONUP:
                        button = MouseButtons.Middle;
                        break;
                    case WinMessages.WM_XBUTTONDOWN:
                        button = (mouseData.mouseData >> 16) == WinMessages.XBUTTON1 ? 
                            MouseButtons.XButton1 : MouseButtons.XButton2;
                        isDown = true;
                        break;
                    case WinMessages.WM_XBUTTONUP:
                        button = (mouseData.mouseData >> 16) == WinMessages.XBUTTON1 ? 
                            MouseButtons.XButton1 : MouseButtons.XButton2;
                        break;
                }

                if (button != MouseButtons.None)
                {
                    var args = new MouseHookEventArgs(button, mouseData.pt.X, mouseData.pt.Y);
                    if (isDown)
                        MouseDown?.Invoke(this, args);
                    else
                        MouseUp?.Invoke(this, args);
                }
            }
            return NativeMethods.CallNextHookEx(hookID, nCode, wParam, lParam);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the MouseHook.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the MouseHook and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    Stop();
                }
                disposed = true;
            }
        }

        /// <summary>
        /// Finalizes an instance of the MouseHook class.
        /// </summary>
        ~MouseHook()
        {
            Dispose(false);
        }
    }

    /// <summary>
    /// Event arguments for mouse hook events.
    /// </summary>
    public class MouseHookEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the mouse button that triggered the event.
        /// </summary>
        public MouseButtons Button { get; }

        /// <summary>
        /// Gets the X coordinate of the mouse cursor.
        /// </summary>
        public int X { get; }

        /// <summary>
        /// Gets the Y coordinate of the mouse cursor.
        /// </summary>
        public int Y { get; }

        /// <summary>
        /// Initializes a new instance of the MouseHookEventArgs class.
        /// </summary>
        /// <param name="button">The mouse button.</param>
        /// <param name="x">The X coordinate.</param>
        /// <param name="y">The Y coordinate.</param>
        public MouseHookEventArgs(MouseButtons button, int x, int y)
        {
            Button = button;
            X = x;
            Y = y;
        }
    }
}
</file>

<file path="src/Hooks/NativeMethods.cs">
using System;
using System.Runtime.InteropServices;

namespace NotesAndTasks
{
    /// <summary>
    /// Contains P/Invoke declarations for Windows API functions and related structures.
    /// This class follows security best practices by isolating native method declarations.
    /// </summary>
    /// <remarks>
    /// This class encapsulates all external Windows API calls used by the application.
    /// It implements the recommended pattern for P/Invoke declarations by:
    /// - Using internal access to limit exposure
    /// - Properly declaring structures with correct marshaling attributes
    /// - Including security-related attributes where needed
    /// - Providing comprehensive documentation for each member
    /// </remarks>
    internal static class NativeMethods
    {
        #region Delegates
        /// <summary>
        /// Delegate for low-level keyboard and mouse hook callbacks.
        /// </summary>
        /// <param name="nCode">Hook code. If nCode is less than zero, the hook procedure must pass the message to CallNextHookEx.</param>
        /// <param name="wParam">Message identifier.</param>
        /// <param name="lParam">Pointer to a KBDLLHOOKSTRUCT or MSLLHOOKSTRUCT structure.</param>
        /// <returns>If nCode is less than zero, the hook procedure must return the value returned by CallNextHookEx.</returns>
        internal delegate IntPtr LowLevelHookProc(int nCode, IntPtr wParam, IntPtr lParam);
        #endregion

        #region Structures
        /// <summary>
        /// Represents a point in a two-dimensional coordinate system.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct POINT
        {
            /// <summary>The x-coordinate of the point.</summary>
            public int X;
            /// <summary>The y-coordinate of the point.</summary>
            public int Y;
        }

        /// <summary>
        /// Contains information about a low-level mouse input event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct MSLLHOOKSTRUCT
        {
            /// <summary>The x- and y-coordinates of the cursor, in screen coordinates.</summary>
            public POINT pt;
            /// <summary>
            /// Additional information about the mouse event.
            /// If the message is WM_XBUTTONDOWN, WM_XBUTTONUP, WM_XBUTTONDBLCLK, WM_NCXBUTTONDOWN, WM_NCXBUTTONUP,
            /// or WM_NCXBUTTONDBLCLK, the high-order word specifies which X button was pressed or released.
            /// </summary>
            public uint mouseData;
            /// <summary>The event-injected flag.</summary>
            public uint flags;
            /// <summary>The time stamp for this message.</summary>
            public uint time;
            /// <summary>Additional information associated with the message.</summary>
            public IntPtr dwExtraInfo;
        }

        /// <summary>
        /// Contains information about a low-level keyboard input event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct KBDLLHOOKSTRUCT
        {
            /// <summary>The virtual-key code of the key.</summary>
            public uint vkCode;
            /// <summary>The hardware scan code of the key.</summary>
            public uint scanCode;
            /// <summary>The extended-key flag, event-injected flag, context code, and transition-state flag.</summary>
            public uint flags;
            /// <summary>The time stamp for this message.</summary>
            public uint time;
            /// <summary>Additional information associated with the message.</summary>
            public IntPtr dwExtraInfo;
        }

        /// <summary>
        /// Contains information about simulated mouse or keyboard input events.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct INPUT
        {
            /// <summary>The type of the input event (1 for mouse input, 2 for keyboard input).</summary>
            public uint type;
            /// <summary>The mouse input data when the type is INPUT_MOUSE.</summary>
            public MOUSEINPUT mi;
        }

        /// <summary>
        /// Contains information about a simulated mouse event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        internal struct MOUSEINPUT
        {
            /// <summary>The absolute position of the mouse, or the amount of motion since the last mouse event.</summary>
            public int dx;
            /// <summary>The absolute position of the mouse, or the amount of motion since the last mouse event.</summary>
            public int dy;
            /// <summary>If the mouse wheel is moved, indicates the amount of wheel movement.</summary>
            public uint mouseData;
            /// <summary>A set of bit flags that specify various aspects of mouse motion and button clicks.</summary>
            public uint dwFlags;
            /// <summary>The time stamp for the event, in milliseconds.</summary>
            public uint time;
            /// <summary>Additional information associated with the event.</summary>
            public IntPtr dwExtraInfo;
        }
        #endregion

        #region User32.dll Functions
        /// <summary>
        /// Sets a Windows hook that monitors low-level keyboard or mouse input events.
        /// </summary>
        /// <param name="idHook">The type of hook to be installed (WH_KEYBOARD_LL or WH_MOUSE_LL).</param>
        /// <param name="lpfn">A pointer to the hook procedure.</param>
        /// <param name="hMod">A handle to the DLL containing the hook procedure.</param>
        /// <param name="dwThreadId">The identifier of the thread with which the hook procedure is to be associated.</param>
        /// <returns>If successful, returns a handle to the hook procedure. If unsuccessful, returns IntPtr.Zero.</returns>
        /// <remarks>
        /// The hook procedure should process the message and return the value returned by CallNextHookEx.
        /// For low-level hooks, the hook procedure must be in the same desktop as the running application.
        /// </remarks>
        [DllImport("user32.dll", SetLastError = true)]
        internal static extern IntPtr SetWindowsHookEx(
            int idHook,
            LowLevelHookProc lpfn,
            IntPtr hMod,
            uint dwThreadId);

        /// <summary>
        /// Removes a previously set Windows hook.
        /// </summary>
        /// <param name="hhk">A handle to the hook to be removed. This parameter is obtained by a previous call to SetWindowsHookEx.</param>
        /// <returns>If successful, returns true. If unsuccessful, returns false.</returns>
        /// <remarks>
        /// The hook procedure must be in the state to be removed, that is, it must not be in the middle of processing a message.
        /// This function must be called on the same thread that installed the hook.
        /// </remarks>
        [DllImport("user32.dll", SetLastError = true)]
        internal static extern bool UnhookWindowsHookEx(IntPtr hhk);

        /// <summary>
        /// Passes the hook information to the next hook procedure in the current hook chain.
        /// </summary>
        /// <param name="hhk">This parameter is ignored.</param>
        /// <param name="nCode">The hook code passed to the current hook procedure.</param>
        /// <param name="wParam">The wParam value passed to the current hook procedure.</param>
        /// <param name="lParam">The lParam value passed to the current hook procedure.</param>
        /// <returns>The value returned by the next hook procedure in the chain.</returns>
        /// <remarks>
        /// This function must be called by the hook procedure if it is not processing the message.
        /// The hook procedure can modify the values pointed to by wParam and lParam before passing them to CallNextHookEx.
        /// </remarks>
        [DllImport("user32.dll")]
        internal static extern IntPtr CallNextHookEx(
            IntPtr hhk,
            int nCode,
            IntPtr wParam,
            IntPtr lParam);

        /// <summary>
        /// Retrieves the current cursor position.
        /// </summary>
        /// <param name="lpPoint">A pointer to a POINT structure that receives the screen coordinates of the cursor.</param>
        /// <returns>Returns true if successful, false otherwise.</returns>
        /// <remarks>
        /// The cursor position is always specified in screen coordinates and is not affected by the mapping mode of the window that contains the cursor.
        /// </remarks>
        [DllImport("user32.dll")]
        internal static extern bool GetCursorPos(out POINT lpPoint);

        /// <summary>
        /// Synthesizes mouse motion and button clicks.
        /// </summary>
        /// <param name="dwFlags">A set of bit flags that specify various aspects of mouse motion and button clicking.</param>
        /// <param name="dx">The mouse's absolute position along the x-axis or its amount of motion since the last mouse event.</param>
        /// <param name="dy">The mouse's absolute position along the y-axis or its amount of motion since the last mouse event.</param>
        /// <param name="dwData">If dwFlags contains MOUSEEVENTF_WHEEL, then dwData specifies the amount of wheel movement.</param>
        /// <param name="dwExtraInfo">Additional information associated with the mouse event.</param>
        /// <remarks>
        /// The mouse_event function has been superseded by SendInput. Use SendInput instead.
        /// </remarks>
        [DllImport("user32.dll")]
        internal static extern void mouse_event(
            uint dwFlags,
            int dx,
            int dy,
            uint dwData,
            int dwExtraInfo);

        /// <summary>
        /// Synthesizes keystrokes, mouse motions, and button clicks.
        /// </summary>
        /// <param name="nInputs">The number of structures in the pInputs array.</param>
        /// <param name="pInputs">An array of INPUT structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</param>
        /// <param name="cbSize">The size, in bytes, of an INPUT structure.</param>
        /// <returns>The function returns the number of events that it successfully inserted into the keyboard or mouse input stream.</returns>
        /// <remarks>
        /// This function is the preferred method for synthesizing input, as it supports more features and is more efficient than mouse_event and keybd_event.
        /// </remarks>
        [DllImport("user32.dll", SetLastError = true)]
        internal static extern uint SendInput(
            uint nInputs,
            ref INPUT pInputs,
            int cbSize);
        #endregion

        #region Kernel32.dll Functions
        /// <summary>
        /// Retrieves a module handle for the specified module.
        /// </summary>
        /// <param name="lpModuleName">The name of the loaded module (either a .dll or .exe file).</param>
        /// <returns>If successful, returns a handle to the specified module. If unsuccessful, returns IntPtr.Zero.</returns>
        /// <remarks>
        /// If lpModuleName is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).
        /// The returned handle is not global or inheritable. It cannot be duplicated or used by another process.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        internal static extern IntPtr GetModuleHandle(string lpModuleName);
        #endregion
    }
}
</file>

<file path="src/Hooks/WinMessages.cs">
using System;

namespace NotesAndTasks
{
    /// <summary>
    /// Contains Windows message constants used for low-level hooks and input handling.
    /// </summary>
    /// <remarks>
    /// This class provides a centralized location for all Windows message constants used in the application.
    /// The constants are organized into logical groups:
    /// - Hook-related constants (WH_*)
    /// - Keyboard message constants (WM_KEY*)
    /// - Mouse button message constants (WM_*BUTTON*)
    /// - Mouse button identifiers (XBUTTON*)
    /// - Mouse event flags (MOUSEEVENTF_*)
    /// - Input type identifiers (INPUT_*)
    /// - Base values for calculations
    /// </remarks>
    public static class WinMessages
    {
        /// <summary>
        /// Windows hook constant for low-level keyboard events.
        /// Used with SetWindowsHookEx to install a hook procedure that monitors low-level keyboard input events.
        /// </summary>
        public const int WH_KEYBOARD_LL = 13;

        /// <summary>
        /// Windows hook constant for low-level mouse events.
        /// Used with SetWindowsHookEx to install a hook procedure that monitors low-level mouse input events.
        /// </summary>
        public const int WH_MOUSE_LL = 14;

        /// <summary>
        /// Posted when a nonsystem key is pressed.
        /// A nonsystem key is a key that is pressed when the ALT key is not pressed.
        /// </summary>
        public const int WM_KEYDOWN = 0x0100;

        /// <summary>
        /// Posted when a nonsystem key is released.
        /// </summary>
        public const int WM_KEYUP = 0x0101;

        /// <summary>
        /// Posted when a system key is pressed (such as ALT).
        /// </summary>
        public const int WM_SYSKEYDOWN = 0x0104;

        /// <summary>
        /// Posted when a system key is released.
        /// </summary>
        public const int WM_SYSKEYUP = 0x0105;

        /// <summary>
        /// Posted when the left mouse button is pressed.
        /// </summary>
        public const int WM_LBUTTONDOWN = 0x0201;

        /// <summary>
        /// Posted when the left mouse button is released.
        /// </summary>
        public const int WM_LBUTTONUP = 0x0202;

        /// <summary>
        /// Posted when the right mouse button is pressed.
        /// </summary>
        public const int WM_RBUTTONDOWN = 0x0204;

        /// <summary>
        /// Posted when the right mouse button is released.
        /// </summary>
        public const int WM_RBUTTONUP = 0x0205;

        /// <summary>
        /// Posted when the middle mouse button is pressed.
        /// </summary>
        public const int WM_MBUTTONDOWN = 0x0207;

        /// <summary>
        /// Posted when the middle mouse button is released.
        /// </summary>
        public const int WM_MBUTTONUP = 0x0208;

        /// <summary>
        /// Posted when an X button is pressed.
        /// The specific button (XBUTTON1 or XBUTTON2) is indicated in the high-order word of the mouseData field.
        /// </summary>
        public const int WM_XBUTTONDOWN = 0x020B;

        /// <summary>
        /// Posted when an X button is released.
        /// The specific button (XBUTTON1 or XBUTTON2) is indicated in the high-order word of the mouseData field.
        /// </summary>
        public const int WM_XBUTTONUP = 0x020C;

        /// <summary>
        /// First X button identifier (typically the fourth mouse button).
        /// Used to identify which X button was pressed in WM_XBUTTONDOWN events.
        /// </summary>
        public const int XBUTTON1 = 0x0001;

        /// <summary>
        /// Second X button identifier (typically the fifth mouse button).
        /// Used to identify which X button was pressed in WM_XBUTTONDOWN events.
        /// </summary>
        public const int XBUTTON2 = 0x0002;

        /// <summary>
        /// Mouse event flag indicating relative mouse movement.
        /// When used with SendInput, specifies that dx and dy contain relative movement data.
        /// </summary>
        public const uint MOUSEEVENTF_MOVE = 0x0001;

        /// <summary>
        /// Input type constant indicating mouse input.
        /// Used with the INPUT structure to specify that the input event is mouse-related.
        /// </summary>
        public const uint INPUT_MOUSE = 0;

        /// <summary>
        /// Base strength value for recoil calculations.
        /// Used as a multiplier in basic recoil reduction calculations.
        /// </summary>
        public const double BASE_RECOIL_STRENGTH = 0.75;

        /// <summary>
        /// Secondary base strength value for enhanced recoil calculations.
        /// Used as a multiplier in advanced recoil reduction calculations.
        /// </summary>
        public const double BASE_RECOIL_STRENGTH_2 = 2.0;

        /// <summary>
        /// Speed multiplier for the lowest level of movement adjustment.
        /// Applied to movement calculations when minimal adjustment is needed.
        /// </summary>
        public const double LOW_LEVEL_1_SPEED = 0.25;

        /// <summary>
        /// Speed multiplier for the medium-low level of movement adjustment.
        /// Applied to movement calculations when moderate adjustment is needed.
        /// </summary>
        public const double LOW_LEVEL_2_SPEED = 0.5;

        /// <summary>
        /// Speed multiplier for the medium level of movement adjustment.
        /// Applied to movement calculations when significant adjustment is needed.
        /// </summary>
        public const double LOW_LEVEL_3_SPEED = 0.75;
    }
}
</file>

<file path="src/Utilities/InputSimulator.cs">
using System;
using System.Runtime.InteropServices;
using NotesAndTasks.Hooks;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Provides functionality for simulating mouse input and movement.
    /// This class encapsulates the Windows SendInput API for mouse control.
    /// </summary>
    public class InputSimulator : IDisposable
    {
        private bool disposed = false;
        private readonly object lockObject = new object();

        [StructLayout(LayoutKind.Sequential)]
        private struct MOUSEINPUT
        {
            public int dx;
            public int dy;
            public uint mouseData;
            public uint dwFlags;
            public uint time;
            public IntPtr dwExtraInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct INPUT
        {
            public uint type;
            public MOUSEINPUT mi;
        }

        private const int INPUT_MOUSE = 0;
        private const int MOUSEEVENTF_MOVE = 0x0001;

        [DllImport("user32.dll", SetLastError = true)]
        private static extern uint SendInput(uint nInputs, ref INPUT pInputs, int cbSize);

        /// <summary>
        /// Simulates mouse movement by the specified delta values.
        /// </summary>
        /// <param name="deltaX">The change in X coordinate.</param>
        /// <param name="deltaY">The change in Y coordinate.</param>
        /// <returns>True if the input was successfully simulated, false otherwise.</returns>
        public bool SimulateMouseMovement(int deltaX, int deltaY)
        {
            if (disposed)
            {
                throw new ObjectDisposedException(nameof(InputSimulator));
            }

            try
            {
                lock (lockObject)
                {
                    // Validate movement values
                    if (Math.Abs(deltaX) > 100 || Math.Abs(deltaY) > 100)
                    {
                        return false;
                    }

                    var input = new INPUT
                    {
                        type = INPUT_MOUSE,
                        mi = new MOUSEINPUT
                        {
                            dx = deltaX,
                            dy = deltaY,
                            mouseData = 0,
                            time = 0,
                            dwExtraInfo = IntPtr.Zero,
                            dwFlags = MOUSEEVENTF_MOVE
                        }
                    };

                    return SendInput(1, ref input, Marshal.SizeOf(input)) == 1;
                }
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Simulates mouse movement with jitter pattern.
        /// </summary>
        /// <param name="pattern">The jitter pattern coordinates (dx, dy).</param>
        /// <param name="strength">The strength multiplier for the pattern (1-20).</param>
        /// <returns>True if the input was successfully simulated, false otherwise.</returns>
        public bool SimulateJitterMovement((int dx, int dy) pattern, int strength)
        {
            if (disposed)
            {
                throw new ObjectDisposedException(nameof(InputSimulator));
            }

            if (strength < 1 || strength > 20)
            {
                throw new ArgumentOutOfRangeException(nameof(strength), "Strength must be between 1 and 20.");
            }

            int scaledDx = (int)(pattern.dx * strength / 7.0);
            int scaledDy = (int)(pattern.dy * strength / 7.0);

            return SimulateMouseMovement(scaledDx, scaledDy);
        }

        /// <summary>
        /// Simulates mouse movement for recoil reduction.
        /// </summary>
        /// <param name="strength">The strength of the recoil reduction (1-20).</param>
        /// <returns>True if the input was successfully simulated, false otherwise.</returns>
        public bool SimulateRecoilReduction(int strength)
        {
            if (disposed)
            {
                throw new ObjectDisposedException(nameof(InputSimulator));
            }

            if (strength < 1 || strength > 20)
            {
                throw new ArgumentOutOfRangeException(nameof(strength), "Strength must be between 1 and 20.");
            }

            int verticalMovement;
            if (strength <= 6)
            {
                if (strength == 1)
                {
                    verticalMovement = Math.Max(1, (int)Math.Round(0.75 * 0.3));
                }
                else
                {
                    double logBase = 1.5;
                    verticalMovement = Math.Max(1, (int)Math.Round(0.75 * Math.Log(strength + 1, logBase)));
                }
            }
            else if (strength <= 16)
            {
                verticalMovement = Math.Max(1, (int)Math.Round(0.75 * strength * 1.2));
            }
            else
            {
                double baseValue = 0.75 * 20.0;
                double scalingFactor = 1.3;
                double exponentialBoost = 1.2;
                verticalMovement = Math.Max(1, (int)Math.Round(
                    baseValue *
                    Math.Pow(scalingFactor, strength - 13) *
                    Math.Pow(exponentialBoost, (strength - 13) / 2)
                ));
            }

            return SimulateMouseMovement(0, verticalMovement);
        }

        /// <summary>
        /// Moves the mouse to the specified coordinates.
        /// </summary>
        /// <param name="dx">The change in X coordinate.</param>
        /// <param name="dy">The change in Y coordinate.</param>
        public void MoveMouse(int dx, int dy)
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(InputSimulator));

            if (Math.Abs(dx) > 100 || Math.Abs(dy) > 100)
            {
                throw new ArgumentOutOfRangeException("Movement values exceeded safe limits");
            }

            var input = new INPUT
            {
                type = INPUT_MOUSE,
                mi = new MOUSEINPUT
                {
                    dx = dx,
                    dy = dy,
                    mouseData = 0,
                    dwFlags = MOUSEEVENTF_MOVE,
                    time = 0,
                    dwExtraInfo = IntPtr.Zero
                }
            };

            SendInput(1, ref input, Marshal.SizeOf(input));
        }

        /// <summary>
        /// Disposes of resources used by the InputSimulator.
        /// </summary>
        public void Dispose()
        {
            if (!disposed)
            {
                disposed = true;
                GC.SuppressFinalize(this);
            }
        }
    }
}
</file>

<file path="src/Utilities/JitterManager.cs">
using System;
using System.Windows.Forms;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Manages jitter pattern generation and application for mouse movement.
    /// This class handles the timing and pattern of jitter movements.
    /// </summary>
    public class JitterManager : IDisposable
    {
        private readonly InputSimulator inputSimulator;
        private bool disposed = false;
        private int strength = 3;
        private bool isActive = false;
        private System.Threading.Timer timer;
        private int currentStep = 0;

        private readonly (int dx, int dy)[] jitterPattern = new[]
        {
            (7, 7), (-7, -7), (0, 7), (7, 7), (-7, -7),
            (0, 6), (7, 7), (-7, -7), (0, 7), (7, 7),
            (-7, -7), (0, 6), (7, 7), (-7, -7), (0, 6),
            (7, 7), (-7, -7), (0, 7), (7, 7), (-7, -7),
            (0, 6), (7, 7), (-7, -7), (0, 6)
        };

        /// <summary>
        /// Event raised when the jitter state changes.
        /// </summary>
        public event EventHandler<bool> StateChanged;

        /// <summary>
        /// Initializes a new instance of the JitterManager class.
        /// </summary>
        /// <param name="inputSimulator">The input simulator to use for mouse movement.</param>
        public JitterManager(InputSimulator inputSimulator)
        {
            this.inputSimulator = inputSimulator ?? throw new ArgumentNullException(nameof(inputSimulator));
            timer = new System.Threading.Timer(OnTimer, null, System.Threading.Timeout.Infinite, 10);
        }

        /// <summary>
        /// Gets or sets the current jitter strength (1-20).
        /// </summary>
        public int Strength
        {
            get => strength;
            private set
            {
                if (value < 1 || value > 20)
                    throw new ArgumentOutOfRangeException(nameof(value), "Strength must be between 1 and 20.");
                strength = value;
            }
        }

        /// <summary>
        /// Sets the jitter strength value (1-20).
        /// </summary>
        /// <param name="value">The strength value to set.</param>
        public void SetStrength(int value)
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(JitterManager));
            Strength = value;
        }

        /// <summary>
        /// Gets whether the jitter effect is currently active.
        /// </summary>
        public bool IsActive => isActive;

        /// <summary>
        /// Starts the jitter effect.
        /// </summary>
        public void Start()
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(JitterManager));

            if (!isActive)
            {
                isActive = true;
                timer.Change(0, 10);
                StateChanged?.Invoke(this, true);
            }
        }

        /// <summary>
        /// Stops the jitter effect.
        /// </summary>
        public void Stop()
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(JitterManager));

            if (isActive)
            {
                isActive = false;
                timer.Change(System.Threading.Timeout.Infinite, 10);
                StateChanged?.Invoke(this, false);
            }
        }

        /// <summary>
        /// Timer callback that applies the jitter pattern.
        /// </summary>
        private void OnTimer(object state)
        {
            if (!isActive) return;

            try
            {
                var pattern = jitterPattern[currentStep];
                int dx = (int)(pattern.dx * strength / 7);
                int dy = (int)(pattern.dy * strength / 7);

                inputSimulator.MoveMouse(dx, dy);
                currentStep = (currentStep + 1) % jitterPattern.Length;
            }
            catch (Exception)
            {
                Stop();
            }
        }

        /// <summary>
        /// Disposes of resources used by the JitterManager.
        /// </summary>
        public void Dispose()
        {
            if (!disposed)
            {
                Stop();
                timer.Dispose();
                disposed = true;
                GC.SuppressFinalize(this);
            }
        }
    }
}
</file>

<file path="src/Utilities/MacroManager.cs">
using System;
using System.Windows.Forms;
using NotesAndTasks.Hooks;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Coordinates between hook and feature managers to provide macro functionality.
    /// This class handles the overall macro state and mode switching.
    /// </summary>
    public class MacroManager : IDisposable
    {
        #region Events
        public event EventHandler<bool> MacroStateChanged;
        public event EventHandler<bool> ModeChanged;
        public event EventHandler JitterStarted;
        public event EventHandler JitterStopped;
        public event EventHandler RecoilReductionStarted;
        public event EventHandler RecoilReductionStopped;
        #endregion

        #region Fields
        private readonly InputSimulator inputSimulator;
        private readonly JitterManager jitterManager;
        private readonly RecoilReductionManager recoilManager;
        private readonly object lockObject = new object();
        private bool disposed = false;
        private bool leftButtonDown = false;
        private bool rightButtonDown = false;
        private bool isActive = false;
        private int jitterStrength = 3;
        private int recoilReductionStrength = 1;
        #endregion

        #region Properties
        public bool IsEnabled { get; private set; }
        public bool IsJitterEnabled { get; private set; }
        public bool IsAlwaysJitterMode { get; private set; }
        public bool IsAlwaysRecoilReductionMode { get; private set; }
        #endregion

        #region Constructor
        public MacroManager()
        {
            inputSimulator = new InputSimulator();
            jitterManager = new JitterManager(inputSimulator);
            recoilManager = new RecoilReductionManager(inputSimulator);

            // Subscribe to state change events
            jitterManager.StateChanged += (s, active) => CheckMacroState();
            recoilManager.StateChanged += (s, active) => CheckMacroState();
        }
        #endregion

        #region Public Methods
        public void HandleMouseButton(MouseButtons button, bool isDown)
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(MacroManager));

            lock (lockObject)
            {
                if (button == MouseButtons.Left)
                {
                    leftButtonDown = isDown;
                }
                else if (button == MouseButtons.Right)
                {
                    rightButtonDown = isDown;
                }

                CheckMacroState();
            }
        }

        public void ToggleMacro()
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(MacroManager));

            lock (lockObject)
            {
                IsEnabled = !IsEnabled;
                MacroStateChanged?.Invoke(this, IsEnabled);
                CheckMacroState();
            }
        }

        public void SwitchMode()
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(MacroManager));

            lock (lockObject)
            {
                if (!IsAlwaysJitterMode && !IsAlwaysRecoilReductionMode)
                {
                    IsJitterEnabled = !IsJitterEnabled;
                    ModeChanged?.Invoke(this, IsJitterEnabled);
                    CheckMacroState();
                }
            }
        }

        public void SetJitterStrength(int strength)
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(MacroManager));

            if (strength >= 1 && strength <= 20)
            {
                jitterStrength = strength;
                jitterManager.SetStrength(strength);
            }
        }

        public void SetRecoilReductionStrength(int strength)
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(MacroManager));

            if (strength >= 1 && strength <= 20)
            {
                recoilReductionStrength = strength;
                recoilManager.SetStrength(strength);
            }
        }

        public void SetAlwaysJitterMode(bool enabled)
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(MacroManager));

            lock (lockObject)
            {
                if (enabled && IsAlwaysRecoilReductionMode)
                {
                    IsAlwaysRecoilReductionMode = false;
                }
                IsAlwaysJitterMode = enabled;
                if (enabled)
                {
                    IsJitterEnabled = true;
                }
                CheckMacroState();
                ModeChanged?.Invoke(this, IsJitterEnabled);
            }
        }

        public void SetAlwaysRecoilReductionMode(bool enabled)
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(MacroManager));

            lock (lockObject)
            {
                if (enabled && IsAlwaysJitterMode)
                {
                    IsAlwaysJitterMode = false;
                }
                IsAlwaysRecoilReductionMode = enabled;
                if (enabled)
                {
                    IsJitterEnabled = false;
                }
                CheckMacroState();
                ModeChanged?.Invoke(this, IsJitterEnabled);
            }
        }
        #endregion

        #region Private Methods
        private void CheckMacroState()
        {
            bool shouldActivate = IsEnabled && leftButtonDown && rightButtonDown;

            if (shouldActivate && !isActive)
            {
                isActive = true;
                if (IsAlwaysJitterMode || (!IsAlwaysRecoilReductionMode && IsJitterEnabled))
                {
                    JitterStarted?.Invoke(this, EventArgs.Empty);
                    jitterManager.Start();
                }
                else
                {
                    RecoilReductionStarted?.Invoke(this, EventArgs.Empty);
                    recoilManager.Start();
                }
            }
            else if (!shouldActivate && isActive)
            {
                isActive = false;
                if (IsAlwaysJitterMode || (!IsAlwaysRecoilReductionMode && IsJitterEnabled))
                {
                    JitterStopped?.Invoke(this, EventArgs.Empty);
                    jitterManager.Stop();
                }
                else
                {
                    RecoilReductionStopped?.Invoke(this, EventArgs.Empty);
                    recoilManager.Stop();
                }
            }
        }
        #endregion

        #region IDisposable Implementation
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    jitterManager.Dispose();
                    recoilManager.Dispose();
                    inputSimulator.Dispose();
                }
                disposed = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}
</file>

<file path="src/Utilities/RecoilReductionManager.cs">
using System;
using System.Windows.Forms;

namespace NotesAndTasks.Utilities
{
    /// <summary>
    /// Manages recoil reduction functionality for mouse movement.
    /// This class handles the timing and strength of vertical compensation.
    /// </summary>
    public class RecoilReductionManager : IDisposable
    {
        private readonly InputSimulator inputSimulator;
        private bool disposed = false;
        private int strength = 1;
        private bool isActive = false;
        private System.Threading.Timer timer;

        private const double BASE_RECOIL_STRENGTH = 0.75;
        private const double BASE_RECOIL_STRENGTH_2 = 2.0;
        private const double LOW_LEVEL_1_SPEED = 0.25;
        private const double LOW_LEVEL_2_SPEED = 0.5;
        private const double LOW_LEVEL_3_SPEED = 0.75;

        /// <summary>
        /// Gets or sets the current recoil reduction strength (1-20).
        /// </summary>
        public int Strength
        {
            get => strength;
            private set
            {
                if (value < 1 || value > 20)
                    throw new ArgumentOutOfRangeException(nameof(value), "Strength must be between 1 and 20.");
                strength = value;
            }
        }

        /// <summary>
        /// Sets the recoil reduction strength value (1-20).
        /// </summary>
        /// <param name="value">The strength value to set.</param>
        public void SetStrength(int value)
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(RecoilReductionManager));
            Strength = value;
        }

        /// <summary>
        /// Gets whether the recoil reduction is currently active.
        /// </summary>
        public bool IsActive => isActive;

        /// <summary>
        /// Event raised when the recoil reduction state changes.
        /// </summary>
        public event EventHandler<bool> StateChanged;

        /// <summary>
        /// Initializes a new instance of the RecoilReductionManager class.
        /// </summary>
        /// <param name="inputSimulator">The input simulator to use for mouse movement.</param>
        public RecoilReductionManager(InputSimulator inputSimulator)
        {
            this.inputSimulator = inputSimulator ?? throw new ArgumentNullException(nameof(inputSimulator));
            timer = new System.Threading.Timer(OnTimer, null, System.Threading.Timeout.Infinite, 10);
        }

        /// <summary>
        /// Starts the recoil reduction effect.
        /// </summary>
        public void Start()
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(RecoilReductionManager));

            if (!isActive)
            {
                isActive = true;
                timer.Change(0, 10);
                StateChanged?.Invoke(this, true);
            }
        }

        /// <summary>
        /// Stops the recoil reduction effect.
        /// </summary>
        public void Stop()
        {
            if (disposed)
                throw new ObjectDisposedException(nameof(RecoilReductionManager));

            if (isActive)
            {
                isActive = false;
                timer.Change(System.Threading.Timeout.Infinite, 10);
                StateChanged?.Invoke(this, false);
            }
        }

        /// <summary>
        /// Timer callback that applies the recoil reduction movement.
        /// </summary>
        private void OnTimer(object state)
        {
            if (!isActive) return;

            try
            {
                int dy;
                if (strength <= 6)
                {
                    if (strength == 1)
                    {
                        dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * 0.3));
                    }
                    else
                    {
                        double logBase = 1.5;
                        dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * Math.Log(strength + 1, logBase)));
                    }
                }
                else if (strength <= 16)
                {
                    dy = Math.Max(1, (int)Math.Round(BASE_RECOIL_STRENGTH * strength * 1.2));
                }
                else
                {
                    double baseValue = BASE_RECOIL_STRENGTH * 20.0;
                    double scalingFactor = 1.3;
                    double exponentialBoost = 1.2;
                    dy = Math.Max(1, (int)Math.Round(
                        baseValue *
                        Math.Pow(scalingFactor, strength - 13) *
                        Math.Pow(exponentialBoost, (strength - 13) / 2)
                    ));
                }

                inputSimulator.MoveMouse(0, dy);
            }
            catch (Exception)
            {
                Stop();
            }
        }

        /// <summary>
        /// Disposes of resources used by the RecoilReductionManager.
        /// </summary>
        public void Dispose()
        {
            if (!disposed)
            {
                Stop();
                timer.Dispose();
                disposed = true;
                GC.SuppressFinalize(this);
            }
        }
    }
}
</file>

<file path="build.bat">
@echo off
:: Check for admin privileges
net session >nul 2>&1
if %errorLevel% == 0 (
    goto :admin
) else (
    echo Requesting administrative privileges...
    goto :UACPrompt
)

:UACPrompt
echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
echo UAC.ShellExecute "%~s0", "", "", "runas", 1 >> "%temp%\getadmin.vbs"
"%temp%\getadmin.vbs"
del "%temp%\getadmin.vbs"
exit /B

:admin
cd /d "%~dp0"

echo Starting Mouse Macro build process...
echo.

echo === Cleaning solution ===
dotnet clean
if errorlevel 1 goto error

echo === Removing build directories ===
if exist "bin" rmdir /s /q "bin"
if exist "obj" rmdir /s /q "obj"
if errorlevel 1 goto error

echo === Restoring packages ===
dotnet restore
if errorlevel 1 goto error

echo === Building Debug configuration ===
dotnet build -c Debug
if errorlevel 1 goto error

echo === Building Release configuration ===
dotnet build -c Release
if errorlevel 1 goto error

echo.
echo === Build Complete! ===
echo.
echo Debug build: %~dp0bin\Debug\net6.0-windows\NotesAndTasks.exe
echo Release build: %~dp0bin\Release\net6.0-windows\NotesAndTasks.exe
echo.
goto end

:error
echo.
echo Build failed! See error message above.
pause
exit /b 1

:end
echo Press any key to exit...
pause >nul
</file>

<file path="src/Configuration/Settings.cs">
using System.Windows.Forms;
using NotesAndTasks.Utilities;

namespace NotesAndTasks.Configuration
{
    /// <summary>
    /// Represents the application settings including hotkeys, strengths, and modes.
    /// </summary>
    public class Settings
    {
        #region Properties
        /// <summary>
        /// Gets or sets the jitter strength value (1-20).
        /// </summary>
        public int JitterStrength { get; set; } = 3;

        /// <summary>
        /// Gets or sets the recoil reduction strength value (1-20).
        /// </summary>
        public int RecoilReductionStrength { get; set; } = 1;

        /// <summary>
        /// Gets or sets whether jitter mode is always enabled.
        /// </summary>
        public bool AlwaysJitterMode { get; set; } = false;

        /// <summary>
        /// Gets or sets whether recoil reduction mode is always enabled.
        /// </summary>
        public bool AlwaysRecoilReductionMode { get; set; } = false;

        /// <summary>
        /// Gets or sets whether jitter is enabled.
        /// </summary>
        public bool JitterEnabled { get; set; } = false;

        /// <summary>
        /// Gets or sets whether recoil reduction is enabled.
        /// </summary>
        public bool RecoilReductionEnabled { get; set; } = false;

        /// <summary>
        /// Gets or sets whether to minimize to system tray when closing.
        /// </summary>
        public bool MinimizeToTray { get; set; } = true;

        /// <summary>
        /// Gets or sets the macro toggle key.
        /// </summary>
        public Keys MacroKey { get; set; } = Keys.Capital;

        /// <summary>
        /// Gets or sets the mode switch key.
        /// </summary>
        public Keys SwitchKey { get; set; } = Keys.Q;

        /// <summary>
        /// Gets or sets the toggle type for macro activation.
        /// </summary>
        public ToggleType ToggleType { get; set; } = ToggleType.Keyboard;
        #endregion

        #region Methods
        /// <summary>
        /// Creates a new instance of Settings with default values.
        /// </summary>
        public static Settings CreateDefault()
        {
            return new Settings();
        }

        /// <summary>
        /// Resets all settings to their default values.
        /// </summary>
        public void ResetToDefaults()
        {
            JitterStrength = 3;
            RecoilReductionStrength = 1;
            AlwaysJitterMode = false;
            AlwaysRecoilReductionMode = false;
            JitterEnabled = false;
            RecoilReductionEnabled = false;
            MinimizeToTray = false;
            MacroKey = Keys.Capital;
            SwitchKey = Keys.Q;
            ToggleType = ToggleType.Keyboard;
        }
        #endregion
    }
}
</file>

<file path="src/UI/MacroForm.Designer.cs">
using System;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;
using NotesAndTasks.Hooks;

namespace NotesAndTasks
{
    partial class MacroForm
    {
        /// <summary>
        ///  Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        ///  Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (components != null)
                {
                    components.Dispose();
                }

                // Dispose hooks
                if (keyboardHook != null)
                {
                    keyboardHook.Stop();
                    keyboardHook.Dispose();
                }

                if (mouseHook != null)
                {
                    mouseHook.Stop();
                    mouseHook.Dispose();
                }

                // Dispose timer
                if (jitterTimer != null)
                {
                    jitterTimer.Dispose();
                }

                if (notifyIcon != null)
                {
                    notifyIcon.Visible = false;
                    notifyIcon.Dispose();
                }

                if (toolTip != null)
                {
                    toolTip.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        ///  Required method for Designer support - do not modify
        ///  the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
            mainPanel = new Panel();
            debugPanel = new Panel();
            debugLabel = new TextBox();
            btnToggleDebug = new ModernButton();
            strengthPanel1 = new Panel();
            lblRecoilReductionStrengthValue = new Label();
            lblRecoilReductionStrengthPrefix = new Label();
            trackBarRecoilReduction = new ModernTrackBar();
            lblRecoilReductionActive = new Label();
            strengthPanel2 = new Panel();
            lblJitterStrengthValue = new Label();
            lblJitterStrengthPrefix = new Label();
            trackBarJitter = new ModernTrackBar();
            lblJitterActive = new Label();
            settingsPanel = new Panel();
            lblCurrentKeyValue = new Label();
            lblCurrentKeyPrefix = new Label();
            btnSetKey = new ModernButton();
            chkMinimizeToTray = new CheckBox();
            lblMacroSwitchKeyValue = new Label();
            btnSetMacroSwitch = new ModernButton();
            lblMacroSwitchKeyPrefix = new Label();
            chkAlwaysJitter = new CheckBox();
            chkAlwaysRecoilReduction = new CheckBox();
            notifyIcon = new NotifyIcon(components);
            trayContextMenu = new ContextMenuStrip(components);
            showWindowMenuItem = new ToolStripMenuItem();
            exitMenuItem = new ToolStripMenuItem();

            mainPanel.SuspendLayout();
            debugPanel.SuspendLayout();
            strengthPanel1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarRecoilReduction).BeginInit();
            strengthPanel2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarJitter).BeginInit();
            settingsPanel.SuspendLayout();
            trayContextMenu.SuspendLayout();
            SuspendLayout();
            // 
            // mainPanel
            // 
            mainPanel.Dock = DockStyle.Fill;
            mainPanel.BackColor = Color.FromArgb(16, 2, 31);
            mainPanel.Controls.Add(debugPanel);
            mainPanel.Controls.Add(btnToggleDebug);
            mainPanel.Controls.Add(strengthPanel1);
            mainPanel.Controls.Add(strengthPanel2);
            mainPanel.Controls.Add(settingsPanel);
            mainPanel.Controls.Add(chkAlwaysJitter);
            mainPanel.Controls.Add(chkAlwaysRecoilReduction);
            mainPanel.Location = new Point(0, 0);
            mainPanel.Margin = new Padding(3, 2, 3, 2);
            mainPanel.Name = "mainPanel";
            mainPanel.Padding = new Padding(14, 12, 14, 12);
            mainPanel.Size = new Size(477, 676);
            mainPanel.TabIndex = 0;
            // 
            // debugPanel
            // 
            debugPanel.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            debugPanel.AutoScroll = true;
            debugPanel.BackColor = Color.FromArgb(214, 37, 106);
            debugPanel.BorderStyle = BorderStyle.FixedSingle;
            debugPanel.Controls.Add(debugLabel);
            debugPanel.Location = new Point(20, 541);
            debugPanel.Margin = new Padding(3, 2, 3, 2);
            debugPanel.Name = "debugPanel";
            debugPanel.Padding = new Padding(7, 6, 7, 6);
            debugPanel.Size = new Size(438, 124);
            debugPanel.TabIndex = 7;
            debugPanel.Visible = false;
            // 
            // debugLabel
            // 
            debugLabel.BackColor = Color.FromArgb(16, 2, 31);
            debugLabel.BorderStyle = BorderStyle.None;
            debugLabel.Dock = DockStyle.Fill;
            debugLabel.Font = new Font("JetBrains Mono", 9.75F, FontStyle.Regular, GraphicsUnit.Point);
            debugLabel.ForeColor = Color.White;
            debugLabel.Location = new Point(7, 6);
            debugLabel.Margin = new Padding(3, 2, 3, 2);
            debugLabel.Multiline = true;
            debugLabel.Name = "debugLabel";
            debugLabel.ReadOnly = true;
            debugLabel.ScrollBars = ScrollBars.Vertical;
            debugLabel.Size = new Size(422, 110);
            debugLabel.TabIndex = 0;
            // 
            // btnToggleDebug
            // 
            btnToggleDebug.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            btnToggleDebug.BackColor = Color.FromArgb(30, 1, 62);
            btnToggleDebug.BorderColor = Color.FromArgb(250, 91, 101);
            btnToggleDebug.BorderRadius = 10;
            btnToggleDebug.FlatStyle = FlatStyle.Flat;
            btnToggleDebug.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            btnToggleDebug.ForeColor = Color.White;
            btnToggleDebug.HoverBackColor = Color.FromArgb(214, 37, 106);
            btnToggleDebug.Location = new Point(21, 495);
            btnToggleDebug.Margin = new Padding(0, 0, 0, 12);
            btnToggleDebug.Name = "btnToggleDebug";
            btnToggleDebug.Size = new Size(437, 35);
            btnToggleDebug.TabIndex = 5;
            btnToggleDebug.Text = "Show Debug Info";
            btnToggleDebug.UseVisualStyleBackColor = false;
            // 
            // strengthPanel1
            // 
            strengthPanel1.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            strengthPanel1.Controls.Add(lblRecoilReductionStrengthValue);
            strengthPanel1.Controls.Add(lblRecoilReductionStrengthPrefix);
            strengthPanel1.Controls.Add(trackBarRecoilReduction);
            strengthPanel1.Controls.Add(lblRecoilReductionActive);
            strengthPanel1.Location = new Point(20, 225);
            strengthPanel1.Margin = new Padding(0, 0, 0, 12);
            strengthPanel1.Name = "strengthPanel1";
            strengthPanel1.Size = new Size(438, 84);
            strengthPanel1.TabIndex = 9;
            // 
            // lblRecoilReductionStrengthValue
            // 
            lblRecoilReductionStrengthValue.AutoSize = true;
            lblRecoilReductionStrengthValue.Font = new Font("JetBrains Mono", 10F, FontStyle.Bold, GraphicsUnit.Point);
            lblRecoilReductionStrengthValue.ForeColor = Color.White;
            lblRecoilReductionStrengthValue.Location = new Point(212, 6);
            lblRecoilReductionStrengthValue.Margin = new Padding(0);
            lblRecoilReductionStrengthValue.Name = "lblRecoilReductionStrengthValue";
            lblRecoilReductionStrengthValue.Size = new Size(16, 18);
            lblRecoilReductionStrengthValue.TabIndex = 1;
            lblRecoilReductionStrengthValue.Text = "1";
            // 
            // lblRecoilReductionStrengthPrefix
            // 
            lblRecoilReductionStrengthPrefix.AutoSize = true;
            lblRecoilReductionStrengthPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblRecoilReductionStrengthPrefix.ForeColor = Color.White;
            lblRecoilReductionStrengthPrefix.Location = new Point(0, 6);
            lblRecoilReductionStrengthPrefix.Margin = new Padding(0);
            lblRecoilReductionStrengthPrefix.Name = "lblRecoilReductionStrengthPrefix";
            lblRecoilReductionStrengthPrefix.Size = new Size(216, 18);
            lblRecoilReductionStrengthPrefix.TabIndex = 0;
            lblRecoilReductionStrengthPrefix.Text = "Recoil Reduction Strength:";
            // 
            // trackBarRecoilReduction
            // 
            trackBarRecoilReduction.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            trackBarRecoilReduction.Location = new Point(0, 37);
            trackBarRecoilReduction.Margin = new Padding(0);
            trackBarRecoilReduction.Maximum = 20;
            trackBarRecoilReduction.Minimum = 1;
            trackBarRecoilReduction.Name = "trackBarRecoilReduction";
            trackBarRecoilReduction.Size = new Size(438, 45);
            trackBarRecoilReduction.TabIndex = 8;
            trackBarRecoilReduction.ThumbColor = Color.FromArgb(255, 255, 255);
            trackBarRecoilReduction.TickColor = Color.FromArgb(250, 91, 101);
            trackBarRecoilReduction.TrackColor = Color.FromArgb(214, 37, 106);
            trackBarRecoilReduction.Value = 1;
            // 
            // lblRecoilReductionActive (RecoilReduction Active Label)
            // 
            lblRecoilReductionActive.AutoSize = true;
            lblRecoilReductionActive.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblRecoilReductionActive.ForeColor = Color.FromArgb(250, 91, 101);
            lblRecoilReductionActive.Location = new Point(350, 5);
            lblRecoilReductionActive.Name = "lblRecoilReductionActive";
            lblRecoilReductionActive.Size = new Size(0, 20);
            lblRecoilReductionActive.TabIndex = 1;
            lblRecoilReductionActive.TextAlign = ContentAlignment.MiddleRight;
            // 
            // strengthPanel2
            // 
            strengthPanel2.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            strengthPanel2.Controls.Add(lblJitterStrengthValue);
            strengthPanel2.Controls.Add(lblJitterStrengthPrefix);
            strengthPanel2.Controls.Add(trackBarJitter);
            strengthPanel2.Controls.Add(lblJitterActive);
            strengthPanel2.Location = new Point(20, 331);
            strengthPanel2.Margin = new Padding(0, 0, 0, 12);
            strengthPanel2.Name = "strengthPanel2";
            strengthPanel2.Size = new Size(438, 81);
            strengthPanel2.TabIndex = 10;
            // 
            // lblJitterStrengthValue
            // 
            lblJitterStrengthValue.AutoSize = true;
            lblJitterStrengthValue.Font = new Font("JetBrains Mono", 10F, FontStyle.Bold, GraphicsUnit.Point);
            lblJitterStrengthValue.ForeColor = Color.White;
            lblJitterStrengthValue.Location = new Point(132, 6);
            lblJitterStrengthValue.Margin = new Padding(0);
            lblJitterStrengthValue.Name = "lblJitterStrengthValue";
            lblJitterStrengthValue.Size = new Size(16, 18);
            lblJitterStrengthValue.TabIndex = 1;
            lblJitterStrengthValue.Text = "3";
            // 
            // lblJitterStrengthPrefix
            // 
            lblJitterStrengthPrefix.AutoSize = true;
            lblJitterStrengthPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblJitterStrengthPrefix.ForeColor = Color.White;
            lblJitterStrengthPrefix.Location = new Point(0, 6);
            lblJitterStrengthPrefix.Margin = new Padding(0);
            lblJitterStrengthPrefix.Name = "lblJitterStrengthPrefix";
            lblJitterStrengthPrefix.Size = new Size(144, 18);
            lblJitterStrengthPrefix.TabIndex = 0;
            lblJitterStrengthPrefix.Text = "Jitter Strength: ";
            // 
            // trackBarJitter
            // 
            trackBarJitter.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            trackBarJitter.Location = new Point(0, 34);
            trackBarJitter.Margin = new Padding(0);
            trackBarJitter.Maximum = 20;
            trackBarJitter.Minimum = 1;
            trackBarJitter.Name = "trackBarJitter";
            trackBarJitter.Size = new Size(438, 45);
            trackBarJitter.TabIndex = 3;
            trackBarJitter.ThumbColor = Color.FromArgb(255, 255, 255);
            trackBarJitter.TickColor = Color.FromArgb(250, 91, 101);
            trackBarJitter.TrackColor = Color.FromArgb(214, 37, 106);
            trackBarJitter.Value = 3;
            // 
            // lblJitterActive (Jitter Active Label)
            // 
            lblJitterActive.AutoSize = true;
            lblJitterActive.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblJitterActive.ForeColor = Color.FromArgb(250, 91, 101);
            lblJitterActive.Location = new Point(350, 5);
            lblJitterActive.Name = "lblJitterActive";
            lblJitterActive.Size = new Size(0, 20);
            lblJitterActive.TabIndex = 0;
            lblJitterActive.TextAlign = ContentAlignment.MiddleRight;
            lblJitterActive.Click += lblJitterActive_Click;
            // 
            // settingsPanel
            // 
            settingsPanel.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            settingsPanel.Controls.Add(lblCurrentKeyValue);
            settingsPanel.Controls.Add(lblCurrentKeyPrefix);
            settingsPanel.Controls.Add(btnSetKey);
            settingsPanel.Controls.Add(chkMinimizeToTray);
            settingsPanel.Controls.Add(lblMacroSwitchKeyValue);
            settingsPanel.Controls.Add(btnSetMacroSwitch);
            settingsPanel.Controls.Add(lblMacroSwitchKeyPrefix);
            settingsPanel.Location = new Point(20, 25);
            settingsPanel.Margin = new Padding(0, 0, 0, 12);
            settingsPanel.Name = "settingsPanel";
            settingsPanel.Size = new Size(438, 179);
            settingsPanel.TabIndex = 11;
            // 
            // lblCurrentKeyValue
            // 
            lblCurrentKeyValue.AutoSize = true;
            lblCurrentKeyValue.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Bold, GraphicsUnit.Point);
            lblCurrentKeyValue.ForeColor = Color.White;
            lblCurrentKeyValue.Location = new Point(141, 22);
            lblCurrentKeyValue.Margin = new Padding(0);
            lblCurrentKeyValue.Name = "lblCurrentKeyValue";
            lblCurrentKeyValue.Size = new Size(64, 18);
            lblCurrentKeyValue.TabIndex = 1;
            lblCurrentKeyValue.Text = "Capital";
            // 
            // lblCurrentKeyPrefix
            // 
            lblCurrentKeyPrefix.AutoSize = true;
            lblCurrentKeyPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblCurrentKeyPrefix.ForeColor = Color.White;
            lblCurrentKeyPrefix.Location = new Point(0, 21);
            lblCurrentKeyPrefix.Margin = new Padding(0);
            lblCurrentKeyPrefix.Name = "lblCurrentKeyPrefix";
            lblCurrentKeyPrefix.Size = new Size(144, 18);
            lblCurrentKeyPrefix.TabIndex = 0;
            lblCurrentKeyPrefix.Text = "Macro Toggle Key:";
            lblCurrentKeyPrefix.Click += lblCurrentKeyPrefix_Click;
            // 
            // btnSetKey
            // 
            btnSetKey.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            btnSetKey.BackColor = Color.FromArgb(30, 1, 62);
            btnSetKey.BorderColor = Color.FromArgb(250, 91, 101);
            btnSetKey.BorderRadius = 10;
            btnSetKey.FlatStyle = FlatStyle.Flat;
            btnSetKey.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            btnSetKey.ForeColor = Color.White;
            btnSetKey.HoverBackColor = Color.FromArgb(214, 37, 106);
            btnSetKey.Location = new Point(1, 49);
            btnSetKey.Margin = new Padding(0, 0, 0, 12);
            btnSetKey.Name = "btnSetKey";
            btnSetKey.Size = new Size(437, 35);
            btnSetKey.TabIndex = 1;
            btnSetKey.Text = "Set Toggle Key";
            btnSetKey.UseVisualStyleBackColor = false;
            // 
            // chkMinimizeToTray
            // 
            chkMinimizeToTray.Anchor = AnchorStyles.Top | AnchorStyles.Right;
            chkMinimizeToTray.AutoSize = true;
            chkMinimizeToTray.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            chkMinimizeToTray.ForeColor = Color.White;
            chkMinimizeToTray.Location = new Point(280, 3);
            chkMinimizeToTray.Margin = new Padding(3, 2, 3, 2);
            chkMinimizeToTray.Name = "chkMinimizeToTray";
            chkMinimizeToTray.Size = new Size(155, 22);
            chkMinimizeToTray.TabIndex = 6;
            chkMinimizeToTray.Text = "Minimize to Tray";
            // 
            // lblMacroSwitchKeyValue
            // 
            lblMacroSwitchKeyValue.AutoSize = true;
            lblMacroSwitchKeyValue.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Bold, GraphicsUnit.Point);
            lblMacroSwitchKeyValue.ForeColor = Color.White;
            lblMacroSwitchKeyValue.Location = new Point(148, 105);
            lblMacroSwitchKeyValue.Name = "lblMacroSwitchKeyValue";
            lblMacroSwitchKeyValue.Size = new Size(20, 19);
            lblMacroSwitchKeyValue.TabIndex = 5;
            lblMacroSwitchKeyValue.Text = "Q";
            // 
            // btnSetMacroSwitch
            // 
            btnSetMacroSwitch.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            btnSetMacroSwitch.BackColor = Color.FromArgb(30, 1, 62);
            btnSetMacroSwitch.BorderColor = Color.FromArgb(250, 91, 101);
            btnSetMacroSwitch.BorderRadius = 10;
            btnSetMacroSwitch.FlatStyle = FlatStyle.Flat;
            btnSetMacroSwitch.Font = new Font("JetBrains Mono", 10F, FontStyle.Regular, GraphicsUnit.Point);
            btnSetMacroSwitch.ForeColor = Color.White;
            btnSetMacroSwitch.HoverBackColor = Color.FromArgb(214, 37, 106);
            btnSetMacroSwitch.Location = new Point(1, 133);
            btnSetMacroSwitch.Margin = new Padding(0, 0, 0, 12);
            btnSetMacroSwitch.Name = "btnSetMacroSwitch";
            btnSetMacroSwitch.Size = new Size(437, 35);
            btnSetMacroSwitch.TabIndex = 4;
            btnSetMacroSwitch.Text = "Set Switch Key";
            btnSetMacroSwitch.UseVisualStyleBackColor = false;
            // 
            // lblMacroSwitchKeyPrefix
            // 
            lblMacroSwitchKeyPrefix.AutoSize = true;
            lblMacroSwitchKeyPrefix.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            lblMacroSwitchKeyPrefix.ForeColor = Color.White;
            lblMacroSwitchKeyPrefix.Location = new Point(0, 106);
            lblMacroSwitchKeyPrefix.Name = "lblMacroSwitchKeyPrefix";
            lblMacroSwitchKeyPrefix.Size = new Size(152, 18);
            lblMacroSwitchKeyPrefix.TabIndex = 6;
            lblMacroSwitchKeyPrefix.Text = "Switch Macro Mode:";
            // 
            // chkAlwaysJitter
            // 
            chkAlwaysJitter.AutoSize = true;
            chkAlwaysJitter.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            chkAlwaysJitter.ForeColor = Color.White;
            chkAlwaysJitter.Location = new Point(24, 459);
            chkAlwaysJitter.Margin = new Padding(3, 2, 3, 2);
            chkAlwaysJitter.Name = "chkAlwaysJitter";
            chkAlwaysJitter.Size = new Size(171, 22);
            chkAlwaysJitter.TabIndex = 3;
            chkAlwaysJitter.Text = "Always Jitter Mode";
            // 
            // chkAlwaysRecoilReduction
            // 
            chkAlwaysRecoilReduction.AutoSize = true;
            chkAlwaysRecoilReduction.Font = new Font("JetBrains Mono", 10.2F, FontStyle.Regular, GraphicsUnit.Point);
            chkAlwaysRecoilReduction.ForeColor = Color.White;
            chkAlwaysRecoilReduction.Location = new Point(24, 429);
            chkAlwaysRecoilReduction.Margin = new Padding(3, 2, 3, 2);
            chkAlwaysRecoilReduction.Name = "chkAlwaysRecoilReduction";
            chkAlwaysRecoilReduction.Size = new Size(251, 22);
            chkAlwaysRecoilReduction.TabIndex = 2;
            chkAlwaysRecoilReduction.Text = "Always Recoil Reduction Mode";
            // 
            // notifyIcon
            // 
            notifyIcon.ContextMenuStrip = trayContextMenu;
            notifyIcon.Text = "NotesAndTasks";
            notifyIcon.Visible = true;
            // 
            // trayContextMenu
            // 
            trayContextMenu.Items.AddRange(new ToolStripItem[] { showWindowMenuItem, exitMenuItem });
            trayContextMenu.Name = "trayContextMenu";
            trayContextMenu.Size = new Size(151, 48);
            // 
            // showWindowMenuItem
            // 
            showWindowMenuItem.Name = "showWindowMenuItem";
            showWindowMenuItem.Size = new Size(150, 22);
            showWindowMenuItem.Text = "Show Window";
            // 
            // exitMenuItem
            // 
            exitMenuItem.Name = "exitMenuItem";
            exitMenuItem.Size = new Size(150, 22);
            exitMenuItem.Text = "Exit";
            // 
            // MacroForm
            // 
            AutoScaleDimensions = new SizeF(7F, 15F);
            AutoScaleMode = AutoScaleMode.Font;
            BackColor = Color.FromArgb(30, 30, 30);
            ClientSize = new Size(477, 676);
            Controls.Add(mainPanel);
            Margin = new Padding(3, 2, 3, 2);
            MinimumSize = new Size(493, 422);
            Name = "MacroForm";
            Text = "NotesAndTasks";
            mainPanel.ResumeLayout(false);
            mainPanel.PerformLayout();
            debugPanel.ResumeLayout(false);
            debugPanel.PerformLayout();
            strengthPanel1.ResumeLayout(false);
            strengthPanel1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarRecoilReduction).EndInit();
            strengthPanel2.ResumeLayout(false);
            strengthPanel2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)trackBarJitter).EndInit();
            settingsPanel.ResumeLayout(false);
            settingsPanel.PerformLayout();
            trayContextMenu.ResumeLayout(false);
            ResumeLayout(false);
        }

        #endregion
        private System.Windows.Forms.Panel mainPanel;
        private ModernButton btnSetKey;
        private System.Windows.Forms.Label lblCurrentKeyPrefix;
        private System.Windows.Forms.Label lblCurrentKeyValue;
        private ModernTrackBar trackBarJitter;
        private System.Windows.Forms.Label lblJitterStrengthPrefix;
        private System.Windows.Forms.Label lblJitterStrengthValue;
        private ModernTrackBar trackBarRecoilReduction;
        private System.Windows.Forms.Label lblRecoilReductionStrengthPrefix;
        private System.Windows.Forms.Label lblRecoilReductionStrengthValue;
        private ModernButton btnToggleDebug;
        private System.Windows.Forms.Panel debugPanel;
        private System.Windows.Forms.TextBox debugLabel;
        private System.Windows.Forms.NotifyIcon notifyIcon;
        private System.Windows.Forms.ContextMenuStrip trayContextMenu;
        private System.Windows.Forms.ToolStripMenuItem showWindowMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exitMenuItem;
        private System.Windows.Forms.Panel settingsPanel;
        private System.Windows.Forms.Panel strengthPanel1;
        private System.Windows.Forms.Panel strengthPanel2;
        private System.Windows.Forms.CheckBox chkMinimizeToTray;
        private ModernButton btnSetMacroSwitch;
        private System.Windows.Forms.Label lblMacroSwitchKeyPrefix;
        private System.Windows.Forms.Label lblMacroSwitchKeyValue;
        private System.Windows.Forms.CheckBox chkAlwaysJitter;
        private System.Windows.Forms.CheckBox chkAlwaysRecoilReduction;
        private System.Windows.Forms.Label lblRecoilReductionActive;
        private System.Windows.Forms.Label lblJitterActive;
    }
}
</file>

<file path="src/Program.cs">
using System;
using System.Threading;
using System.Windows.Forms;
using System.Diagnostics;
using System.Security.Principal;

namespace NotesAndTasks
{
    internal static class Program
    {
        private static Mutex mutex = new Mutex(true, "NotesTasksGlobalMutex");

        [STAThread]
        static void Main()
        {
            try
            {
                // Check for administrative privileges
                WindowsIdentity identity = WindowsIdentity.GetCurrent();
                WindowsPrincipal principal = new WindowsPrincipal(identity);
                bool isAdmin = principal.IsInRole(WindowsBuiltInRole.Administrator);

                if (!isAdmin)
                {
                    // Restart the application with admin rights
                    ProcessStartInfo startInfo = new ProcessStartInfo();
                    startInfo.UseShellExecute = true;
                    startInfo.WorkingDirectory = Environment.CurrentDirectory;
                    startInfo.FileName = Application.ExecutablePath;
                    startInfo.Verb = "runas";

                    try
                    {
                        Process.Start(startInfo);
                        return;
                    }
                    catch (Exception)
                    {
                        MessageBox.Show("This application requires administrative privileges to run.", "Notes&Tasks",
                            MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }
                }

                // Try to get mutex ownership
                if (!mutex.WaitOne(TimeSpan.Zero, true))
                {
                    MessageBox.Show("Another instance of Notes&Tasks is already running.", "Notes&Tasks", 
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // Optimize process settings for background operation alongside games
                using (Process currentProcess = Process.GetCurrentProcess())
                {
                    // Set process priority to BelowNormal to avoid competing with games
                    currentProcess.PriorityClass = ProcessPriorityClass.BelowNormal;

                    // Set CPU affinity to use last core
                    // This keeps the macro off the primary cores that games typically use
                    if (Environment.ProcessorCount > 1)
                    {
                        int lastCore = Environment.ProcessorCount - 1;
                        currentProcess.ProcessorAffinity = (IntPtr)(1 << lastCore);
                    }

                    // Enable Windows 11 Efficiency Mode
                    // This helps reduce resource competition with games
                    try
                    {
                        if (Environment.OSVersion.Version.Build >= 22621) // Windows 11 22H2 build
                        {
                            currentProcess.ProcessorAffinity = currentProcess.ProcessorAffinity;
                        }
                    }
                    catch (Exception) { /* Ignore if not supported */ }
                }

                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);

                try
                {
                    Application.Run(new MacroForm());
                }
                finally
                {
                    // Release mutex when application exits
                    mutex.ReleaseMutex();
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"An error occurred: {ex.Message}", "Notes&Tasks Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                mutex.Dispose();
            }
        }
    }
}
</file>

<file path="MouseMacro.csproj">
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net6.0-windows</TargetFramework>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
    <UacUIApproved>true</UacUIApproved>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <AssemblyName>Notes&amp;Tasks</AssemblyName>
    <RootNamespace>NotesAndTasks</RootNamespace>
    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>
    <ApplicationIcon>assets\logo.ico</ApplicationIcon>
    <Title>Notes &amp; Tasks</Title>
    <Authors>HaikalllP</Authors>
    <Description>Task Management and Note Taking Application</Description>
    <SignAssembly>true</SignAssembly>
    <EnableUnsafeBinaryFormatterSerialization>true</EnableUnsafeBinaryFormatterSerialization>
    <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
    <Version>1.0.0.1</Version> <!-- Incrementing the version for the next release -->
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DebugType>embedded</DebugType>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
    <DebugType>none</DebugType>
    <Optimize>true</Optimize>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="src\**\*.cs" />
  </ItemGroup>

  <ItemGroup>
    <Compile Include="src\UI\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="src\UI\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
</Project>
</file>

<file path="src/UI/MacroForm.cs">
using System;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.ComponentModel;
using NotesAndTasks.Configuration;
using NotesAndTasks.Hooks;
using NotesAndTasks.Utilities;
using NotesAndTasks.UI;

namespace NotesAndTasks
{
    /// <summary>
    /// Main form for the Notes&Tasks application that provides mouse input management functionality.
    /// This form handles both jitter and recoil reduction features with configurable hotkeys and settings.
    /// </summary>
    /// <remarks>
    /// The form implements two main features:
    /// 1. Jitter - Applies a complex movement pattern to the mouse cursor
    /// 2. Recoil Reduction - Provides vertical compensation with configurable strength
    /// 
    /// Both features are activated when left and right mouse buttons are held simultaneously.
    /// The application can be minimized to the system tray and supports various hotkeys for control.
    /// </remarks>
    public partial class MacroForm : Form
    {
        #region Fields
        private readonly KeyboardHook keyboardHook;
        private readonly MouseHook mouseHook;
        private readonly MacroManager macroManager;
        private readonly HotkeyManager hotkeyManager;
        private readonly UIManager uiManager;
        private readonly ToolTip toolTip;

        private bool isSettingKey = false;
        private bool isSettingMacroSwitchKey = false;
        private bool isExiting = false;
        private System.Threading.Timer jitterTimer;
        private int jitterStrength = 3;  // Default to 3
        private int recoilReductionStrength = 1;  // Default to 1
        private bool isJittering = false;
        private int currentStep = 0;
        private readonly object lockObject = new object();
        private bool leftButtonDown = false;
        private bool rightButtonDown = false;
        private bool jitterEnabled = false;
        private bool alwaysJitterMode = false;
        private bool alwaysRecoilReductionMode = false;
        private bool recoilReductionEnabled = false;

        private readonly (int dx, int dy)[] jitterPattern = new[]
        {
            (7, 7), (-7, -7), (0, 7), (7, 7), (-7, -7),
            (0, 6), (7, 7), (-7, -7), (0, 7), (7, 7),
            (-7, -7), (0, 6), (7, 7), (-7, -7), (0, 6),
            (7, 7), (-7, -7), (0, 7), (7, 7), (-7, -7),
            (0, 6), (7, 7), (-7, -7), (0, 6)
        };

        private const double BASE_RECOIL_STRENGTH = 0.75;
        private const double BASE_RECOIL_STRENGTH_2 = 2.0;
        private const double LOW_LEVEL_1_SPEED = 0.25;
        private const double LOW_LEVEL_2_SPEED = 0.5;
        private const double LOW_LEVEL_3_SPEED = 0.75;

        #endregion

        /// <summary>
        /// Initializes a new instance of the MacroForm class.
        /// Sets up all necessary components, hooks, and event handlers.
        /// </summary>
        public MacroForm()
        {
            // Initialize hooks and tools before InitializeComponent
            keyboardHook = new KeyboardHook();
            mouseHook = new MouseHook();
            macroManager = new MacroManager();
            hotkeyManager = new HotkeyManager();
            toolTip = new ToolTip();

            try
            {
                InitializeComponent();

                // Initialize UI Manager after components are initialized
                uiManager = new UIManager(
                    this,
                    macroManager,
                    hotkeyManager,
                    debugLabel,
                    lblJitterActive,
                    lblRecoilReductionActive,
                    lblCurrentKeyValue,
                    lblMacroSwitchKeyValue,
                    lblJitterStrengthValue,
                    lblRecoilReductionStrengthValue,
                    notifyIcon,
                    toolTip
                );

                // Initialize components and settings
                InitializeCustomComponents();

                // Initialize tray icon behavior
                notifyIcon.DoubleClick += (s, e) => uiManager.ShowWindow();
                showWindowMenuItem.Click += (s, e) => uiManager.ShowWindow();
                exitMenuItem.Click += (s, e) => CleanupAndExit();

                this.FormClosing += OnFormClosingHandler;
                this.Resize += OnResizeHandler;
                this.Load += OnLoadHandler;

                // Set up hook event handlers
                keyboardHook.KeyDown += OnKeyDown;
                mouseHook.MouseDown += OnMouseDown;
                mouseHook.MouseUp += OnMouseUp;

                // Set up macro manager event handlers
                macroManager.MacroStateChanged += OnMacroStateChanged;
                macroManager.ModeChanged += OnModeChanged;
                macroManager.JitterStarted += (s, e) => uiManager.UpdateDebugInfo("Jitter started");
                macroManager.JitterStopped += (s, e) => uiManager.UpdateDebugInfo("Jitter stopped");
                macroManager.RecoilReductionStarted += (s, e) => uiManager.UpdateDebugInfo("Recoil reduction started");
                macroManager.RecoilReductionStopped += (s, e) => uiManager.UpdateDebugInfo("Recoil reduction stopped");

                // Set up hotkey manager event handlers
                hotkeyManager.MacroKeyChanged += (s, key) => uiManager.UpdateCurrentKey(key.ToString());
                hotkeyManager.SwitchKeyChanged += (s, key) => uiManager.UpdateMacroSwitchKey(key.ToString());

                // Handle application exit
                Application.ApplicationExit += (s, e) =>
                {
                    if (!isExiting)
                    {
                        CleanupAndExit();
                    }
                };
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing form: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void OnKeyDown(object sender, KeyboardHookEventArgs e)
        {
            try
            {
                if (isSettingKey)
                {
                    isSettingKey = false;
                    btnSetKey.Enabled = true;
                    btnSetKey.Text = "Set Toggle Key";
                    hotkeyManager.SetMacroKey(e.VirtualKeyCode, ToggleType.Keyboard);
                    uiManager.UpdateDebugInfo($"Set toggle key to {e.VirtualKeyCode}");
                }
                else if (isSettingMacroSwitchKey)
                {
                    isSettingMacroSwitchKey = false;
                    btnSetMacroSwitch.Enabled = true;
                    btnSetMacroSwitch.Text = "Set Switch Key";
                    hotkeyManager.SetSwitchKey(e.VirtualKeyCode);
                    uiManager.UpdateDebugInfo($"Set macro switch key to {e.VirtualKeyCode}");
                }
                else if (e.VirtualKeyCode == hotkeyManager.MacroKey && hotkeyManager.ToggleType == ToggleType.Keyboard)
                {
                    macroManager.ToggleMacro();
                }
                else if (e.VirtualKeyCode == hotkeyManager.SwitchKey)
                {
                    macroManager.SwitchMode();
                }
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnKeyDown: {ex.Message}");
            }
        }

        private void OnMouseDown(object sender, MouseHookEventArgs e)
        {
            try
            {
                switch (e.Button)
                {
                    case MouseButtons.Left:
                    case MouseButtons.Right:
                        macroManager.HandleMouseButton(e.Button, true);
                        break;
                    case MouseButtons.Middle:
                        if (isSettingKey)
                        {
                            isSettingKey = false;
                            btnSetKey.Enabled = true;
                            btnSetKey.Text = "Set Toggle Key";
                            hotkeyManager.SetMacroKey(Keys.MButton, ToggleType.MouseMiddle);
                            uiManager.UpdateDebugInfo("Set toggle key to MButton");
                        }
                        else if (isSettingMacroSwitchKey)
                        {
                            isSettingMacroSwitchKey = false;
                            btnSetMacroSwitch.Enabled = true;
                            btnSetMacroSwitch.Text = "Set Switch Key";
                            hotkeyManager.SetSwitchKey(Keys.MButton);
                            uiManager.UpdateDebugInfo("Set macro switch key to MButton");
                        }
                        else if (hotkeyManager.MacroKey == Keys.MButton)
                        {
                            macroManager.ToggleMacro();
                        }
                        else if (hotkeyManager.SwitchKey == Keys.MButton)
                        {
                            macroManager.SwitchMode();
                        }
                        break;
                    case MouseButtons.XButton1:
                    case MouseButtons.XButton2:
                        if (isSettingKey)
                        {
                            isSettingKey = false;
                            btnSetKey.Enabled = true;
                            btnSetKey.Text = "Set Toggle Key";
                            string buttonName = e.Button == MouseButtons.XButton1 ? "XButton1" : "XButton2";
                            Keys key = e.Button == MouseButtons.XButton1 ? Keys.XButton1 : Keys.XButton2;
                            var type = e.Button == MouseButtons.XButton1 ? 
                                ToggleType.MouseX1 : 
                                ToggleType.MouseX2;
                            hotkeyManager.SetMacroKey(key, type);
                            uiManager.UpdateDebugInfo($"Set toggle key to {buttonName}");
                        }
                        else if (isSettingMacroSwitchKey)
                        {
                            isSettingMacroSwitchKey = false;
                            btnSetMacroSwitch.Enabled = true;
                            btnSetMacroSwitch.Text = "Set Switch Key";
                            string buttonName = e.Button == MouseButtons.XButton1 ? "XButton1" : "XButton2";
                            Keys key = e.Button == MouseButtons.XButton1 ? Keys.XButton1 : Keys.XButton2;
                            hotkeyManager.SetSwitchKey(key);
                            uiManager.UpdateDebugInfo($"Set macro switch key to {buttonName}");
                        }
                        else if ((e.Button == MouseButtons.XButton1 && hotkeyManager.MacroKey == Keys.XButton1) ||
                                (e.Button == MouseButtons.XButton2 && hotkeyManager.MacroKey == Keys.XButton2))
                        {
                            macroManager.ToggleMacro();
                        }
                        else if ((e.Button == MouseButtons.XButton1 && hotkeyManager.SwitchKey == Keys.XButton1) ||
                                (e.Button == MouseButtons.XButton2 && hotkeyManager.SwitchKey == Keys.XButton2))
                        {
                            macroManager.SwitchMode();
                        }
                        break;
                }
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnMouseDown: {ex.Message}");
            }
        }

        private void OnMouseUp(object sender, MouseHookEventArgs e)
        {
            try
            {
                if (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right)
                {
                    macroManager.HandleMouseButton(e.Button, false);
                }
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnMouseUp: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles the form closing event. If minimize to tray is enabled,
        /// the form will be hidden instead of closed when the user clicks the close button.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Event data containing the close reason and cancellation option.</param>
        private void OnFormClosingHandler(object sender, FormClosingEventArgs e)
        {
            if (!isExiting && chkMinimizeToTray.Checked && e.CloseReason == CloseReason.UserClosing)
            {
                e.Cancel = true;
                this.Hide();
                notifyIcon.Visible = true;
                uiManager.UpdateDebugInfo("Application minimized to system tray");
            }
            else if (isExiting || !chkMinimizeToTray.Checked)
            {
                // Cleanup when actually closing
                CleanupAndExit();
            }
        }

        /// <summary>
        /// Handles form resize events by ensuring proper layout of controls.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Event data.</param>
        private void OnResizeHandler(object sender, EventArgs e)
        {
            // Let the anchor properties handle control resizing
            mainPanel.PerformLayout();
            this.PerformLayout();
        }

        /// <summary>
        /// Handles the form load event by initializing hooks and timers.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Event data.</param>
        private void OnLoadHandler(object sender, EventArgs e)
        {
            try
            {
                // Start the hooks
                keyboardHook.Start();
                mouseHook.Start();
                
                // Update UI
                uiManager.UpdateTitle();
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error initializing hooks: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles changes in the macro's enabled/disabled state.
        /// </summary>
        private void OnMacroStateChanged(object sender, bool isEnabled)
        {
            try
            {
                uiManager.UpdateTitle();
                uiManager.UpdateDebugInfo($"Macro {(isEnabled ? "enabled" : "disabled")}");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnMacroStateChanged: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles changes in the macro's mode (jitter/recoil reduction).
        /// </summary>
        private void OnModeChanged(object sender, bool isJitterMode)
        {
            try
            {
                uiManager.UpdateTitle();
                uiManager.UpdateModeLabels();
                uiManager.UpdateDebugInfo($"Mode switched to {(isJitterMode ? "jitter" : "recoil reduction")}");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in OnModeChanged: {ex.Message}");
            }
        }

        /// <summary>
        /// Initializes custom components including icons, hotkeys, tooltips, and loads saved settings.
        /// </summary>
        private void InitializeCustomComponents()
        {
            try
            {
                using var icon = Icon.ExtractAssociatedIcon(Application.ExecutablePath);
                if (icon != null)
                {
                    this.Icon = (Icon)icon.Clone();
                    notifyIcon.Icon = (Icon)icon.Clone();
                }
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error loading icon: {ex.Message}");
            }

            // Set initial text with bold formatting
            if (hotkeyManager.MacroKey != Keys.None)
                uiManager.UpdateCurrentKey(hotkeyManager.MacroKey.ToString());
            if (hotkeyManager.SwitchKey != Keys.None)
                uiManager.UpdateSwitchKey(hotkeyManager.SwitchKey.ToString());

            // Initialize tooltips
            toolTip.SetToolTip(chkAlwaysJitter, "Always keep Jitter enabled");
            toolTip.SetToolTip(trackBarJitter, "Adjust Jitter strength");
            toolTip.SetToolTip(chkAlwaysRecoilReduction, "Always keep Recoil Reduction enabled");
            toolTip.SetToolTip(trackBarRecoilReduction, "Adjust Recoil Reduction strength");
            toolTip.SetToolTip(chkMinimizeToTray, "Minimize to system tray when closing");

            // Initialize event handlers
            InitializeEventHandlers();

            // Load settings
            LoadSettings();
        }

        private void InitializeEventHandlers()
        {
            btnToggleDebug.Click += (sender, e) =>
            {
                debugPanel.Visible = !debugPanel.Visible;
                btnToggleDebug.Text = debugPanel.Visible ? "Hide Debug Info" : "Show Debug Info";
                uiManager.UpdateDebugInfo("Debug panel visibility toggled");
            };

            btnSetKey.Click += (sender, e) =>
            {
                isSettingKey = true;
                btnSetKey.Text = "Press any key...";
                btnSetKey.Enabled = false;
                uiManager.UpdateDebugInfo("Waiting for new toggle key...");
            };

            trackBarJitter.ValueChanged += (sender, e) =>
            {
                try
                {
                    Validation.ValidateStrength(trackBarJitter.Value, trackBarJitter.Minimum, trackBarJitter.Maximum, nameof(trackBarJitter.Value));
                    macroManager.SetJitterStrength(trackBarJitter.Value);
                    SettingsManager.CurrentSettings.JitterStrength = trackBarJitter.Value;
                    SettingsManager.SaveSettings();
                    uiManager.UpdateJitterStrength(trackBarJitter.Value);
                    uiManager.UpdateDebugInfo($"Jitter strength set to {trackBarJitter.Value}");
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    uiManager.UpdateDebugInfo($"Error setting jitter strength: {ex.Message}");
                    trackBarJitter.Value = Math.Max(trackBarJitter.Minimum, Math.Min(trackBarJitter.Maximum, trackBarJitter.Value));
                }
            };

            trackBarRecoilReduction.ValueChanged += (sender, e) =>
            {
                try
                {
                    Validation.ValidateStrength(trackBarRecoilReduction.Value, trackBarRecoilReduction.Minimum, trackBarRecoilReduction.Maximum, nameof(trackBarRecoilReduction.Value));
                    macroManager.SetRecoilReductionStrength(trackBarRecoilReduction.Value);
                    SettingsManager.CurrentSettings.RecoilReductionStrength = trackBarRecoilReduction.Value;
                    SettingsManager.SaveSettings();
                    uiManager.UpdateRecoilReductionStrength(trackBarRecoilReduction.Value);
                    uiManager.UpdateDebugInfo($"Recoil reduction strength set to {trackBarRecoilReduction.Value}");
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    uiManager.UpdateDebugInfo($"Error setting recoil reduction strength: {ex.Message}");
                    trackBarRecoilReduction.Value = Math.Max(trackBarRecoilReduction.Minimum, Math.Min(trackBarRecoilReduction.Maximum, trackBarRecoilReduction.Value));
                }
            };

            chkAlwaysJitter.CheckedChanged += (sender, e) =>
            {
                macroManager.SetAlwaysJitterMode(chkAlwaysJitter.Checked);
                btnSetMacroSwitch.Enabled = !chkAlwaysJitter.Checked;
                SettingsManager.CurrentSettings.AlwaysJitterMode = chkAlwaysJitter.Checked;
                SettingsManager.SaveSettings();
                uiManager.UpdateTitle();
                uiManager.UpdateModeLabels();
            };

            chkAlwaysRecoilReduction.CheckedChanged += (sender, e) =>
            {
                macroManager.SetAlwaysRecoilReductionMode(chkAlwaysRecoilReduction.Checked);
                btnSetMacroSwitch.Enabled = !chkAlwaysRecoilReduction.Checked;
                SettingsManager.CurrentSettings.AlwaysRecoilReductionMode = chkAlwaysRecoilReduction.Checked;
                SettingsManager.SaveSettings();
                uiManager.UpdateTitle();
                uiManager.UpdateModeLabels();
            };

            chkMinimizeToTray.CheckedChanged += (sender, e) =>
            {
                SettingsManager.CurrentSettings.MinimizeToTray = chkMinimizeToTray.Checked;
                SettingsManager.SaveSettings();
            };

            btnSetMacroSwitch.Click += (sender, e) =>
            {
                isSettingMacroSwitchKey = true;
                btnSetMacroSwitch.Text = "Press any key...";
                btnSetMacroSwitch.Enabled = false;
                uiManager.UpdateDebugInfo("Waiting for new switch key...");
            };
        }

        /// <summary>
        /// Loads saved settings from the settings manager and applies them to the form.
        /// Validates all settings before applying them and falls back to defaults if validation fails.
        /// </summary>
        private void LoadSettings()
        {
            try
            {
                var settings = SettingsManager.CurrentSettings;
                Validation.ValidateNotNull(settings, nameof(settings));

                // Validate all settings before applying them
                if (!SettingsValidation.ValidateSettings(settings, 
                    Math.Min(trackBarJitter.Minimum, trackBarRecoilReduction.Minimum),
                    Math.Max(trackBarJitter.Maximum, trackBarRecoilReduction.Maximum)))
                {
                    uiManager.UpdateDebugInfo("Invalid settings detected, resetting to defaults");
                    ResetToDefaultSettings();
                    return;
                }

                // Apply validated settings to UI
                trackBarJitter.Value = settings.JitterStrength;
                trackBarRecoilReduction.Value = settings.RecoilReductionStrength;
                chkAlwaysJitter.Checked = settings.AlwaysJitterMode;
                chkAlwaysRecoilReduction.Checked = settings.AlwaysRecoilReductionMode;
                chkMinimizeToTray.Checked = settings.MinimizeToTray;

                // Update UI elements
                uiManager.UpdateTitle();
                uiManager.UpdateModeLabels();
                uiManager.UpdateDebugInfo("Settings loaded successfully");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error loading settings: {ex.Message}");
                ResetToDefaultSettings();
            }
        }

        /// <summary>
        /// Saves the current settings to the settings manager.
        /// </summary>
        private void SaveCurrentSettings()
        {
            try
            {
                var settings = SettingsManager.CurrentSettings;
                settings.JitterStrength = trackBarJitter.Value;
                settings.RecoilReductionStrength = trackBarRecoilReduction.Value;
                settings.AlwaysJitterMode = chkAlwaysJitter.Checked;
                settings.AlwaysRecoilReductionMode = chkAlwaysRecoilReduction.Checked;
                settings.MinimizeToTray = chkMinimizeToTray.Checked;
                SettingsManager.SaveSettings();
                uiManager.UpdateDebugInfo("Settings saved successfully");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error saving settings: {ex.Message}");
            }
        }

        /// <summary>
        /// Resets all settings to their default values.
        /// </summary>
        private void ResetToDefaultSettings()
        {
            try
            {
                // Reset UI controls
                trackBarJitter.Value = 3;
                trackBarRecoilReduction.Value = 1;
                chkAlwaysJitter.Checked = false;
                chkAlwaysRecoilReduction.Checked = false;
                chkMinimizeToTray.Checked = true;

                // Reset MacroManager
                macroManager.SetJitterStrength(3);
                macroManager.SetRecoilReductionStrength(1);
                macroManager.SetAlwaysJitterMode(false);
                macroManager.SetAlwaysRecoilReductionMode(false);

                // Reset hotkeys
                hotkeyManager.ResetToDefaults();

                // Update UI
                uiManager.UpdateCurrentKey(hotkeyManager.MacroKey.ToString());
                uiManager.UpdateSwitchKey(hotkeyManager.SwitchKey.ToString());
                uiManager.UpdateTitle();
                uiManager.UpdateModeLabels();

                // Save settings
                SaveCurrentSettings();
                uiManager.UpdateDebugInfo("Settings reset to defaults");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error resetting settings: {ex.Message}");
            }
        }

        /// <summary>
        /// Shows and activates the main window when restored from system tray.
        /// </summary>
        private void ShowWindow()
        {
            this.Show();
            this.WindowState = FormWindowState.Normal;
            this.Activate();
            notifyIcon.Visible = false;
            uiManager.UpdateDebugInfo("Application restored from system tray");
        }

        /// <summary>
        /// Toggles the macro on/off state and updates the UI accordingly.
        /// </summary>
        private void ToggleMacro()
        {
            macroManager.ToggleMacro();
            string mode = macroManager.IsJitterEnabled ? "Jitter" : "Recoil Reduction";
            string alwaysMode = macroManager.IsAlwaysJitterMode ? "Always Jitter" : 
                (macroManager.IsAlwaysRecoilReductionMode ? "Always Recoil Reduction" : "Normal");
            uiManager.UpdateDebugInfo($"Macro {(macroManager.IsEnabled ? "Enabled" : "Disabled")} - Mode: {mode}, Always Mode: {alwaysMode}, Key: **{hotkeyManager.MacroKey}**");
            uiManager.UpdateModeLabels();
        }

        /// <summary>
        /// Handles switching between jitter and recoil reduction modes.
        /// Only works when neither "Always" mode is enabled.
        /// Validates mode state before switching.
        /// </summary>
        private void HandleModeSwitch()
        {
            try
            {
                // Validate current state
                if (isSettingKey || isSettingMacroSwitchKey)
                {
                    uiManager.UpdateDebugInfo("Cannot switch modes while setting keys");
                    return;
                }

                // Don't switch if either "Always" mode is enabled
                if (alwaysJitterMode || alwaysRecoilReductionMode)
                {
                    uiManager.UpdateDebugInfo("Cannot switch modes when 'Always' mode is enabled");
                    return;
                }

                // Toggle between jitter and recoil reduction with validation
                bool previousJitterState = jitterEnabled;
                bool previousRecoilState = recoilReductionEnabled;

                jitterEnabled = !jitterEnabled;
                recoilReductionEnabled = !jitterEnabled;

                // Validate the new state
                if (jitterEnabled == recoilReductionEnabled)
                {
                    // Invalid state detected, revert changes
                    jitterEnabled = previousJitterState;
                    recoilReductionEnabled = previousRecoilState;
                    uiManager.UpdateDebugInfo("Error: Invalid mode state detected");
                    return;
                }

                // Save the new state
                try
                {
                    SettingsManager.CurrentSettings.JitterEnabled = jitterEnabled;
                    SettingsManager.CurrentSettings.RecoilReductionEnabled = recoilReductionEnabled;
                    SettingsManager.SaveSettings();
                }
                catch (Exception ex)
                {
                    // Revert changes if settings save fails
                    jitterEnabled = previousJitterState;
                    recoilReductionEnabled = previousRecoilState;
                    uiManager.UpdateDebugInfo($"Error saving mode settings: {ex.Message}");
                    return;
                }

                uiManager.UpdateTitle();
                uiManager.UpdateModeLabels();
                uiManager.UpdateDebugInfo($"Switched to {(jitterEnabled ? "Jitter" : "Recoil Reduction")} mode");
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error in HandleModeSwitch: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates the active mode labels in the UI.
        /// Thread-safe method that can be called from any thread.
        /// </summary>
        private void UpdateModeLabels()
        {
            if (InvokeRequired)
            {
                Invoke(new Action(UpdateModeLabels));
                return;
            }

            uiManager.UpdateModeLabels();
        }

        private void lblJitterActive_Click(object sender, EventArgs e)
        {

        }

        private void lblCurrentKeyPrefix_Click(object sender, EventArgs e)
        {

        }

        private void strengthPanel2_Paint(object sender, PaintEventArgs e)
        {
            // This is an empty Paint event handler for strengthPanel2
        }

        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            SaveCurrentSettings();
            base.OnFormClosing(e);
        }

        /// <summary>
        /// Performs cleanup operations before exiting the application.
        /// </summary>
        private void CleanupAndExit()
        {
            try
            {
                isExiting = true;
                SaveCurrentSettings();

                // Stop and dispose of hooks
                keyboardHook?.Dispose();
                mouseHook?.Dispose();

                // Stop and dispose of macro manager
                macroManager?.Dispose();

                // Clean up UI resources
                notifyIcon?.Dispose();
                toolTip?.Dispose();

                // Close the form
                this.Close();
            }
            catch (Exception ex)
            {
                uiManager.UpdateDebugInfo($"Error during cleanup: {ex.Message}");
            }
        }
    }
}
</file>

<file path="docs/implementation_plan.md">
# MouseMacro Improvement Implementation Plan

## Overview
This plan details the specific steps to transform the MouseMacro project into a modular, professional, and maintainable application while preserving all existing functionality. The implementation follows the 12-step approach outlined in the improvement.md document.

## Progress Tracking

| Phase | Status |
|-------|--------|
| Phase 1: Preparation and Structure | ✅ Complete |
| Phase 2: Code Modularization | 🔄 In Progress (80%) |
| Phase 3: Architecture Improvements | Not Started |
| Phase 4: Documentation and Testing | Not Started |
| Phase 5: Validation and Finalization | Not Started |

## Implementation Steps

### Phase 1: Preparation and Structure

#### Step 1: Backup the Current Project
- [x] Create a full backup of the project directory
- [x] Set up version control (Git) if not already in place
- [x] Create an initial commit with the current state

```powershell
# PowerShell script to create backup
$sourceDir = "E:\CODING\Projects\CODE\Macro"
$backupDir = "E:\CODING\Projects\CODE\Macro_Backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
Copy-Item -Path $sourceDir -Destination $backupDir -Recurse
```

#### Step 2: Organize Directory Structure
- [ ] Create the following directory structure:
  ```
  MouseMacro/
  ├── src/
  │   ├── UI/
  │   ├── Configuration/
  │   ├── Hooks/
  │   ├── Utilities/
  │   ├── Models/
  ├── tests/
  ├── docs/
  ```
- [x] Move existing files to their appropriate locations
- [x] Update namespace declarations in all files
- [x] Update project file (MouseMacro.csproj) to reflect new structure

```powershell
# PowerShell script to create directory structure
$projectDir = "E:\CODING\Projects\CODE\Macro"
$directories = @(
    "src\UI\Controls",
    "src\Configuration",
    "src\Hooks",
    "src\Utilities",
    "src\Models",
    "tests",
    "docs"
)

foreach ($dir in $directories) {
    $path = Join-Path -Path $projectDir -ChildPath $dir
    if (-not (Test-Path $path)) {
        New-Item -Path $path -ItemType Directory
        Write-Host "Created directory: $path"
    }
}
```

```powershell
# PowerShell script to move files
$projectDir = "E:\CODING\Projects\CODE\Macro"

# Define file moves (source -> destination)
$fileMoves = @{
    "MacroForm.cs" = "src\UI\MacroForm.cs"
    "MacroForm.Designer.cs" = "src\UI\MacroForm.Designer.cs"
    "ModernButton.cs" = "src\UI\Controls\ModernButton.cs"
    "ModernTrackBar.cs" = "src\UI\Controls\ModernTrackBar.cs"
    "NativeMethods.cs" = "src\Hooks\NativeMethods.cs"
    "Program.cs" = "src\Program.cs"
    # Add other files as needed
}

foreach ($file in $fileMoves.Keys) {
    $sourcePath = Join-Path -Path $projectDir -ChildPath $file
    $destPath = Join-Path -Path $projectDir -ChildPath $fileMoves[$file]

    if (Test-Path $sourcePath) {
        # Create destination directory if it doesn't exist
        $destDir = Split-Path -Path $destPath -Parent
        if (-not (Test-Path $destDir)) {
            New-Item -Path $destDir -ItemType Directory
        }

        # Move the file
        Move-Item -Path $sourcePath -Destination $destPath -Force
        Write-Host "Moved: $file -> $($fileMoves[$file])"
    } else {
        Write-Host "Source file not found: $sourcePath"
    }
}
```

### Phase 2: Code Modularization

#### Step 3: Extract Hook Logic
- [x] Create KeyboardHook.cs in src/Hooks/
- [x] Create MouseHook.cs in src/Hooks/
- [x] Move hook-related code from MacroForm.cs to these classes
- [x] Implement IDisposable pattern for proper resource cleanup
- [x] Add public methods for controlling hooks (Start, Stop)
- [x] Update MacroForm.cs to use the new hook classes

#### Step 4: Create Manager Classes
- [x] Create InputSimulator.cs in src/Utilities/
- [x] Create JitterManager.cs in src/Utilities/
- [x] Create RecoilReductionManager.cs in src/Utilities/
- [x] Create MacroManager.cs in src/Utilities/
- [x] Move relevant logic from MacroForm.cs to these classes
- [x] Update MacroForm.cs to use the new manager classes

#### Step 5: Refactor MacroForm.cs
- [x] Inject manager classes into MacroForm
- [x] Remove direct event handler assignments from designer file
- [ ] Remove remaining business logic from form class
- [ ] Update event handlers to call methods on manager classes
- [ ] Keep UI-specific code in MacroForm.cs
- [ ] Implement event handlers for manager events

### Phase 3: Architecture Improvements

#### Step 6: Improve Configuration Management
- [ ] Create configuration models in src/Models/
- [ ] Enhance ConfigurationManager.cs in src/Configuration/
- [ ] Integrate Microsoft.Extensions.Configuration
- [ ] Implement validation for configuration values
- [ ] Add proper exception handling
- [ ] Store configuration in standard location
- [ ] Add backup functionality for configuration

#### Step 7: Separate UI and Business Logic
- [ ] Create IMacroView interface in src/UI/
- [ ] Implement interface in MacroForm
- [ ] Create MacroPresenter in src/UI/Presenters/
- [ ] Move business logic from MacroForm to MacroPresenter
- [ ] Update MacroForm to interact with presenter

#### Step 8: Enhance Code Quality
- [ ] Rename variables and methods for clarity
- [ ] Remove unused code and variables
- [ ] Apply consistent formatting
- [ ] Consolidate duplicated code
- [ ] Use readonly and const appropriately
- [ ] Add exception handling
- [ ] Integrate Serilog for logging

### Phase 4: Documentation and Testing

#### Step 9: Add Documentation
- [ ] Add XML comments to all public classes, methods, and properties
- [ ] Update README.md with project overview, setup instructions, and usage guidelines
- [ ] Create architecture.md in docs/ with component descriptions and design decisions
- [ ] Add inline comments for complex logic

#### Step 10: Implement Unit Tests
- [ ] Create test project using xUnit
- [ ] Write tests for hook initialization and callbacks
- [ ] Write tests for jitter and recoil reduction logic
- [ ] Write tests for configuration loading/saving
- [ ] Write tests for macro state management
- [ ] Mock dependencies using Moq
- [ ] Aim for high test coverage of critical components

### Phase 5: Validation and Finalization

#### Step 11: Test the Application
- [ ] Run the application and test all features
- [ ] Verify UI updates
- [ ] Ensure hooks work correctly
- [ ] Confirm configuration persists
- [ ] Test error handling
- [ ] Validate performance

#### Step 12: Review and Iterate
- [ ] Review code for adherence to goals
- [ ] Address issues found during testing
- [ ] Refine documentation
- [ ] Optimize performance if needed
- [ ] Commit final changes to version control

## Detailed Todo Items

### 1. Create backup of the current project
- **Description**: Create a full backup of the project directory to preserve the original code. This can be done by copying the entire project folder to a safe location or by setting up a Git repository and making an initial commit.
- **Complexity**: 1/10
- **Status**: ✅ Complete

### 2. Create new directory structure
- **Description**: Create the new directory structure as outlined in the improvement plan. This includes creating src/, tests/, and docs/ directories, with src/ further divided into UI/, Configuration/, Hooks/, Utilities/, and Models/ subdirectories.
- **Complexity**: 2/10
- **Status**: ✅ Complete

### 3. Move existing files to new directory structure
- **Description**: Move existing files to their appropriate locations in the new directory structure. Update namespace declarations in all files to reflect the new structure. Update the project file (MouseMacro.csproj) to reflect the new file paths.
- **Complexity**: 3/10
- **Status**: ✅ Complete

### 4. Create KeyboardHook class
- **Description**: Create a KeyboardHook class in src/Hooks/ directory. Extract keyboard hook-related functionality from MacroForm.cs, including hook initialization, callback methods, and disposal logic. Implement IDisposable pattern for proper resource cleanup.
- **Complexity**: 5/10
- **Status**: ✅ Complete

### 5. Create MouseHook class
- **Description**: Create a MouseHook class in src/Hooks/ directory. Extract mouse hook-related functionality from MacroForm.cs, including hook initialization, callback methods, and disposal logic. Implement IDisposable pattern for proper resource cleanup.
- **Complexity**: 5/10
- **Status**: ✅ Complete

### 6. Create InputSimulator class
- **Description**: Create an InputSimulator class in src/Utilities/ directory to handle mouse movement simulation. Extract SendInput implementation from MacroForm.cs and add methods for mouse movement simulation.
- **Complexity**: 4/10
- **Status**: ✅ Complete

### 7. Create JitterManager class
- **Description**: Create a JitterManager class in src/Utilities/ directory to handle jitter pattern generation and application. Extract jitter-related functionality from MacroForm.cs, including pattern definition, timer handling, and strength scaling.
- **Complexity**: 6/10
- **Status**: ✅ Complete

### 8. Create RecoilReductionManager class
- **Description**: Create a RecoilReductionManager class in src/Utilities/ directory to handle recoil reduction functionality. Extract recoil reduction-related code from MacroForm.cs, including timer handling, strength scaling, and movement calculation.
- **Complexity**: 6/10
- **Status**: ✅ Complete

### 9. Create MacroManager class
- **Description**: Create a MacroManager class in src/Utilities/ directory to coordinate between hook and feature managers. This class will handle macro state (enabled/disabled), mode switching, and delegate tasks to the appropriate managers.
- **Complexity**: 7/10
- **Status**: ✅ Complete

### 10. Create configuration models
- **Description**: Create configuration model classes in src/Models/ directory to represent the application's configuration. These models will be used by the ConfigurationManager to load and save settings.
- **Complexity**: 4/10
- **Status**: Not Started

### 11. Enhance ConfigurationManager class
- **Description**: Enhance the ConfigurationManager class in src/Configuration/ directory to use Microsoft.Extensions.Configuration for robust configuration handling. Implement validation, error handling, and store the configuration file in a standard location.
- **Complexity**: 8/10
- **Status**: Not Started

### 12. Create IMacroView interface
- **Description**: Create an IMacroView interface in src/UI/ directory to define the contract between the view (MacroForm) and the presenter (MacroPresenter). This interface will include methods for updating UI elements and properties for getting user input.
- **Complexity**: 3/10
- **Status**: Not Started

### 13. Create MacroPresenter class
- **Description**: Create a MacroPresenter class in src/UI/Presenters/ directory to handle business logic. This class will implement the MVP pattern, interacting with the view via the IMacroView interface and delegating tasks to the MacroManager.
- **Complexity**: 7/10
- **Status**: Not Started

### 14. Update MacroForm to implement IMacroView
- **Description**: Update the MacroForm class to implement the IMacroView interface. Remove business logic from the form and delegate tasks to the MacroPresenter. Update event handlers to call methods on the presenter. Remove direct event handler assignments from designer file and handle them programmatically.
- **Complexity**: 8/10
- **Status**: In Progress

### 15. Create unit test project
- **Description**: Create a unit test project in the tests/ directory using xUnit. Set up the project to test the core components of the application, including hook initialization, jitter and recoil reduction logic, configuration loading/saving, and macro state management.
- **Complexity**: 6/10
- **Status**: Not Started

### 16. Update project file for new structure
- **Description**: Update the MouseMacro.csproj file to reflect the new directory structure and add any required package references. This includes references to Microsoft.Extensions.Configuration, Serilog, and any other packages needed for the implementation.
- **Complexity**: 3/10
- **Status**: Not Started

### 17. Create test project file
- **Description**: Create a project file for the unit test project in the tests/ directory. Add references to xUnit, Moq, and the main project.
- **Complexity**: 2/10
- **Status**: Not Started

### 18. Update Program.cs for new structure
- **Description**: Update the Program.cs file to work with the new structure. Initialize Serilog for logging and set up the application to use the new MacroForm with the MVP pattern.
- **Complexity**: 3/10
- **Status**: Not Started

### 19. Create validation classes
- **Description**: Create validation classes in src/Configuration/ directory to validate configuration values. Implement methods for validating strength values, hotkeys, and other settings.
- **Complexity**: 4/10
- **Status**: Not Started

### 20. Update README.md with new structure
- **Description**: Update the README.md file to reflect the new project structure and implementation details. Include information about the modular architecture, MVP pattern, and other improvements.
- **Complexity**: 3/10
- **Status**: Not Started

## Timeline and Dependencies
- Phase 1 (Steps 1-2): 1 day
- Phase 2 (Steps 3-5): 3 days
- Phase 3 (Steps 6-8): 3 days
- Phase 4 (Steps 9-10): 2 days
- Phase 5 (Steps 11-12): 1 day

Total estimated time: 10 days

## Success Criteria
- All existing functionality is preserved
- Code is modular with clear separation of concerns
- Directory structure is logical and organized
- Configuration management is robust
- UI and business logic are properly separated
- Code quality is improved
- Documentation is comprehensive
- Unit tests validate critical functionality
- Application performs as expected
</file>

<file path=".gitignore">
# Build output directories
bin/*
obj/*

# Visual Studio files
.vs/
*.user
*.suo

# Temporary files
*.tmp
*.bak

# Log files
*.log

# User-specific configuration
*.userprefs

# Nuget packages (if using NuGet)
*.nupkg
obj/Debug/net6.0-windows/MouseMacro.assets.cache
obj/Debug/net6.0-windows/MouseMacro.GeneratedMSBuildEditorConfig.editorconfig

# RepoMix
.cursor/*
.git/*
.idea/*
.vs/*
.vscode/*
.repomix/*
bin/*
obj/*
</file>

<file path="docs/architecture.md">
# Mouse Macro Application Architecture

## Introduction
This document provides an overview of the Mouse Macro Application architecture. The application is designed to create and manage mouse macros, featuring a modern dark-themed UI for keybind configuration and settings management.IMPORTANT For professional system integration the application presents itself as "Notes&Tasks" and "NotesAndTasks" 😊.

## System Overview

### Identity & Integration
- **Process Name**: NotesTasks.exe
- **Display Name**: Notes&Tasks
- **Window Title**: Notes&Tasks - [Status]
- **System Tray**: Notes&Tasks with corresponding icon
- **Design Rationale**:
  - Professional appearance in enterprise environments
  - Discrete system integration
  - Consistent branding across interfaces

### System Requirements
1. **Hardware**
   - Windows 10/11 compatible PC
   - DirectX compatible display
   - Mouse with standard buttons
   - Keyboard for hotkey support
   - Optional: Multi-button mouse, high refresh rate display, SSD

2. **Software**
   - Windows 10/11 (64-bit)
   - .NET 6.0 Runtime
   - Administrator privileges
   - DirectX 9.0c or later

## Project Structure

### Directory Organization
```
MouseMacro/
├── assets/                  # Application resources
│   ├── logo.ico            # Application icon
├── bin/                    # Compiled binaries
│   ├── Debug/             # Debug build output
│   └── Release/           # Release build output
├── docs/                   # Documentation
├── obj/                    # Intermediate build files
│   ├── Debug/             # Debug build intermediates
│   │   └── net6.0-windows/
│   │       ├── ref/       # Assembly reference files
│   │       ├── refint/    # Reference interface files
│   │       └── *.cache    # Build cache files
│   └── Release/           # Release build intermediates
├── src/                    # Source code
│   ├── MacroForm.cs       # Main form implementation
│   ├── MacroForm.Designer.cs # Form designer code
│   ├── ModernButton.cs    # Custom button control
│   ├── ModernTrackBar.cs  # Custom trackbar control
│   └── Program.cs         # Application entry point
├── MouseMacro.csproj      # Project configuration
├── README.md              # Project documentation and setup guide
└── app.manifest           # Application manifest
```

## Core Components

### 1. Input System
- **Low-Level Hooks**
  - Keyboard Hook (WH_KEYBOARD_LL)
  - Mouse Hook (WH_MOUSE_LL)
  - Global event capture
  
- **Input Simulation**
  - SendInput API implementation
  - Physical mouse movement simulation
  - Game compatibility optimizations

- **Toggle System**
  - Keyboard key support
  - Mouse button support (Mouse3-5)
  - State tracking via GetAsyncKeyState

### 2. Macro Engine
- **Recoil Reduction System**
  - Vertical compensation
  - Three-tier strength distribution:
    - Tier 1 (1-6): Linear scaling
    - Tier 2 (7-16): Enhanced scaling
    - Tier 3 (17-20): Maximum impact
  - Dynamic strength adjustment
  - Default strength: 1
  
- **Jitter System**
  - Complex movement patterns
  - Strength control (1-20)
  - Optional activation
  - Default strength: 3
  
- **Mode Switching**
  - Toggle between Jitter and Recoil Reduction modes
  - Default switch key: Q
  - Always mode options (locks to either Jitter or Recoil Reduction mode at all times)
  - Independent mode states

- **Timer Management**
  - Dual timer implementation
  - Independent operation
  - Performance optimized

### 3. User Interface
- **Main Window**
  - Modern dark theme with consistent color scheme
  - Responsive layout with fluid transitions
  - DPI scaling support
  - Professional visual design
  
- **Custom Controls**
  - ModernButton
    - Customizable hover and click effects
    - Smooth color transitions
    - Consistent styling with theme
    - Professional rounded corners
  - ModernTrackBar
    - Custom slider design
    - Visual value feedback
    - Smooth drag operations
    - Theme-consistent appearance
  
- **Standard Controls**
  - Macro Toggle key display/configuration (Default: Capital)
  - Macro Switch key configuration (Default: Q)
  - Strength sliders (1-20)
  - Mode toggles and indicators
  - Always mode checkboxes
  - Debug panel (collapsible)
  
- **System Tray**
  - Minimize to tray support
  - Context menu
  - Status indication

### 4. Process Management
- **Instance Control**
  - Global mutex implementation
  - Single instance enforcement
  - Clean termination handling
  
- **Security**
  - UAC integration
  - Privilege management
  - Secure API access

### 5. Settings Configuration System
- **Configuration Manager (`ConfigurationManager.cs`)**
  - Singleton pattern implementation
  - Thread-safe operations using `ReaderWriterLockSlim`
  - JSON-based configuration storage
  - Automatic configuration backup
  - Event-driven configuration changes
  - Validation system

#### 5.1 Configuration Components
```csharp
// Root configuration
public class AppConfiguration : ICloneable
{
    public JitterConfiguration JitterSettings { get; set; }
    public RecoilConfiguration RecoilSettings { get; set; }
    public HotkeyConfiguration HotkeySettings { get; set; }
    public UIConfiguration UISettings { get; set; }
    public BackupConfiguration BackupSettings { get; set; }
}

// Feature-specific configurations
public class JitterConfiguration : ICloneable
public class RecoilConfiguration : ICloneable
public class HotkeyConfiguration : ICloneable
public class UIConfiguration : ICloneable
public class BackupConfiguration : ICloneable
```

#### 5.2 Configuration Events
```csharp
// Event Arguments
public class ConfigurationChangedEventArgs : EventArgs
public class ConfigurationValidationEventArgs : EventArgs
public class ConfigurationBackupEventArgs : EventArgs

// Event Handlers
public delegate void ConfigurationChangedEventHandler(object sender, ConfigurationChangedEventArgs e);
public delegate void ConfigurationValidationEventHandler(object sender, ConfigurationValidationEventArgs e);
public delegate void ConfigurationBackupEventHandler(object sender, ConfigurationBackupEventArgs e);
```

#### 5.3 Configuration Validation
```csharp
public static class Validation
{
    // Core validation methods
    public static void ValidateStrength(int strength, int minValue, int maxValue, string paramName)
    public static void ValidateStringNotNullOrEmpty(string value, string paramName)
    public static void ValidateNotNull<T>(T value, string paramName)
    public static void ValidateHandle(IntPtr handle, string paramName)
    public static bool ValidateHookCode(int nCode)
}

public static class SettingsValidation
{
    // Settings-specific validation
    public static bool ValidateSettings(Settings settings, int minStrength, int maxStrength)
    public static bool IsValidHotkey(Keys key)
    public static bool ValidateStrengthValue(int strength, int min, int max)
    public static bool ValidateModeStates(bool jitterEnabled, bool recoilEnabled)
}
```

#### Validation Features
1. **Input Validation**
   - Parameter validation
   - Range checking
   - Null checks
   - Empty string prevention
   
2. **Settings Validation**
   - Configuration integrity
   - Hotkey validation
   - Mode state validation
   - Strength range validation
   
3. **Handle Validation**
   - Windows handle validation
   - Hook code validation
   - Resource validation

4. **Recovery Mechanisms**
   - Default value fallback
   - State preservation
   - Error reporting
   - Automatic recovery

### 5.4 Error Handling

#### 1. Validation Errors
```csharp
try
{
    Validation.ValidateStrength(strength, min, max, paramName);
}
catch (ArgumentOutOfRangeException ex)
{
    // Reset to default value
    strength = defaultValue;
    UpdateDebugInfo($"Reset to default strength: {ex.Message}");
}
```

#### 2. Runtime Errors
```csharp
try
{
    // Critical operation
}
catch (Exception ex)
{
    UpdateDebugInfo($"Error: {ex.Message}");
    // Cleanup and recovery
    CleanupResources();
    RestoreState();
}
```

#### 3. Resource Management
```csharp
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        // Cleanup resources
        jitterTimer?.Dispose();
        keyboardHookID = IntPtr.Zero;
        mouseHookID = IntPtr.Zero;
    }
    base.Dispose(disposing);
}
```

#### 4. Debug System
```csharp
private void UpdateDebugInfo(string message)
{
    if (debugLabel.InvokeRequired)
    {
        debugLabel.Invoke(new Action(() => UpdateDebugInfo(message)));
        return;
    }

    string timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
    string newLine = $"[{timestamp}] {message}";
    
    // Keep last 100 lines
    var lines = debugLabel.Lines.ToList();
    lines.Add(newLine);
    if (lines.Count > 100)
        lines.RemoveAt(0);
        
    debugLabel.Lines = lines.ToArray();
    debugLabel.SelectionStart = debugLabel.TextLength;
    debugLabel.ScrollToCaret();
}
```

### 6. Event Handler System

#### 6.1 Event Handler Manager
```csharp
public class EventHandlerManager : IDisposable
{
    private readonly Dictionary<string, List<Delegate>> eventHandlers;
    private readonly ConfigurationManager configManager;
    
    // Event registration methods
    public void RegisterControlEvents(Control control)
    public void UnregisterControlEvents(Control control)
    private void RegisterEventHandler(string eventName, Delegate handler)
    
    // Configuration event handlers
    private void OnConfigurationChanged(object sender, ConfigurationChangedEventArgs e)
    private void OnConfigurationValidating(object sender, ConfigurationValidationEventArgs e)
    private void OnConfigurationBackupCompleted(object sender, ConfigurationBackupEventArgs e)
}
```

#### 6.2 Event Handler Extensions
```csharp
public static class EventHandlerExtensions
{
    // Generic registration
    public static T RegisterEvents<T>(this T control, EventHandlerManager manager)
    public static T UnregisterEvents<T>(this T control, EventHandlerManager manager)
    
    // Control-specific registration
    public static TrackBar RegisterTrackBarEvents(...)
    public static CheckBox RegisterCheckBoxEvents(...)
    public static Button RegisterButtonEvents(...)
    public static TextBox RegisterTextBoxEvents(...)
}
```

#### 6.3 Event Categories
1. **Configuration Events**
   - Configuration changes
   - Validation events
   - Backup events

2. **Control Events**
   - TrackBar events (ValueChanged, Scroll)
   - CheckBox events (CheckedChanged)
   - Button events (Click, MouseDown, MouseUp)
   - TextBox events (TextChanged, KeyDown)

3. **System Events**
   - Window events
   - Application lifecycle events
   - Error events

#### 6.4 Event Handler Features
- Centralized event management
- Automatic cleanup on disposal
- Type-safe event registration
- Fluent API support
- Event tracking and logging
- Error handling and recovery

### 7. Project Structure Update
```
MouseMacro/
├── src/
│   ├── Configuration/           # Configuration system
│   │   ├── ConfigurationManager.cs
│   │   ├── AppConfiguration.cs
│   │   ├── ConfigurationEvents.cs
│   │   ├── EventHandlerManager.cs
│   │   └── EventHandlerExtensions.cs
│   ├── Controls/               # UI Controls
│   │   ├── ModernButton.cs
│   │   └── ModernTrackBar.cs
│   ├── MacroForm.cs           # Main form
│   ├── MacroForm.Designer.cs  # Form designer
│   └── Program.cs             # Entry point
```

## Macro Implementation Details

### 1. Core Macro Logic
- **Language**: C#
- **Primary Components**:
  - Recoil reduction system
  - Jitter pattern generation
  - State management
  - Timer-based execution

#### 1.1 Recoil Reduction System
- **Implementation**:
  ```csharp
  private void OnRecoilReductionTimer(object state)
  {
      if (IsRecoilReductionActive)
      {
          int strength = recoilReductionStrength.Value;
          int scaledStrength = CalculateScaledStrength(strength);
          SendInput.MoveMouse(0, scaledStrength);
      }
  }

  private int CalculateScaledStrength(int strength)
  {
      if (strength <= 6) // Tier 1
          return strength;
      else if (strength <= 13) // Tier 2
          return 6 + (strength - 6) * 2;
      else // Tier 3
          return 20 + (strength - 13) * 3;
  }
  ```
- **Features**:
  - Vertical movement compensation
  - Three-tier strength scaling system
  - Dynamic strength calculation
  - Optimized performance
  - Smooth movement patterns

#### 1.2 Jitter System
- **Pattern Definition**:
  ```csharp
  private readonly (int dx, int dy)[] jitterPattern = {
      (0, 6), (7, 7), (-7, -7), (7, -7), (-7, 7),
      (0, -6), (-6, 0), (6, 0), (5, 5), (-5, -5)
  };
  ```
- **Implementation**:
  ```csharp
  private void OnJitterTimer(object state)
  {
      if (IsJitterActive && currentPattern < jitterPattern.Length)
      {
          var (dx, dy) = jitterPattern[currentPattern];
          SendInput.MoveMouse(
              dx * jitterStrength.Value / 10,
              dy * jitterStrength.Value / 10
          );
          currentPattern = (currentPattern + 1) % jitterPattern.Length;
      }
  }
  ```
- **Features**:
  - Complex movement patterns
  - Pattern cycling
  - Strength scaling
  - Independent activation

### 2. State Management

#### 2.1 Activation States
```csharp
private bool IsRecoilReductionActive => 
    MacroEnabled && 
    (GetAsyncKeyState(VK_LBUTTON) < 0) && 
    (GetAsyncKeyState(VK_RBUTTON) < 0);

private bool IsJitterActive =>
    MacroEnabled && 
    (JitterEnabled || alwaysJitterMode) && 
    !alwaysRecoilReductionMode && 
    IsRecoilReductionActive;
```

#### 2.2 Mode Management
```csharp
private void ToggleMacroMode()
{
    // If either always mode is on, we can't switch modes
    if (alwaysJitterMode || alwaysRecoilReductionMode)
        return;

    // Toggle between jitter and recoil reduction modes
    jitterEnabled = !jitterEnabled;
    UpdateModeLabels();
}

private void UpdateModeLabels()
{
    lblJitterActive.Text = jitterEnabled || alwaysJitterMode ? "[Active]" : "";
    lblRecoilReductionActive.Text = !jitterEnabled || alwaysRecoilReductionMode ? "[Active]" : "";
}
```

#### 2.3 Toggle System
- **Keyboard Implementation**:
  ```csharp
  private IntPtr KeyboardProc(int nCode, IntPtr wParam, IntPtr lParam)
  {
      if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
      {
          var kb = (KBDLLHOOKSTRUCT)Marshal.PtrToStructure(lParam, typeof(KBDLLHOOKSTRUCT));
          if (kb.vkCode == ToggleKey)
          {
              MacroEnabled = !MacroEnabled;
              UpdateWindowTitle();
          }
      }
      return CallNextHookEx(KeyboardHook, nCode, wParam, lParam);
  }
  ```

- **Mouse Implementation**:
  ```csharp
  private IntPtr MouseProc(int nCode, IntPtr wParam, IntPtr lParam)
  {
      if (nCode >= 0)
      {
          var mouseData = (MSLLHOOKSTRUCT)Marshal.PtrToStructure(lParam, typeof(MSLLHOOKSTRUCT));
          if (wParam == (IntPtr)WM_XBUTTONDOWN)
          {
              int button = mouseData.mouseData >> 16;
              if (button == ToggleButton)
              {
                  MacroEnabled = !MacroEnabled;
                  UpdateWindowTitle();
              }
          }
      }
      return CallNextHookEx(MouseHook, nCode, wParam, lParam);
  }
  ```

### 3. Timer System

#### 3.1 Timer Configuration
```csharp
private readonly System.Windows.Forms.Timer recoilReductionTimer;
private readonly System.Windows.Forms.Timer jitterTimer;

private void InitializeTimers()
{
    recoilReductionTimer = new System.Windows.Forms.Timer
    {
        Interval = 16,  // ~60Hz
        Enabled = true
    };
    recoilReductionTimer.Tick += OnRecoilReductionTimer;

    jitterTimer = new System.Windows.Forms.Timer
    {
        Interval = 25,  // 40Hz
        Enabled = true
    };
    jitterTimer.Tick += OnJitterTimer;
}
```

#### 3.2 Performance Optimization
- **Timer Intervals**:
  - Recoil Reduction: 16ms (60Hz) for smooth movement
  - Jitter: 25ms (40Hz) for pattern execution
  - Balanced for performance and responsiveness

- **Resource Management**:
  ```csharp
  protected override void Dispose(bool disposing)
  {
      if (disposing)
      {
          recoilReductionTimer?.Dispose();
          jitterTimer?.Dispose();
      }
      base.Dispose(disposing);
  }
  ```

### 4. Input Simulation

#### 4.1 SendInput Implementation
```csharp
public static class SendInput
{
    [DllImport("user32.dll")]
    private static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

    public static void MoveMouse(int dx, int dy)
    {
        var input = new INPUT
        {
            type = INPUT_MOUSE,
            u = new InputUnion
            {
                mi = new MOUSEINPUT
                {
                    dx = dx,
                    dy = dy,
                    mouseData = 0,
                    dwFlags = MOUSEEVENTF_MOVE,
                    time = 0,
                    dwExtraInfo = IntPtr.Zero
                }
            }
        };

        SendInput(1, new[] { input }, Marshal.SizeOf(typeof(INPUT)));
    }
}
```

#### 4.2 Low-Level Hooks
```csharp
private const int WH_KEYBOARD_LL = 13;
private const int WH_MOUSE_LL = 14;

private IntPtr SetWindowsHookEx(int idHook, HookProc lpfn)
{
    using var curProcess = Process.GetCurrentProcess();
    using var curModule = curProcess.MainModule;
    return SetWindowsHookEx(idHook, lpfn, 
        GetModuleHandle(curModule.ModuleName), 0);
}
```

### 5. Debug System

#### 5.1 State Monitoring
```csharp
private void UpdateDebugInfo()
{
    if (debugTextBox.Visible)
    {
        var info = $"[{DateTime.Now:HH:mm:ss.fff}] " +
                   $"Macro: {(MacroEnabled ? "ON" : "OFF")} | " +
                   $"Recoil Reduction: {(IsRecoilReductionActive ? "Active" : "Inactive")} | " +
                   $"Jitter: {(IsJitterActive ? "Active" : "Inactive")} | " +
                   $"LMB: {(GetAsyncKeyState(VK_LBUTTON) < 0)} | " +
                   $"RMB: {(GetAsyncKeyState(VK_RBUTTON) < 0)}";
        
        debugTextBox.AppendText(info + Environment.NewLine);
    }
}
```

#### 5.2 Performance Monitoring
```csharp
private readonly Stopwatch perfTimer = new();
private void MeasurePerformance(Action action, string operation)
{
    if (debugTextBox.Visible)
    {
        perfTimer.Restart();
        action();
        perfTimer.Stop();
        
        UpdateDebugInfo($"{operation}: {perfTimer.ElapsedMilliseconds}ms");
    }
    else
    {
        action();
    }
}
```

## Build System

### Configurations
1. **Debug Build**
   - Location: `bin/Debug/net6.0-windows/`
   - Debug symbols and logging
   - Development features enabled
   
2. **Release Build**
   - Location: `bin/Release/net6.0-windows/`
   - Optimized performance
   - Production ready

### Build Process
- **Automated Script**: `build.bat`
  - Admin privilege elevation
  - Environment preparation
  - Dual configuration builds
  - Error handling

## Usage Guide

### Application Lifecycle
1. **Startup**
   - Admin rights elevation
   - Single instance check
   - System tray initialization

2. **Runtime**
   - Background operation
   - Resource optimization
   - State management
   
3. **Shutdown**
   - Clean termination
   - Resource cleanup
   - Settings preservation

### Troubleshooting
1. **Common Issues**
   - Instance conflicts
   - Admin privileges
   - Performance optimization
   - Resource management

2. **Debug Mode**
   - Real-time monitoring
   - Event logging
   - Performance metrics
   - Error tracking

## Performance Optimization
1. **Resource Management**
   - Efficient hook handling
   - Minimal GC impact
   - Handle management
   
2. **CPU Usage**
   - Timer optimization
   - Event throttling
   - Efficient state checks

## Security Considerations
1. **Process Protection**
   - Mutex implementation
   - Process name obfuscation
   
2. **Privilege Management**
   - Manifest-based elevation
   - Runtime privilege checks
   - Secure API access

## Maintenance
1. **Regular Updates**
   - Runtime compatibility
   - Security patches
   - Feature updates
   
2. **Code Maintenance**
   - Performance optimization
   - Security audits
   - Documentation updates
</file>

<file path="README.md">
# Notes & Tasks (Mouse Macro)

A professional Windows Forms application for advanced mouse input management, featuring recoil compensation and jitter pattern generation. IMPORTANT For professional system integration the application presents itself as "Notes&Tasks" or "NotesAndTasks" 😊.

## Features

- **Recoil Reduction System**
  - Advanced vertical compensation with three-tier scaling:
    - Tier 1 (1-6): Linear scaling with logarithmic base
    - Tier 2 (7-16): Enhanced scaling with 1.2x multiplier
    - Tier 3 (17-20): Exponential scaling with dynamic boost
  - Real-time strength adjustment (1-20)
  - Default strength: 1
  - Optimized movement patterns

- **Jitter System**
  - Complex 24-point movement pattern
  - Dynamic strength scaling (1-20)
  - Default strength: 3
  - Pattern cycling with smooth transitions
  - Optimized for performance

- **Mode Switching**
  - Intelligent mode toggling
  - Support for keyboard and mouse buttons (Mouse3-5)
  - Always mode options with validation
  - Real-time mode state tracking
  - Visual state indicators

- **Professional Integration**
  - Clean system tray integration
  - Modern dark theme UI
  - DPI-aware scaling
  - Single instance enforcement
  - Professional window management

- **Configuration Management System**
  - Thread-safe configuration handling
  - JSON-based settings storage
  - Automatic configuration backup
  - Comprehensive validation system:
    - Pre-save validation
    - Type validation
    - Range validation
    - Cross-property validation
  - Event-driven updates
  - Configuration sections:
    - Jitter settings
    - Recoil reduction settings
    - Hotkey bindings
    - UI preferences
    - Backup settings

- **Event Handler System**
  - Centralized event management
  - Automatic resource cleanup
  - Type-safe event registration
  - Fluent API for control events
  - Comprehensive error handling:
    - Exception tracking
    - State recovery
    - Debug logging
  - Event categories:
    - Configuration events
    - Control events
    - System events

- **Debug System**
  - Real-time state monitoring
  - Performance tracking
  - Event logging
  - Error tracking
  - Thread-safe logging

- **Settings Saved with JSON**
  - Settings saved automatically into a JSON file
  - JSON file located at the executable directory
  - Settings automatically saved while running the Application
  - Settings automatically loaded upon starting the Application

## Requirements

### Hardware
- Windows 10/11 compatible PC
- DirectX compatible display
- Mouse with standard buttons
- Keyboard for hotkey support

### Software
- Windows 10/11 (64-bit)
- .NET 6.0 Runtime
- Administrator privileges
- DirectX 9.0c or later

### Optional
- Multi-button mouse for extended features
- High refresh rate display (recommended)
- SSD for faster startup (recommended)

## Installation

1. **Download**
   - Get the latest release from the releases page
   - Choose between Debug and Release builds

2. **Setup**
   - Extract the files to your preferred location
   - No installation required (portable application)
   - Run `NotesAndTasks.exe` with administrator privileges

## Building from Source

### Method 1: Using Build Script
1. Clone the repository
2. Double-click `build.bat`
   - Script automatically requests admin rights
   - Builds both Debug and Release configurations

### Method 2: Manual Build
1. Open command prompt
2. Navigate to project directory
3. Run commands:
   ```cmd
   # Debug build
   dotnet build -c Debug

   # Release build
   dotnet build -c Release
   ```

### Output Locations
- Debug: `bin/Debug/net6.0-windows/NotesAndTasks.exe`
- Release: `bin/Release/net6.0-windows/NotesAndTasks.exe`

## Usage Guide

### Basic Controls
1. **Macro Toggle Key (Macro ON/OFF)**
   - Click "Set Toggle Key" button
   - Press any key to set as macro toggle
   - Default: 'Capital' key
   - Supports keyboard and mouse buttons (Mouse3-5)
   - LMB/RMB reserved for activation

2. **Mode Switch Key**
   - Click "Set Switch Key" button
   - Press any key to set as switch toggle
   - Default: 'Q' key
   - Supports keyboard and mouse buttons (Mouse3-5)
   - LMB/RMB reserved for activation

3. **Strength Adjustment**
   - Use slider to set strength (1-20)
   - Changes apply immediately
   - Recoil Reduction default: 1
   - Jitter default: 3

4. **Always Mode Options**
   - Always Jitter Mode: Locks to jitter
   - Always Recoil Reduction Mode: Locks to recoil reduction
   - Prevents mode switching while active

5. **System Tray**
   - Optional minimize to tray
   - Double-click tray icon to restore
   - Right-click for context menu
   - Clean exit via tray menu

### Usage Scenarios

#### 1. Dynamic Mode Switching
```
1. Press Toggle Key → Macro ON
2. Press Q to switch between modes
3. Hold LMB + RMB → Current mode activates
4. Release buttons → Effect stops
5. Press Q again → Switch to other mode
```

#### 2. Always Jitter Mode
```
1. Enable "Always Jitter Mode" checkbox
2. Press Toggle Key → Macro ON
3. Hold LMB + RMB → Jitter pattern active
4. Release buttons → Jitter stops
5. Q key has no effect (locked to jitter)
```

#### 3. Always Recoil Reduction Mode
```
1. Enable "Always Recoil Reduction Mode"
2. Press Toggle Key → Macro ON
3. Hold LMB + RMB → Recoil reduction active
4. Release buttons → Effect stops
5. Q key has no effect (locked to recoil reduction)
```

#### 4. Strength Optimization
```
1. Start with default strengths:
   - Recoil Reduction: 1
   - Jitter: 3
2. Test each mode
3. Adjust strength per mode as needed
4. Settings persist between mode switches
```

### Important Notes
- Effects ONLY activate when BOTH buttons are held
- Mode switch key (Q) works in real-time
- Always mode prevents accidental switching
- Each mode maintains its own strength setting
- Visual indicators show current active mode
- Window title reflects current state

### Settings Configuration
- **Configuration Manager**
  - Thread-safe operations with ReaderWriterLockSlim
  - Automatic backups with versioning
  - Real-time validation with error recovery
  - Event notifications with detailed state
  
- **Validation System**
  - Comprehensive input validation
  - Type safety checks
  - Range validation
  - Cross-property validation
  - Error reporting with context
  - Recovery mechanisms

- **Event System**
  - Configuration change tracking
  - Validation event handling
  - Backup completion notifications
  - Error event propagation
  - State change notifications

### Error Handling
- **Validation Errors**
  - Automatic recovery
  - Default value fallback
  - User notification
  - State preservation

- **Runtime Errors**
  - Exception handling
  - Resource cleanup
  - State recovery
  - Debug logging
  - User feedback

## Troubleshooting

### Common Issues

1. **"Another instance is running"**
   - Check Task Manager
   - End existing process if necessary
   - Restart application

2. **Admin Rights Required**
   - Run as administrator
   - Use build.bat for automatic elevation
   - Check app.manifest settings

3. **Performance Issues**
   - Switch to Release build
   - Check system resources
   - Adjust timer intervals
   - Monitor debug panel

## Development

### Environment Setup
1. Install Visual Studio 2022 or later
2. Install .NET 6.0 SDK
3. Clone repository
4. Open solution file

### Project Structure
```
MouseMacro/
├── assets/                  # Application resources
│   ├── logo.ico            # Application icon
├── bin/                    # Compiled binaries
│   ├── Debug/             # Debug build output
│   └── Release/           # Release build output
├── docs/                   # Documentation
│   ├── architecture.md    # Detailed architecture documentation
├── src/                   # Source code
│   ├── Configuration/     # Configuration system
│   │   ├── ConfigurationManager.cs
│   │   ├── AppConfiguration.cs
│   │   ├── ConfigurationEvents.cs
│   │   ├── EventHandlerManager.cs
│   │   ├── EventHandlerExtensions.cs
│   │   ├── SettingsValidation.cs
│   │   └── Validation.cs
│   ├── Controls/         # UI Controls
│   │   ├── ModernButton.cs
│   │   └── ModernTrackBar.cs
│   ├── MacroForm.cs      # Main form implementation
│   ├── MacroForm.Designer.cs
│   ├── NativeMethods.cs  # Windows API interop
│   ├── WinMessages.cs    # Windows message constants
│   └── Program.cs        # Application entry point
├── MouseMacro.csproj     # Project configuration
├── README.md             # Project documentation
└── app.manifest         # Application manifest
```

## Contributing
1. Fork the repository
2. Create feature branch
3. Commit changes
4. Submit pull request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- Windows Forms (.NET 6.0)
- Windows API (user32.dll)
- .NET Community
</file>

</files>
